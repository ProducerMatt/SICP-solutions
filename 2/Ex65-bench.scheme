;; [[file:../Answers.org::*Answer][Answer:4]]
(use-modules (ice-9 format))
(load "../mattbench.scm")
;; [[[[file:~/SICP-group/Answers.org::sets-txt][sets-txt]]][sets-txt]]
(define (element-of-set?-manual x set)
  (cond ((null? set) #f)
        ((equal? x (car set)) #t)
        (else (element-of-set? x (cdr set)))))
(define element-of-set? member) ; builtins are faster :)

(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))

(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) 
         '())
        ((element-of-set? (car set1) set2)
         (cons (car set1)
               (intersection-set (cdr set1) 
                                 set2)))
        (else (intersection-set (cdr set1) 
                                set2))))
;; sets-txt ends here
;; [[[[file:~/SICP-group/Answers.org::sets-as-trees][sets-as-trees]]][sets-as-trees]]
;; [[[[file:~/SICP-group/Answers.org::make-tree][make-tree]]][make-tree]]
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))
;; make-tree ends here
;; [[[[file:~/SICP-group/Answers.org::list-to-tree][list-to-tree]]][list-to-tree]]
;; [[[[file:~/SICP-group/Answers.org::make-tree][make-tree]]][make-tree]]
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))
;; make-tree ends here
(define (list->tree elements)
  (car (partial-tree elements (length elements))))
(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result
               (partial-tree elts left-size)))
          (let ((left-tree (car left-result))
                (non-left-elts (cdr left-result))
                (right-size (- n (+ left-size 1))))
            (let ((this-entry (car non-left-elts))
                  (right-result
                   (partial-tree
                    (cdr non-left-elts)
                    right-size)))
              (let ((right-tree (car right-result))
                    (remaining-elts
                     (cdr right-result)))
                (cons (make-tree this-entry
                                 left-tree
                                 right-tree)
                      remaining-elts))))))))
;; list-to-tree ends here
;; [[[[file:~/SICP-group/Answers.org::tree-to-list][tree-to-list]]][tree-to-list]]
;; [[[[file:~/SICP-group/Answers.org::make-tree][make-tree]]][make-tree]]
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))
;; make-tree ends here
(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree)
                    (tree->list-1
                      (right-branch tree))))))
(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list
                              (right-branch tree)
                              result-list)))))
  (copy-to-list tree '()))
;; tree-to-list ends here
;; [[[[file:~/SICP-group/Answers.org::tree-sets-txt][tree-sets-txt]]][tree-sets-txt]]
(define (element-of-set?-tree x set)
  (cond ((null? set) #f)
        ((= x (entry set)) #t)
        ((< x (entry set))
         (element-of-set?-tree
          x 
          (left-branch set)))
        ((> x (entry set))
         (element-of-set?-tree
          x 
          (right-branch set)))))
(define (adjoin-set-tree x set)
  (cond ((null? set) (make-tree x '() '()))
        ((= x (entry set)) set)
        ((< x (entry set))
         (make-tree 
          (entry set)
          (adjoin-set-tree x (left-branch set))
          (right-branch set)))
        ((> x (entry set))
         (make-tree
          (entry set)
          (left-branch set)
          (adjoin-set-tree x (right-branch set))))))
;; tree-sets-txt ends here

(define (tree->list-debug tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (let ((result
               (begin (echo ">> entering tree at" (entry tree) "results" result-list)
                      (copy-to-list (left-branch tree)
                                    (begin (echo "we'll cons" (entry tree))
                                           (let ((pair
                                                  (cons (entry tree)
                                                        (copy-to-list
                                                         (right-branch tree)
                                                         result-list))))
                                             (echo "  cons'd" pair)
                                             pair))))))
          (echo "<< leaving tree at" (entry tree) "results" result-list)
          result)))
  (copy-to-list tree '()))

(define (union-set-tree-wrong1 set1 set2)
  (define (copy-to-list tree held-tree result-list)
    (define (swap-trees)
      (copy-to-list held-tree tree result-list))
    (define (advance-tree-no-cons)
      (copy-to-list (left-branch tree)
                    held-tree
                    (copy-to-list
                     (right-branch tree)
                     held-tree
                     result-list)))
    (define (advance-tree-cons)
      (copy-to-list (left-branch tree)
                    held-tree
                    (cons (entry tree)
                          (copy-to-list
                           (right-branch tree)
                           held-tree
                           result-list))))
    (define (advance-both-cons)
      (copy-to-list (left-branch tree)
                    held-tree
                    (cons (entry tree)
                          (copy-to-list
                           (right-branch tree)
                           held-tree
                           result-list))))
    (cond ((and (null? tree)
                (null? held-tree))
           result-list)
          ((null? tree)
           (swap-trees))
          ((= (entry tree)
              (car result-list))
           (advance-tree-no-cons))
          ((= (entry tree) (entry held-tree))
           (advance-both-cons))
          ((< (entry tree) (entry held-tree))
           (advance-tree-cons))
          ((> (entry tree) (entry held-tree))
           (swap-trees))))
  (copy-to-list set1 set2 '()))

(define (union-set-tree-wrong2 set1 set2)
  (define (copy-to-tree tree result-tree)
    (if (null? tree)
        result-tree
        (copy-to-tree (left-branch tree)
                      (adjoin-set-tree (entry tree)
                                       (copy-to-tree
                                        (right-branch tree)
                                        result-tree)))))
  (copy-to-tree set1 set2))

(define (intersection-set-tree-wrong1 set1 set2)
  (define (copy-to-tree tree result-tree)
    (if (null? tree)
        result-tree
        (let ((adjoin-or-not
               (lambda (rest)
                 (if (element-of-set?-tree (entry tree)
                                           set2)
                     (adjoin-set-tree (entry tree)
                                      rest)
                     rest))))
          (copy-to-tree (left-branch tree)
                        (adjoin-or-not
                         (copy-to-tree
                          (right-branch tree)
                          result-tree))))))
    (copy-to-tree set1 '()))
;; sets-as-trees ends here
;; [[[[file:~/SICP-group/Answers.org::enumerate-interval][enumerate-interval]]][enumerate-interval]]
(define (enumerate-interval low high)
  (if (> low high)
      '()
      (cons low 
            (enumerate-interval 
             (+ low 1) 
             high))))
;; enumerate-interval ends here
(define tree->list tree->list-2)
(define (union-set set1 set2)
  (cond ((or (null? set1) (null? set2))
         set2)
        ((element-of-set? (car set1) set2)
         (union-set (cdr set1)
                        set2))
        (else (cons (car set1)
                    (union-set (cdr set1)
                                   set2)))))

;; from http://community.schemewiki.org/?sicp-ex-2.65
(define (union-set-l2t set1 set2)
  (cond ((null? set1) set2)
        ((null? set2) set1)
        (else (list->tree (union-set (tree->list set1) (tree->list set2))))))

(define (intersection-set-l2t set1 set2)
  (cond ((null? set1) '())
        ((null? set2) '())
        (else (list->tree (intersection-set (tree->list set1) (tree->list set2))))))

(define (make-2sets max)
  (let* ((a-start 0)
         (a-end 0.6)
         (b-start 0.4)
         (b-end 1))
    (cons (list->tree
           (enumerate-interval
            0
            (inexact->exact (* a-end max))))
          (list->tree
           (enumerate-interval
            (inexact->exact (* b-start max))
            (inexact->exact (* b-end max)))))))

(define (test-with 2sets repeats)
  (format #t "~&union-set-tree-wrong2: ~a"
          (cadr (mattbench2
                 (位()(union-set-tree-wrong2
                      (car 2sets)
                      (cdr 2sets)))
                 repeats)))
  (format #t "~&union-set-l2t: ~a"
          (cadr (mattbench2
                 (位()(union-set-l2t (car 2sets)
                                    (cdr 2sets)))
                 repeats)))
  (format #t "~&intersection-set-tree-wrong1: ~a"
          (cadr (mattbench2
                 (位()(intersection-set-tree-wrong1
                      (car 2sets)
                      (cdr 2sets)))
                 repeats)))
  (format #t "~&intersection-set-l2t: ~a"
          (cadr (mattbench2
                 (位()(intersection-set-l2t (car 2sets)
                                           (cdr 2sets)))
                 repeats))))
(format #t "~&~a" (make-2sets 10))
(define base-repeats 10000)
(test-with (make-2sets 100)
           base-repeats)
(test-with (make-2sets 1000)
           (/ base-repeats 2))
(test-with (make-2sets 10000)
           (/ base-repeats 4))
;; Answer:4 ends here
