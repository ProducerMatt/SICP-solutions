# Enable TOC at top of document
#+OPTIONS: toc:t stat:t prop:t num:20

# Don't export sections tagged "noexport"
#+EXCLUDE_TAGS: noexport

# Open document folded
#+STARTUP: overview

# for org agenda, tag items with whether they are math-heavy or optional
#+TAGS: math optional

# Tangle when saving
#+auto_tangle: t

# ORG-BABEL DEFAULTS
#+PROPERTY: header-args :tangle no :noeval :exports both :cache yes :results output wrap :noweb no-export :comments noweb :colnames no :rownames no
#+PROPERTY: header-args:scheme :wrap EXAMPLE
#+PROPERTY: header-args:gnuplot :prelude "reset" :session nil
#+PROPERTY: header-args:mermaid :exports results

# For the actual answers use a header like this:
# #+BEGIN_SRC scheme -n :eval no-export :exports both
# For their dependencies:
# #+BEGIN_SRC scheme -n :eval no-export :results silent

#+latex_class: article
#+latex_class_options: [final,fleqn,titlepage,twoside,twocolumn]
#+latex_engraved_theme:

#+LATEX_COMPILER: xelatex
#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \usepackage{calligra}
#+LATEX_HEADER: \usepackage{lmodern}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \setmonofont[Mapping=tex-text,Ligatures=TeX,Scale=MatchLowercase]{FiraMono-Regular}

# SOURCE CODE HIGHLIGHTING
#+LATEX_HEADER: \usepackage[cache=true]{minted}
#+LATEX_HEADER: \usemintedstyle{colorful}
#+LATEX_HEADER: \setminted{fontsize=\small}
# FIXME: keep minted inline code from being automatically wrapped
#+LATEX_HEADER: \setmintedinline{breakbytoken=false,breakbytokenanywhere=false,breaklines=false,breakaftergroup=false}

# SOURCE CODE FRAMES
#+LATEX_HEADER: \usepackage{mdframed}
#+LATEX_HEADER: \definecolor{my-bg}{rgb}{0.99,0.99,0.99}
#+LATEX_HEADER: \definecolor{gray}{rgb}{0.60,0.60,0.60}

#+LATEX_HEADER: \mdfdefinestyle{theoremstyle}{%
#+LATEX_HEADER: linecolor=gray,linewidth=.5pt,%
#+LATEX_HEADER: backgroundcolor=my-bg
#+LATEX_HEADER: }

#+LATEX_HEADER: \usepackage{etoolbox}
#+LATEX_HEADER: \BeforeBeginEnvironment{minted}{\begin{mdframed}[style=theoremstyle]}
#+LATEX_HEADER: \AfterEndEnvironment{minted}{\end{mdframed}}

# listfiles leaves a list of all files used during processing in the log
# in-Emacs renders log to a buffer, not a file
#+LATEX_HEADER: \listfiles

#+title: A Journey Through SICP
#+subtitle: Notes, exercises and analyses of Abelson and Sussman
#+AUTHOR: ProducerMatt
#+date: \today

* HOW THIS DOCUMENT IS MADE :UNNUMBERED:noexport:

**TODO**
#+NAME: testing
#+BEGIN_SRC scheme -n :exports both :eval no-export :results value
(define (foo a b)
  (+ a (* 2 b)))

(foo 5 3)
#+END_SRC

#+RESULTS[57407d275aacd484646294a75251646c910ae5fc]: testing
:results:
11
:end:

^ Dynamically evaluated when you press "enter" on the ~BEGIN_SRC~ block!

*** Also consider:

- ~:results output~ for what the code prints
- ~:exports code~ or ~:exports results~ to just get one or the other

\(a + (\pi \times b)\) <~ inline Latex btw :)

*** Reduce image size

#+BEGIN_SRC org
#+ATTR_LATEX: :width 0.6\linewidth
#+END_SRC

*** Convert .svg's to .pngs

#+BEGIN_SRC shell
fd . -e svg -tf -E old --exec magick '{}' '{.}'.png
#+END_SRC

** Helpers for org-mode tables

*** ~try-these~

Takes function ~f~ and list ~testvals~ and applies ~f~ to each item ~i~. For
each ~i~ returns a list with ~i~ and the result. Useful dor making tables with a
column for input and a column for output.
#+NAME: try-these
#+BEGIN_SRC scheme -n :eval no-export :results silent
;; Surely this could be less nightmarish
(define (try-these f . testvals)
  (let ((l (if (and (= 1 (length testvals))
                    (list? (car testvals)))
               (car testvals)
               testvals)))
    (map (λ (i) (cons i
                      (cons (if (list? i)
                                (apply f i)
                                (f i))
                            #nil)))
         l)))
#+end_src

*** ~transpose-list~

"Rotate" a list, for example from src_scheme{'(1 2 3)} to
src_scheme{'('(1) '(2) '(3))}
#+NAME: transpose-list
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (transpose-list l)
  (map list l))
#+end_src

*** ~print-as-rows~

For manually printing items in rows to stdout. Can be helpful for gnuplot.
#+NAME: print-as-rows
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (p-nl a)
  (display a)
  (newline))
(define (print-spaced args)
  (let ((a (car args))
        (d (cdr args)))
    (if (null? d)
        (p-nl a)
        (begin (display a)
               (display " ")
               (print-spaced d)))))
(define (print-as-rows . args)
  (let ((a (car args))
        (d (cdr args)))
    (if (list? a)
        (if (= 1 (length args))
            (apply print-as-rows a)
            (print-spaced a))
        (p-nl a))
    (if (null? d)
        '()
        (apply print-as-rows d))))
#+end_src

*** ~print-table~

Print ~args~ as a table separated by pipes. Optionally print spacer for
colnames.
#+NAME: print-table
#+BEGIN_SRC scheme -n :eval no-export :results output :exports code
(use-modules (ice-9 format))
(define* (print-row ll #:key (mode #f))
  (let ((fmtstr
         (cond ((or (eq? mode #f)
                    (equal? mode "display")
                    (equal? mode "~a"))
                " ~a |")    ;; print objects for human viewing
               ((or (eq? mode #t)
                    (equal? mode "write")
                    (equal? mode "~s"))
                " ~s |") ;; print objects for correctly (read)ing back
               ((string? mode)
                mode)))) ;; pass custom format string
      (format #t "~&|")
      (map (λ(x) (format #t fmtstr x)) ll)
      (format #t "~%")))
(define* (print-table table #:key (colnames #f) (mode #f))
    (define (iter t)
      (print-row (car t) #:mode mode)
      (if colnames
          (print-row (car t) #:mode "---|"))
      (map (λ(x) (print-row x #:mode mode)) (cdr t)))
    (cond ((and (= 1 (length table))
                (list? (car table))) (iter (car table)))
          ((<= 1 (length table)) (iter table))
          (else error "Invalid Input??")))
#+end_src

#+RESULTS[19c84289ba2a3641df209da53bc4715f762f5ca7]: print-table
:results:
:end:

#+NAME: print-table-test
#+BEGIN_SRC scheme -n :eval no-export  :results table output :exports no :rownames yes :colnames yes
<<print-table>>
(let* ((l (iota 3))
      (table (list
              (list 'column-1 'column-2 'column-3 'column-4)
              (cons 'row-a l)
              (cons 'row-b l)
              (cons 'row-c l))))
  (print-table table #:colnames #t ))
#+end_src

#+RESULTS[6c949ef04c9d52908df9234c749648b0b1a3b9e9]: print-table-test
:results:
| column-1 | column-2 | column-3 | column-4 |
|----------+----------+----------+----------|
| row-a    |        0 |        1 |        2 |
| row-b    |        0 |        1 |        2 |
| row-c    |        0 |        1 |        2 |
:end:

*** ~print-table~ (spaces only)

TODO: Merge these together.
#+NAME: print-table-spaced
#+BEGIN_SRC scheme -n :eval no-export  :results output :exports code
(use-modules (ice-9 format))
(define* (print-row ll #:key (mode #f))
  (let ((fmtstr
         (cond ((or (eq? mode #f)
                    (equal? mode "display")
                    (equal? mode "~a"))
                " ~a")    ;; print objects for human viewing
               ((or (eq? mode #t)
                    (equal? mode "write")
                    (equal? mode "~s"))
                " ~s") ;; print objects for correctly (read)ing back
               ((string? mode)
                mode)))) ;; pass custom format string
    
      (format #t "~&") ;; ensure start of new line
      (map (λ(x) (format #t fmtstr x)) ll)
      (format #t "~%")))

(define* (print-table table #:key (colnames #f) (mode #f))
    (define (iter t)
      (print-row (car t) #:mode mode)
      (map (λ(x) (print-row x #:mode mode)) (cdr t)))
    (cond ((and (= 1 (length table))
                (list? (car table))) (iter (car table)))
          ((<= 1 (length table)) (iter table))
          (else error "Invalid Input??")))
#+end_src

#+NAME: print-table-spaced-test
#+BEGIN_SRC scheme -n :eval no-export  :results table output :exports no :rownames yes :colnames yes
<<print-table-spaced>>
(let* ((l (iota 3))
      (table (list
              (list 'column-1 'column-2 'column-3 'column-4)
              (cons 'row-a l)
              (cons 'row-b l)
              (cons 'row-c l))))
  (print-table table))
#+end_src

#+RESULTS[497a369e75d67018fb5cb6e0beecd5fbddb3468f]: print-table-spaced-test
:results:
 column-1 column-2 column-3 column-4
 row-a 0 1 2
 row-b 0 1 2
 row-c 0 1 2
:end:


* Introduction Notes

** Text Foreword

This book centers on three areas: the human mind, collections of computer
programs, and the computer.

Every program is a model of a real or mental process, and these processes are at
any time only partially understood. We change these programs as our
understandings of these processes evolve.

Ensuring the correctness of programs becomes a Herculean task as complexity
grows. Because of this, it's important to make fundamentals that can be relied
upon to support larger structures.

** Preface, 1e

"Computer Science" isn't really about computers or science, in the same way that
geometry isn't really about measuring the earth ('geometry' translates to
'measurement of earth').

Programming is a medium for expressing ideas about methodology. For this reason,
programs should be written first for people to read, and second for machines to
execute.

The essential material for introductory programming is how to control complexity
when building programs.

Computer Science is about imperative knowledge, as opposed to declarative. This
can be called /procedural epistemology/.

- *Declarative knowledge* :: /what is true/. For example: \(\sqrt{x}\) is the
  \(y\) such that \(y^2 = x\) and \(y \geq 0\)

- *Imperative knowledge* :: /How to follow a process/. For example: to find an
  approximation to \(\sqrt{x}\), make a guess \(G\), improve the guess by
  averaging \(G\) and \(x/G\), keep improving until the guess is good enough.

**** Techniques for controlling complexity

- Black-box abstraction :: Encapsulating an operation so the details of it are
  irrelevant.

  The fixed point of a function \(f()\) is a value \(y\) such that \(f(y) = y\).
  Method for finding a fixed point: start with a guess for \(y\) and keep applying
  \(f(y)\) over and over until the result doesn't change very much.

  Define a box of the method for finding the fixed point of \(f()\).

  One way to find \(\sqrt{x}\) is to take our function for approaching a square
  root src_scheme{(λ(guess target) (average guess (divide target guess)))}, applying
  that to our method for finding a fixed point, and this creates a *procedure* to
  find a square root.

  Black-box abstraction
  1. Start with primitive objects of procedures and data.
  2. Combination: combine procedures with /composition/, combine data with
     /construction/ of compound data.
  3. Abstraction: defining procedures and abstracting data. Capture common
     patterns by making high-order procedures composed of other procedures. Use
     data as procedures.

- Conventional interfaces :: Agreed-upon ways of connecting things together.

  - How do you make operations generalized?
  - How do you make large-scale structure and modularity?
    - Object-oriented programming :: thinking of your structure as a society of
      discrete but interacting parts.
    - Operations on aggregates :: thinking of your structure as operating on a
      stream, comparable to signal processing. /(Needs clarification.)/

- Metalinguistic abstractions :: Making new languages. This changes the way you
  interact with the system by letting you emphasize some parts and deemphasize
  other parts.

* Chapter 1: Building Abstractions with Procedures

*Computational processes* are abstract 'beings' that inhabit computers. Their
evolution is directed by a pattern of rules called a *program*, and processes
manipulate other abstract things called *data*.

Master software engineers are able to organize programs so they can be
reasonably sure the resulting process performs the task intended, without
catastrophic consequences, and that any problems can be debugged.

Lisp's users have traditionally resisted attempts to select an "official"
version of the language, which has enabled Lisp to continually evolve.

There are powerful program-design techniques which rely on the ability to blur
the distinction between data and processes. Lisp enables these techniques by
allowing processes to be represented and manipulated as data.

** 1.1: The Elements of Programming

A programming language isn't just a way to instruct a computer -- it's also a
framework for the programmer to organize their ideas. Thus it's important to
consider the means the language provides for combining ideas. Every powerful
language has three mechanisms for this:

- *primitive expressions* :: the simplest entities the language is concerned with
- *means of combination* :: how compound elements can be built from simpler ones
- *means of abstraction* :: how which compound elements can be named and
  manipulated as units

In programming, we deal with *data* which is what we want to manipulate, and
*procedures* which are descriptions of the rules for manipulating the data.

A procedure has *formal parameters*. When the procedure is applied, the formal
parameters are replaced by the *arguments* it is being applied to. For example,
take the following code:

#+NAME: square
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (square x)
  (* x x))
#+END_SRC

#+begin_src scheme
<<square>>
(square 5)
#+end_src

~x~ is the formal parameter and ~5~ is the argument.

** 1.1.1: Expressions

The general form of Lisp is evaluating *combinations*, denoted by parenthesis,
in the form src_scheme{(operator operands)}, where /operator/ is a procedure and
/operands/ are the 0 or more arguments to the operator.

Lisp uses *prefix notation*, which is not customary mathematical notation, but
provides several advantages.
1. It supports procedures that take arbitrary numbers of arguments,
   i.e. src_scheme{(+ 1 2 3 4 5)}.
2. It's straightforward to nest combinations in other combinations.

** 1.1.3: Evaluating Combinations

The evaluator can evaluate nested expressions recursively. *Tree accumulation*
is the process of evaluating nested combinations, "percolating" values upward.

The recursive evaluation of src_scheme{(* (+ 2 (* 4 6)) (+ 3 5 7))} breaks down into four
parts:

#+begin_src mermaid :file 1/fig/t_1-1-3.png
graph BT;
  A>"390"];
  subgraph four;
  B["*"];
  C>"26"];
  D>"15"];
  end
  subgraph two;
  E["+"];
  F("2");
  G>"24"];
  end
  subgraph three;
  H["+"];
  I("3");
  J("5");
  K("7");
  end
  subgraph one;
  L["*"];
  M("4");
  N("6");
  end

  B & C & D --> A;
  E & F & G --> C
  H & I & J & K --> D;
  L & M & N --> G

#+end_src

#+RESULTS[eb290cb6a678715b9d35bfe3238eff9c97156ef7]:
[[file:1/fig/t_1-1-3.png]]

** 1.1.4: Compound Procedures

We have identified the following in Lisp:
- primitive data are numbers, primitive procedures are arithmetic operations
- Operations can be combined by nesting combinations
- Data and procedures can be abstracted by variable & procedure definitions

Procedure definitions give a name to a compound procedure.
#+begin_src scheme
(define (square x) (* x x)) ; to square something, multiply it by itself
; now it can be applied or used in other definitions:
(square 4) ; => 16

(define (sum-of-squares x y)
  (+ (square x) (square y)))
(sum-of-squares 3 4) ; => 25
#+end_src

Note how these compound procedures are used in the same way as primitive
procedures.

** 1.1.5: The Substitution Model for Procedure Application

To understand how the interpreter works, imagine it substituting the procedure
calls with the bodies of the procedure and its arguments.

#+begin_src scheme
(* (square 3) (square 4))
; has the same results as
(* (* 3 3) (* 3 3))
#+end_src

This way of understanding procedure application is called the *substitution
model*. This model is to help you understand procedure substitution, and is
usually not how the interpreter actually works. This book will progress through
more intricate models of interpreters as it goes. This is the natural
progression when learning scientific phenomena, starting with a simple model,
and replace it with more refined models as the phenomena is examined in more
detail.

Evaluations can be done in different orders.

- *Applicative order* :: evaluates the operator and operands, and then applies the
resulting procedure to the resulting arguments. In other words, reducing, then
expanding, then reducing.

- *Normal order* :: substitutes expressions until it obtains an expression involving
only primitive operators, or until it can't substitute any further, and then
evaluates. This results in expanding the expression completely before doing any
reduction, which results in some repeated evaluations.

For all procedure applications that can be modeled using substitution,
applicative and normal order evaluation produce the same result. Normal order
becomes more complicated once dealing with procedures that can't be modeled by
substitution.

Lisp uses applicative order evaluation because it helps avoid repeated work and
other complications. But normal has its own advantages which will be explored in
Chapter 3 and 4.

#+begin_src scheme
; Applicative evaluation
(f 5)
(sum-of-squares (+ a 1) (* a 2))
(sum-of-squares (+ 5 1) (* 5 2))
(sum-of-squares 6 10)
(+ (square x)(square y))
(+ (square 6)(square 10))
(+ (* 6 6)(* 10 10))
(+ 36 100)
136
; Normal evaluation
(f 5)
(sum-of-squares (+ a 1) (* a 2))
(sum-of-squares (+ 5 1) (* 5 2))
(+ (square (+ 5 1)) (square (* 5 2)))
(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))
(+ (* 6 6) (* 10 10))
(+ 36 100)
136
#+end_src

(Extra-curricular clarification: Normal order delays evaluating arguments until
they're needed by a procedure, which is called lazy evaluation.)

** 1.1.6: Conditional Expressions and Predicates

An important aspect of programming is testing and branching depending on the
results of the test. ~cond~ tests *predicates*, and upon encountering one,
returns a *consequent*.

#+begin_src scheme
(cond
     (predicate1 consequent1)
     ...
     (predicateN consequentN))
#+end_src

A shorter form of conditional:

#+begin_src scheme
(if predicate consequent alternative)
#+end_src

If ~predicate~ is true, ~consequent~ is returned. Else, ~alternative~ is
returned.

Combining predicates:

#+begin_src scheme
(and expression1 ... expressionN)
; if encounters false, stop eval and returns false.
(or expression1 ... expressionN)
; if encounters true, stop eval and return true. Else false.
(not expression)
; true is expression is false, false if expression is true.
#+end_src

A small clarification:

#+begin_src scheme
(define A (* 5 5))
(define (D) (* 5 5))
A ; => 25
D ; => compound procedure D
(D) ; => 25 (result of executing procedure D)
#+end_src

Special forms bring more nuances into the substitution model mentioned
previously. For example, when evaluating an ~if~ expression, you evaluate the
predicate and, depending on the result, either evaluate the *consequent* or the
*alternative*. If you were evaluating in a standard manner, the consequent and
alternative would both be evaluated, rendering the ~if~ expression ineffective.

** Exercise 1.1

*** Question
#+begin_quote
Below is a sequence of expressions. What is the result printed by the
interpreter in response to each expression? Assume that the sequence is to be
evaluated in the order in which it is presented.
#+end_quote

*** Answer

#+BEGIN_SRC scheme -n :results none
10 ;; 10
(+ 5 3 4) ;; 12
(- 9 1) ;; 8
(/ 6 2) ;; 3
(+ (* 2 4) (- 4 6)) ;; 6
(define a 3) ;; a=3
(define b (+ a 1)) ;; b=4
(+ a b (* a b)) ;; 19
(= a b) ;; false
(if (and (> b a) (< b (* a b)))
    b
    a) ;; 4
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25)) ;; 16
(+ 2 (if (> b a) b a)) ;; 6
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1)) ;; 16
#+END_SRC

** Exercise 1.2

*** Question

#+begin_quote
Translate the following expression into prefix form:
\[
  \frac{5 + 2 + (2 - 3 - (6 + \frac{4}{5})))}
            {3(6 - 2)(2 - 7)}
\]
#+end_quote

*** Answer

#+NAME: EX1-2
#+BEGIN_SRC scheme -n :eval no-export :exports both :results value
(/ (+ 5 2 (- 2 3 (+ 6 (/ 4 5))))
   (* 3 (- 6 2) (- 2 7)))
#+END_SRC

#+RESULTS[7039c32447725d91001cae297dc9040b72a855ce]: EX1-2
:results:
#+begin_example
1/75
#+end_example
:end:

** Exercise 1.3

*** Question

#+begin_quote
Define a procedure that takes three numbers as arguments and returns the sum of
the squares of the two larger numbers.
#+end_quote

*** Answer

#+NAME: EX1-3
#+BEGIN_SRC scheme -n :eval no-export :exports both :results value table
<<square>>
(define (sum-square x y)
  (+ (square x) (square y)))
(define (square-2of3 a b c)
  (cond ((and (>= a b) (>= b c)) (sum-square a b))
        ((and (>= a b) (> c b)) (sum-square a c))
        (else (sum-square b c))))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export  :exports both :results value table
<<EX1-3>>
<<try-these>>
 (try-these square-2of3 '(7 5 3)
                        '(7 3 5)
                        '(3 5 7))
#+END_SRC

#+RESULTS[0f816cfe3925898754ab7943a28f676135795e6c]:
:results:
| (7 5 3) | 74 |
| (7 3 5) | 74 |
| (3 5 7) | 74 |
:end:

** Exercise 1.4

*** Question

#+begin_quote
Observe that our model of evaluation allows for combinations whose operators are
compound expressions. Use this observation to describe the behavior of the
following procedure:
#+end_quote

#+NAME: a-plus-abs-b
#+BEGIN_SRC scheme -n
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
#+END_SRC

*** Answer

This code accepts the variables ~a~ and ~b~, and if ~b~ is positive, it adds ~a~
and ~b~. However, if ~b~ is zero or negative, it subtracts them. This decision
is made by using the ~+~ and ~-~ procedures as the results of an if expression,
and then evaluating according to the results of that expression. This is in
contrast to a language like Python, which would do something like this:

#+BEGIN_SRC python :noeval 
if b > 0: a + b
else: a - b
#+END_SRC

** Exercise 1.5

*** Question

#+begin_quote
Ben Bitdiddle has invented a test to determine whether the interpreter he is
faced with is using applicative-order evaluation or normal-order evaluation. He
defines the following two procedures:
#+end_quote

#+BEGIN_SRC scheme -n :noeval 
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
#+END_SRC
#+begin_quote
Then he evaluates the expression:
#+end_quote

#+BEGIN_SRC scheme -n :noeval 
(test 0 (p))
#+END_SRC
#+begin_quote
What behavior will Ben observe with an interpreter that uses applicative-order
evaluation?  What behavior will he observe with an interpreter that uses
normal-order evaluation?  Explain your answer.  (Assume that the evaluation
rule for the special form src_scheme{if} is the same whether the interpreter is
using normal or applicative order: The predicate expression is evaluated first,
and the result determines whether to evaluate the consequent or the alternative
expression.)
#+end_quote

*** Answer

In either type of language, src_scheme{(define (p) (p))} is an infinite
loop. However, a normal-order language will encounter the special form, return
~0~, and never evaluate src_scheme{(p)}. An applicative-order language evaluates the
arguments to src_scheme{(test 0 (p))}, thus triggering the infinite
loop.

** 1.1.7: Example: Square Roots by Newton's Method

Functions in the formal mathematical sense are *declarative knowledge*, while
procedures like in computer science are *imperative knowledge*.

Notice that the elements of the language that have been introduced so far are
sufficient for writing any purely numerical program, despite not having
introduced any looping constructs like ~FOR~ loops.

** 1.1.8: Procedures as Black-Box Abstractions

Notice how the ~sqrt~ procedure is divided into other procedures, which mirror
the division of the square root problem into sub problems.

A procedure should accomplish an identifiable task, and be ready to be used as a
module in defining other procedures. This lets the programmer know how to use
the procedure while not needing to know the details of how it works.

Suppressing these details are particularly helpful:
- Local names. :: A procedure user shouldn't need to know a procedure's choices of
  variable names. A formal parameter of a procedure whose name is irrelevant is
  called a *bound variable*. A procedure definition *binds* its parameters. A
  *free variable* isn't bound. The set of expressions in which a binding defines
  a name is the *scope* of that name.
- Internal definitions and block structure. :: By nesting relevant definitions
  inside other procedures, you hide them from the global namespace. This nesting
  is called *block structure*. Nesting these definitions also allows relevant
  variables to be shared across procedures, which is called *lexical scoping*.

** Exercise 1.6

*** Text code
#+NAME: abs
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (abs x)
  (if (< x 0)
      (- x)
      x))
#+END_SRC
#+NAME: average
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (average x y)
  (/ (+ x y) 2))
#+END_SRC
#+NAME: txt-sqrt
#+BEGIN_SRC scheme -n :eval no-export  :results silent
<<average>>
(define (improve guess x)
  (average guess (/ x guess)))

<<square>>
<<abs>>
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))

(define (sqrt x)
  (sqrt-iter 1.0 x))
#+END_SRC

*** Question

#+begin_quote
Alyssa P. Hacker doesn't see why ~if~ needs to be provided as a
special form. "Why can't I just define it as an ordinary procedure in terms of
cond?" she asks. Alyssa's friend Eva Lu Ator claims this can indeed be done, and
she defines a new version of ~if~:
#+end_quote

#+BEGIN_SRC scheme -n :noeval 
(define (new-if predicate
                then-clause
                else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
#+END_SRC
#+begin_quote
Eva demonstrates the program for Alyssa:
#+end_quote

#+BEGIN_SRC scheme -n :noeval 
(new-if (= 2 3) 0 5)
;; => 5

(new-if (= 1 1) 0 5)
;; => 0
#+END_SRC

#+begin_quote
Delighted, Alyssa uses new-if to rewrite the square-root program:
#+end_quote

#+BEGIN_SRC scheme -n :noeval 
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))
#+END_SRC

#+begin_quote
What happens when Alyssa attempts to use this to compute square roots? Explain.
#+end_quote

*** Answer

Using Alyssa's ~new-if~ leads to an infinite loop because the recursive call to
~sqrt-iter~ is evaluated before the actual call to ~new-if~. This is because
~if~ and ~cond~ are special forms that change the way evaluation is handled;
whichever branch is chosen leaves the other branches unevaluated.

** Exercise 1.7

*** Text

#+NAME: mean-square
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (mean-square x y)
  (average (square x) (square y)))
#+END_SRC

*** Question

#+begin_quote
The src_scheme{good-enough?} test used in computing square roots will not be
very effective for finding the square roots of very small numbers. Also, in real
computers, arithmetic operations are almost always performed with limited
precision. This makes our test inadequate for very large numbers. Explain these
statements, with examples showing how the test fails for small and large
numbers. An alternative strategy for implementing src_scheme{good-enough?} is to
watch how src_scheme{guess} changes from one iteration to the next and to stop
when the change is a very small fraction of the guess. Design a square-root
procedure that uses this kind of end test. Does this work better for small and
large numbers?
#+end_quote

*** Diary

**** Solving

My original answer was this, which compares the previous iteration until the new
and old are within an arbitrary \(dx\).

#+NAME: inferior-good-enough
#+BEGIN_SRC scheme -n 
<<txt-sqrt>>
(define (inferior-good-enough? guess lastguess)
  (<=
   (abs (-
         (/ lastguess guess)
         1))
   0.0000000000001)) ; dx
(define (new-sqrt-iter guess x lastguess) ;; Memory of previous value
  (if (inferior-good-enough? guess lastguess)
      guess
      (new-sqrt-iter (improve guess x) x guess)))
(define (new-sqrt x)
  (new-sqrt-iter 1.0 x 0))
#+end_src

This solution can correctly find small and large numbers:
#+BEGIN_SRC scheme -n :eval no-export  :exports both :results value
<<inferior-good-enough>>
(new-sqrt 10000000000000)
#+END_SRC

#+RESULTS[68a129e63924b52600a4964626d31b776d79fed2]:
:results:
#+begin_example
3162277.6601683795
#+end_example
:end:

#+NAME: EX1-7-t2
#+BEGIN_SRC scheme -n :eval no-export  :exports both :results value table drawer
<<try-these>>
<<inferior-good-enough>>
(try-these new-sqrt '(0.01 0.0001 0.000001 0.00000001 0.0000000001))
#+end_src

#+RESULTS[c27aa8604cebcef53580dbfc41f8585b748aacda]: EX1-7-t2
:results:
|   0.01 |                   0.1 |
| 0.0001 |                  0.01 |
|  1e-06 |                 0.001 |
|  1e-08 | 9.999999999999999e-05 |
|  1e-10 | 9.999999999999999e-06 |
:end:


However, I found this solution online that isn't just simpler but automatically
reaches the precision limit of the system:

#+NAME: new-good-enough
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<txt-sqrt>>
(define (best-good-enough? guess x)
   (= (improve guess x) guess))
#+END_SRC

**** Imroving (sqrt) by avoiding extra (improve) call

***** Non-optimized

#+BEGIN_SRC scheme -n :eval no-export :tangle 1/sqrt-bench.scheme :exports both :results output
(use-modules (ice-9 format))
(load "../mattbench.scm")
(define (average x y)
  (/ (+ x y) 2))
(define (improve guess x)
  (average guess (/ x guess)))
(define (good-enough? guess x)
   (= (improve guess x) guess)) ;; improve call 1
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x))) ;; call 2
(define (sqrt x)
  (sqrt-iter 1.0 x))
(newline)
(display (mattbench (λ() (sqrt 69420)) 400000000))
(newline)
;; 4731.30 <- Benchmark results
#+end_src

***** Optimized

#+BEGIN_SRC scheme -n :noeval :tangle 1/sqrt-bench2.scheme :exports both :results output
(use-modules (ice-9 format))
(load "../mattbench.scm")
(define (average x y)
  (/ (+ x y) 2))
(define (improve guess x)
  (average guess (/ x guess)))
(define (good-enough? guess nextguess x)
  (= nextguess guess))
(define (sqrt-iter guess x)
  (let ((nextguess (improve guess x)))
    (if (good-enough? guess nextguess x)
        guess
        (sqrt-iter nextguess x))))
(define (sqrt x)
  (sqrt-iter 1.0 x))
(newline)
(display (mattbench (λ() (sqrt 69420)) 400000000))
(newline)
#+end_src

***** Benchmark results

| Unoptimized | 4731.30 |
| Optimized   | 2518.44 |

*** Answer

The current method has decreasing accuracy with smaller numbers. Notice the
steady divergence from correct answers here (should be decreasing powers of
0.1):
#+NAME: EX1-7-t1
#+BEGIN_SRC scheme -n :eval no-export  :exports both :results value table
<<txt-sqrt>>
<<try-these>>
(try-these sqrt 0.01 0.0001 0.000001 0.00000001 0.0000000001)
#+END_SRC

#+RESULTS[b2aaaf48d742a7df9331cff3b730a799ad550cfe]: EX1-7-t1
:results:
|   0.01 |  0.10032578510960605 |
| 0.0001 |  0.03230844833048122 |
|  1e-06 | 0.031260655525445276 |
|  1e-08 |  0.03125010656242753 |
|  1e-10 |  0.03125000106562499 |
:end:

And for larger numbers, an infinite loop will eventually be reached. \(10^{12}\)
can resolve, but \(10^{13}\) cannot.

#+BEGIN_SRC scheme -n :eval no-export  :exports both :results value
<<txt-sqrt>>
(sqrt 1000000000000)
#+END_SRC

#+RESULTS[452bf3da7286d9fc1e3d621aeb715eafef650536]:
:results:
#+begin_example
1000000.0
#+end_example
:end:

So, my definition of ~sqrt~:
#+NAME: sqrt
#+BEGIN_SRC scheme -n :eval no-export :exports both :results value table
<<average>>
(define (improve guess x)
  (average guess (/ x guess)))
(define (good-enough? guess x)
   (= (improve guess x) guess))
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
(define (sqrt x)
  (sqrt-iter 1.0 x))
#+end_src
#+NAME: EX1-7-t3
#+BEGIN_SRC scheme -n :eval no-export  :exports both :results value table
<<try-these>>
<<sqrt>>
(try-these sqrt '(0.01 0.0001 0.000001 0.00000001 0.0000000001))
#+end_src

#+RESULTS[7cb8301b492f578ac407eef3e3378a8d1552a5a3]: EX1-7-t3
:results:
|   0.01 |                   0.1 |
| 0.0001 |                  0.01 |
|  1e-06 |                 0.001 |
|  1e-08 | 9.999999999999999e-05 |
|  1e-10 | 9.999999999999999e-06 |
:end:

** Exercise 1.8

*** Question

#+begin_quote
Newton's method for cube roots is based on the fact that if \(y\) is an
approximation to the cube root of \(x\), then a better approximation is given by
the value

\[
\frac{\frac{x}{y^2} + 2y}{3}
\]

Use this formula to implement a cube-root procedure analogous to the
src_scheme{square-root} procedure. (In 1.3.4 we will see how to implement
Newton's method in general as an abstraction of these square-root and cube-root
procedures.)
#+end_quote

*** Diary

My first attempt works, but needs an arbitrary limit to stop infinite loops:
#+NAME: EX1-8-A1
#+BEGIN_SRC scheme -n :eval no-export  :exports both :results value table
<<square>>
<<try-these>>
(define (cb-good-enough? guess x)
  (= (cb-improve guess x) guess))
(define (cb-improve guess x)
  (/
   (+
    (/ x (square guess))
    (* guess 2))
   3))
(define (cbrt-iter guess x counter)
  (if (or (cb-good-enough? guess x) (> counter 100))
      guess
      (begin
        (cbrt-iter (cb-improve guess x) x (+ 1 counter)))))
(define (cbrt x)
  (cbrt-iter 1.0 x 0))

(try-these cbrt 7 32 56 100)
#+end_src

#+RESULTS[1eb5546cd3e124a63b0cd988f571097371a60813]: EX1-8-A1
:results:
|   7 | 1.912931182772389 |
|  32 | 3.174802103936399 |
|  56 | 3.825862365544778 |
| 100 | 4.641588833612779 |
:end:

However, this will hang on an infinite loop when trying to run src_scheme{(cbrt
100)}. I speculate it's a floating point precision issue with the "improve"
algorithm. So to avoid it I'll just keep track of the last guess and stop
improving when there's no more change occurring. Also while researching I
discovered that (again due to floating point) src_scheme{(cbrt -2)} loops
forever unless you initialize your guess with a slightly different value, so
let's do 1.1 instead.

*** Answer

#+NAME: cbrt
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
<<square>>
(define (cb-good-enough? nextguess guess lastguess x)
  (or (= nextguess guess)
      (= nextguess lastguess)))
(define (cb-improve guess x)
  (/
   (+
    (/ x (square guess))
    (* guess 2))
   3))
(define (cbrt-iter guess lastguess x)
  (define nextguess (cb-improve guess x))
  (if (cb-good-enough? nextguess guess lastguess x)
      nextguess
      (cbrt-iter nextguess guess x)))
(define (cbrt x)
  (cbrt-iter 1.1 9999 x))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export  :exports both :results value table
<<cbrt>>
<<try-these>>
(try-these cbrt 7 32 56 100 -2)
#+END_SRC

#+RESULTS[965031d6fc942ec767b94f18bc03219f3a3f93d6]:
:results:
|   7 |   1.912931182772389 |
|  32 |   3.174802103936399 |
|  56 |   3.825862365544778 |
| 100 |   4.641588833612779 |
|  -2 | -1.2599210498948732 |
:end:

** 1.2: Procedures and the Processes They Generate

Procedures define the *local evolution* of processes. We would like to be able
to make statements about the *global* behavior of a process.

** 1.2.1: Linear Recursion and Iteration

Consider these two procedures for obtaining factorials:

#+begin_src scheme
(define (factorial-recursion n)
  (if (= n 1)
      1
      (* n 
         (factorial-recursion (- n 1)))))

(define (factorial-iteration n)
  (define (fact-iter product counter max-count)
      (if (> counter max-count)
          product
          (fact-iter
                    (* counter product)
                    (+ counter 1)
                    max-count)))
  
  (fact-iter 1 1 n))
#+end_src

These two procedures reach the same answers, but form very different processes.
The ~factorial-recursion~ version takes more computational *time* and *space* to
evaluate, by building up a chain of deferred operations. This is a *recursive
process*. As the number of steps needed to operate, and the amount of info
needed to keep track of these operations, both grow linearly with \(n\), this is
a *linear recursive process*.

The second version forms an *iterative process*. Its state can be summarized
with a fixed number of state variables. The number of steps required grow
linearly with \(n\), so this is a *linear iterative process*.

- recursive procedure ::  is a procedure whose definition refers to itself.
- recursive process :: is a process that evolves recursively.

So ~fact-iter~ is a recursive /procedure/ that generates an iterative /process/.

Many implementations of programming languages interpret all recursive procedures
in a way that consume memory that grows with the number of procedure calls, even
when the process is essentially iterative. These languages instead use looping
constructs such as ~do~, ~repeat~, ~for~, etc. Implementations that execute
iterative processes in constant space, even if the procedure is recursive, are
*tail-recursive*.

** Exercise 1.9

*** Question
#+begin_quote
Each of the following two procedures defines a method for adding two positive
integers in terms of the procedures src_scheme{inc}, which increments its
argument by 1, and src_scheme{dec}, which decrements its argument by 1.
#+end_quote

#+BEGIN_SRC scheme -n :noeval 
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
#+END_SRC

#+begin_quote
Using the substitution model, illustrate the process generated by each procedure
in evaluating src_scheme{(+ 4 5)}. Are these processes iterative or recursive?
#+end_quote

*** Answer

The first procedure is recursive, while the second is iterative though
tail-recursion.

**** recursive procedure

#+BEGIN_SRC scheme -n :noeval 
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
#+END_SRC

**** iterative procedure

#+BEGIN_SRC scheme -n :noeval 
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
#+END_SRC

** Exercise 1.10

*** Question

#+begin_quote
The following procedure computes a mathematical function called Ackermann's
function.
#+end_quote
#+NAME: ackermann
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
#+END_SRC

#+begin_quote
What are the values of the following expressions?
#+end_quote

#+BEGIN_SRC scheme -n :noeval 
(A 1 10)
(A 2 4)
(A 3 3)
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :exports results  :results value table
<<try-these>>
<<ackermann>>
(try-these A '(1 10) '(2 4) '(3 3))
#+END_SRC

#+RESULTS[48e58b6029bccdcb0ec0cba4c437572b3b5c2437]:
:results:
| (1 10) |  1024 |
| (2 4)  | 65536 |
| (3 3)  | 65536 |
:end:

#+NAME: EX1-10-defs
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
<<ackermann>>
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
#+END_SRC

#+begin_quote
Give concise mathematical definitions for the functions computed by the
procedures ~f~, ~g~, and ~h~ for positive integer values of \(n\). For example,
src_scheme{(k n)} computes \(5n^2\).
#+end_quote

*** Answer

**** ~f~

#+BEGIN_SRC scheme -n :eval no-export  :exports both :results value table
<<try-these>>
<<EX1-10-defs>>
(try-these f 1 2 3 10 15 20)
#+END_SRC

#+RESULTS[d24f130b3c260d786e4cb6a89fa32c320b8c9216]:
:results:
|  1 |  2 |
|  2 |  4 |
|  3 |  6 |
| 10 | 20 |
| 15 | 30 |
| 20 | 40 |
:end:

\[
f(n)=2n
\]

**** ~g~

#+BEGIN_SRC scheme -n :eval no-export  :exports both :results value table
<<try-these>>
<<EX1-10-defs>>
(try-these g 1 2 3 4 5 6 7 8)
#+END_SRC

#+RESULTS[2de64054dc56968afee805dc8757b991e4f74d88]:
:results:
| 1 |   2 |
| 2 |   4 |
| 3 |   8 |
| 4 |  16 |
| 5 |  32 |
| 6 |  64 |
| 7 | 128 |
| 8 | 256 |
:end:

\[
g(n)=2^n
\]

**** ~h~

#+BEGIN_SRC scheme -n :eval no-export  :exports both :results value table
<<try-these>>
<<EX1-10-defs>>
(try-these h 1 2 3 4)
#+END_SRC

#+RESULTS[b80263a28bd5076f3bfa3f4bae09ec511773e7af]:
:results:
| 1 |     2 |
| 2 |     4 |
| 3 |    16 |
| 4 | 65536 |
:end:

It took a while to figure this one out, just because I didn't know the term.
This is repeated exponentiation. This operation is to exponentiation, what
exponentiation is to multiplication. It's called either /tetration/ or /hyper-4/
and has no formal notation, but two common ways would be these:

\[
h(n)=2 \uparrow\uparrow n
\]
\[
h(n)={}^{n}2
\]

** 1.2.2: Tree Recursion

Consider a recursive procedure for computing Fibonacci numbers:

#+begin_src scheme
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
#+end_src

The resulting process splits into two with every iteration, creating a tree of
computations, many of which are duplicates of previous computations. This kind
of pattern is called *tree-recursion*. However, this one is quite inefficient.
The time and space required grows exponentially with the number of iterations
requested.

Instead, it makes much more sense to start from ~Fib(1) ~ 1~ and ~Fib(0) ~ 0~
and iterate upwards to the desired value. This only requires a linear number of
steps relative to the input.

#+begin_src scheme
(define (fib n)
  (fib-iter 1 0 n))
(define (fib-iter a b count)
  (if (= count 0) b (fib-iter (+ a b) a (- count 1))))
#+end_src

However, notice that the inefficient tree-recursive version is a fairly
straightforward translation of the Fibonacci sequence's definition, while the
iterative version required redefining the process as an iteration with three
variables.

*** Example: Counting change

I should come back and try to make the "better algorithm" suggested.

** Exercise 1.11

*** Question

#+begin_quote
A function \(f\) is defined by the rule that:
\[
f(n)=n \text{ if } n<3
\]
\[
\text{ and }
\]
\[
f(n)=f(n-1)+2f(n-2)+3f(n-3) \text{ if } n \geq 3
\]

Write a procedure that computes \(f\) by means of a recursive process. Write a
procedure that computes \(f\) by means of an iterative process.
#+end_quote

*** Answer

**** Recursive
#+NAME: EX1-11-fr
#+BEGIN_SRC scheme -n :eval no-export  :exports code :results silent
(define (fr n)
  (if (< n 3)
      n
      (+      (fr (- n 1))
         (* 2 (fr (- n 2)))
         (* 3 (fr (- n 3))))))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export  :exports both :results value table
<<try-these>>
<<EX1-11-fr>>
(try-these fr 1 3 5 10)
#+END_SRC

#+RESULTS[d54b80d2fe7a526473762819190f33a520a19fe4]:
:results:
|  1 |    1 |
|  3 |    4 |
|  5 |   25 |
| 10 | 1892 |
:end:

**** Iterative

***** Attempt 1

#+NAME: EX1-11-fi
#+BEGIN_SRC scheme -n :eval no-export  :exports code :results silent
;; This seems like it could be better
(define (fi n)
  (define (formula l)
    (let ((a (car l))
           (b (cadr l))
           (c (caddr l)))
      (+ a
         (* 2 b)
         (* 3 c))))
  (define (iter l i)
    (if (= i n)
        (car l)
        (iter (cons (formula l) l)
              (+ 1 i))))
  (if (< n 3)
      n
      (iter '(2 1 0) 2)))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export  :exports both :results value table
<<try-these>>
<<EX1-11-fi>>
(try-these fi 1 3 5 10)
#+END_SRC

#+RESULTS[77f33e30f912c03277beeb8092d92c55abfcc936]:
:results:
|  1 |    1 |
|  3 |    4 |
|  5 |   25 |
| 10 | 1892 |
:end:

It works but it seems wasteful.

***** Attempt 2

#+NAME: EX1-11-fi2
#+BEGIN_SRC scheme -n :eval no-export  :exports code :results silent
(define (fi2 n)
  (define (formula a b c)
      (+ a
         (* 2 b)
         (* 3 c)))
  (define (iter a b c i)
    (if (= i n)
        a
        (iter (formula a b c)
              a
              b
              (+ 1 i))))
  (if (< n 3)
      n
      (iter 2 1 0 2)))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export  :exports both :results value table
<<try-these>>
<<EX1-11-fi2>>
(try-these fi2 1 3 5 10)
#+END_SRC

#+RESULTS[baa8cd23dfff7b5fa47ae133b0a8b58ef2cb9a61]:
:results:
|  1 |    1 |
|  3 |    4 |
|  5 |   25 |
| 10 | 1892 |
:end:

I like that better.

** Exercise 1.12

*** Question

#+begin_quote
The following pattern of numbers is called Pascal's triangle.
#+end_quote

#+BEGIN_EXAMPLE
        1
      1   1
    1   2   1
  1   3   3   1
1   4   6   4   1
      . . .
#+END_EXAMPLE

#+begin_quote
The numbers at the edge of the triangle are all 1, and each number inside the
triangle is the sum of the two numbers above it. Write a procedure that
computes elements of Pascal's triangle by means of a recursive process.
#+end_quote

*** Answer

I guess I'll rotate the triangle 45 degrees to make it the corner of an
infinite spreadsheet.

#+NAME: pascal-rec
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (pascal x y)
  (if (or (= x 0)
          (= y 0))
      1
      (+ (pascal (- x 1) y)
         (pascal x (- y 1)))))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export  :exports both :results value table
<<try-these>>
<<pascal-rec>>
(let ((l (iota 8)))
  (map (λ (row)
         (map (λ (xy)
                (apply pascal xy))
              row))
       (map (λ (x)
              (map (λ (y)
                     (list x y))
                   l))
            l)))
#+END_SRC

#+RESULTS[151500842c6cdef9252eaf15c1323fc7bcba0527]:
:results:
| 1 | 1 |  1 |   1 |   1 |   1 |    1 |    1 |
| 1 | 2 |  3 |   4 |   5 |   6 |    7 |    8 |
| 1 | 3 |  6 |  10 |  15 |  21 |   28 |   36 |
| 1 | 4 | 10 |  20 |  35 |  56 |   84 |  120 |
| 1 | 5 | 15 |  35 |  70 | 126 |  210 |  330 |
| 1 | 6 | 21 |  56 | 126 | 252 |  462 |  792 |
| 1 | 7 | 28 |  84 | 210 | 462 |  924 | 1716 |
| 1 | 8 | 36 | 120 | 330 | 792 | 1716 | 3432 |
:end:

The test code was much harder to write than the actual solution.

** Exercise 1.13 :optional:

*** Question

#+begin_quote
Prove that \(\text{Fib}(n)\) is the closest integer to
\(\frac\Phi^n}{\sqrt{5}}\) where \(\Phi\) is \(\frac{1 + \sqrt{5}}{2}\). Hint: let
\(\Upsilon = \frac{1 - \sqrt{5}}{2}\). Use induction and the definition of the
Fibonacci numbers to prove that

\[
 \text{Fib}(n) = \frac{\Phi^n - \Upsilon^n}{\sqrt{5}}
\]
#+end_quote

*** Answer

I don't know how to write a proof yet, but I can make functions to
demonstrate it.

**** Fibonacci number generator

#+NAME: fib-iter
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (fib-iter n)
  (define (iter i a b)
    (if (= i n)
        b
    (iter (+ i 1)
          b
          (+ a b))))
  (if (<= n 2)
      1
      (iter 2 1 1)))
#+END_SRC

**** Various algorithms relating to the question

#+NAME: fib-phi
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
<<sqrt>>
(define sqrt5
  (sqrt 5))
(define phi
  (/ (+ 1 sqrt5) 2))
(define upsilon
  (/ (- 1 sqrt5) 2))
(define (fib-phi n)
  (/ (- (expt phi n)
        (expt upsilon n))
     sqrt5))
#+END_SRC
#+NAME: 1-13-tab
#+BEGIN_SRC scheme -n :eval no-export  :exports both :results value table
(use-srfis '(1))
<<fib-iter>>
<<fib-phi>>
<<try-these>>

(let* ((vals (drop (iota 21) 10))
       (fibs (map fib-iter vals))
       (approx (map fib-phi vals)))
  (zip vals fibs approx))
#+END_SRC

#+RESULTS[732483d41040c13f1e9a125ebe5a0ecdca1f5d18]: 1-13-tab
:results:
| 10 |   55 |  54.99999999999999 |
| 11 |   89 |               89.0 |
| 12 |  144 | 143.99999999999997 |
| 13 |  233 | 232.99999999999994 |
| 14 |  377 | 377.00000000000006 |
| 15 |  610 |              610.0 |
| 16 |  987 |  986.9999999999998 |
| 17 | 1597 | 1596.9999999999998 |
| 18 | 2584 |             2584.0 |
| 19 | 4181 |             4181.0 |
| 20 | 6765 |  6764.999999999999 |
:end:

You can see they follow closely. Graphing the differences, it's just
an exponential curve at very low values, presumably following the
exponential increase of the Fibonacci sequence itself.
#+NAME: 1-13-tab2
#+BEGIN_SRC scheme -n :eval no-export  :exports none :results value silent
(use-srfis '(1))
<<fib-iter>>
<<fib-phi>>
<<try-these>>

(let* ((vals (drop (iota 500) 2))
       (diffs (map (λ (i)
                     (- (fib-iter i) (fib-phi i)))
                   vals)))
  (zip vals diffs))
#+END_SRC



#+begin_src gnuplot :var data=1-13-tab2 :file 1/fig/1-13.png :exports results :eval no-export
reset # helps with various issues in execution
set xlabel 'values of n'
set logscale y

plot data using 1:2 with lines title 'Fib(n) minus Fib-phi(n)'
#+end_src

#+RESULTS[8c0a67c9f76a9da9c115187192a6c35899c939cb]:
:results:
[[file:1/fig/1-13.png]]
:end:

** 1.2.3: Orders of Growth

An *order of growth* gives you a gross measure of the resources required by a
process as its inputs grow larger.

Let \(n\) be a parameter for the size of a problem, and \(R(n)\) be the amount
of resources required for size \(n\). \(R(n)\) has order of growth
\(\Theta(f(n))\)

For example:
- \(\Theta(1)\) :: is constant, not growing regardless of input size.
- \(\Theta(n)\) :: is growth 1-to-1 proportional to the input size.

Some algorithms we've already seen:
- Linear recursive :: is time and space \(\Theta(n)\)
- Iterative :: is time \(\Theta(n)\) space \(\Theta(1)\)
- Tree-recursive :: means in general, time is proportional to the number of
  nodes, space is proportional to the depth of the tree. In the Fibonacci
  algorithm example, \(\Theta(n)\) and time \(\Theta(\Upsilon^{n})\) where
  \(\Upsilon\) is the golden ratio \(\frac{1 + \sqrt{5}}{2}\)

Orders of growth are very crude descriptions of process behaviors, but they are
useful in indicating how a process will change with the size of the problem.

** Exercise 1.14

*** Text
Below is the default version of the src_scheme{count-change} function. I'll be
aggressively modifying it in order to get a graph out of it.
#+NAME: count-change
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0)
             (= kinds-of-coins 0))
         0)
        (else
         (+ (cc amount (- kinds-of-coins 1))
            (cc (- amount (first-denomination
                           kinds-of-coins))
                kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
#+end_src

*** Question A

#+begin_quote
Draw the tree illustrating the process generated by the src_scheme{count-change}
procedure of 1.2.2 in making change for 11 cents.
#+end_quote

*** Answer

I want to generate this graph algorithmically.
#+NAME: count-change-graphviz
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
;; cursed global
(define bubblecounter 0)
;; Returns # of ways change can be made
;; "Helper" for (cc)
(define (count-change amount)
  (display "digraph {\n") ;; start graph
  (cc amount 5 0)
  (display "}\n") ;; end graph
  (set! bubblecounter 0))

;; GraphViz output
;; Derivative: https://stackoverflow.com/a/14806144
(define (cc amount kinds-of-coins oldbubble)
  (let ((recur (lambda (new-amount new-kinds)
                 (begin
                   (display "\"") ;; Source bubble
                   (display `(,oldbubble ,amount ,kinds-of-coins))
                   (display "\"")
                   (display " -> ") ;; arrow pointing from parent to child
                   (display "\"") ;; child bubble
                   (display `(,bubblecounter ,new-amount ,new-kinds))
                   (display "\"")
                   (display "\n")
                   (cc new-amount new-kinds bubblecounter)))))
    (set! bubblecounter (+ bubblecounter 1))
    (cond ((= amount 0) 1)
          ((or (< amount 0) (= kinds-of-coins 0)) 0)
          (else (+
                 (recur amount (- kinds-of-coins 1))
                 (recur (- amount
                           (first-denomination kinds-of-coins))
                        kinds-of-coins))))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
#+end_src

I'm not going to include the full printout of the src_scheme{(count-change 11)},
here's an example of what this looks like via ~1~.
#+NAME: count-change-test
#+BEGIN_SRC scheme -n :eval no-export  :exports both :results output code
<<count-change-graphviz>>
(count-change 1)
#+end_src

#+RESULTS[626488f89e622bb93d8813545c83ec8fe4c1254c]: count-change-test
#+begin_src dot
digraph {
"(0 1 5)" -> "(1 1 4)"
"(1 1 4)" -> "(2 1 3)"
"(2 1 3)" -> "(3 1 2)"
"(3 1 2)" -> "(4 1 1)"
"(4 1 1)" -> "(5 1 0)"
"(4 1 1)" -> "(6 0 1)"
"(3 1 2)" -> "(7 -4 2)"
"(2 1 3)" -> "(8 -9 3)"
"(1 1 4)" -> "(9 -24 4)"
"(0 1 5)" -> "(10 -49 5)"
}
#+end_src

#+BEGIN_SRC dot :file 1/fig/cc-test.png :exports results :var data=count-change-test :eval no-export
$data
#+end_src

#+RESULTS[2f9cd2c1031a74ba1f68d4d2a7602c619a798efd]:
#+ATTR_LATEX: :width 0.6\linewidth
[[file:1/fig/cc-test.png]]

So, the graph of src_scheme{(count-change 11)} is:
#+NAME: count-change-11
#+BEGIN_SRC scheme -n :eval no-export  :exports none :results silent output
<<count-change-graphviz>>
(count-change 11)
#+end_src

#+BEGIN_SRC dot :file 1/fig/cc-11.png :exports results :var data=count-change-11 :eval no-export
$data
#+end_src

#+RESULTS[914f8aa869c783656d6a64eb7535f44d22158d20]:
:results:
[[file:1/fig/cc-11.png]]
:end:

*** Question B

#+begin_quote
What are the orders of growth of the space and number of steps used by this
process as the amount to be changed increases?
#+end_quote

*** Answer B

Let's look at this via the number of function calls needed for value ~n~. Instead
of returning an integer, I'll return a pair where ~car~ is the number of ways to
count change, and ~cdr~ is the number of function calls that have occurred down
that branch of the tree.

#+NAME: cc-calls
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (count-calls amount)
  (cc-calls amount 5))

(define (cc-calls amount kinds-of-coins)
  (cond ((= amount 0) '(1 . 1))
        ((or (< amount 0)
             (= kinds-of-coins 0))
         '(0 . 1))
        (else
         (let ((a (cc-calls amount (- kinds-of-coins 1)))
               (b (cc-calls (- amount (first-denomination
                                 kinds-of-coins))
                      kinds-of-coins)))
           (cons (+ (car a)
                    (car b))
                 (+ 1
                    (cdr a)
                    (cdr b)))))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
#+end_src


#+NAME: cc-calls-check
#+BEGIN_SRC scheme -n :eval no-export  :exports none :results value table
;; Test to verify that this function is working as expected.
(use-srfis '(1))
<<count-change>>
<<cc-calls>>
(let* ((vals (drop (iota 11) 1))
       (textbook (map count-change vals))
       (mine (map count-calls vals)))
  (zip vals textbook mine))
#+end_src

#+RESULTS[b7476dc844e2456ebb48c7e96462fe180d60101b]: cc-calls-check
:results:
|  1 | 1 | (1 . 11) |
|  2 | 1 | (1 . 13) |
|  3 | 1 | (1 . 15) |
|  4 | 1 | (1 . 17) |
|  5 | 2 | (2 . 19) |
|  6 | 2 | (2 . 25) |
|  7 | 2 | (2 . 29) |
|  8 | 2 | (2 . 33) |
|  9 | 2 | (2 . 37) |
| 10 | 4 | (4 . 41) |
:end:

#+NAME: cc-calls-100
#+BEGIN_SRC scheme -n :eval no-export  :exports code :results silent value table
(use-srfis '(1))
<<cc-calls>>
(let* ((vals (drop (iota 101) 1))
       (mine (map count-calls vals)))
  (zip vals (map car mine) (map cdr mine)))
#+end_src

#+begin_src gnuplot :var data=cc-calls-100 :file 1/fig/cc-100.png :exports results :eval no-export
reset # helps with various issues in execution
set key top left
set logscale y
set xlabel 'values of n'

plot data using 1:2 with lp title 'Ways to make change for n', \
     data using 1:3 with lp title 'function calls'
#+end_src

#+RESULTS[134cbc95d12b4367d5be943722725cd0baca1d87]:
:results:
[[file:1/fig/cc-100.png]]
:end:

I believe the space to be \(\Theta(n+d)\) as the function calls count down the
denominations before counting down the change. However I notice most answers
describe \(\Theta(n)\) instead, maybe I'm being overly pedantic and getting the
wrong answer.

My issues came finding the time. The book describes the meaning and properties
of \(\Theta\) notation in [[http://sarabander.github.io/sicp/html/1_002e2.xhtml#g_t1_002e2_002e3][Section 1.2.3]]. However, my lack of formal math
education made realizing the significance of this passage difficult. For one, I
didn't understand that \(k_{1}f(n) \leq R(n) \leq k_{2}f(n)\) means "you can
find the \(\Theta\) by proving that a graph of the algorithm's resource usage is
bounded by two identical functions multiplied by constants." So, the graph of
resource usage for an algorithm with \(\Theta(n^{2})\) will by bounded by lines
of \(n^{2} \times some constant\), the top boundary's constant being larger than
the small boundary. These are arbitrarily chosen constants, you're just proving
that the function behaves the way you think it does.

Overall, finding the \(\Theta\) and \(\Omega\) and \(O\) notations (they are all
different btw!) is about aggressively simplifying to make a very general
statement about the behavior of the algorithm.

I could tell that a "correct" way to find the \(\Theta\) would be to make a
formula which describes the algorithm's function calls for given input and
denominations. This is one of the biggest time sinks, although I had a lot of
fun and learned a lot. In the end, with some help from Jach in a Lisp Discord, I
had the following formula:

\[
\sum_{i=1}^{ceil(n / val(d))} T(n - val(d)*i, d)
\]

But I wasn't sure where to go from here. The graphs let me see some interesting
trends, though I didn't get any closer to an answer in the process.

By reading on other websites, I knew that you could find \(\Theta\) by obtaining
a formula for \(R(n)\) and removing constants to end up with a term of interest.
For example, if your algorithm's resource usage is \(\frac{n^{2} + 7n}{5}\),
this demonstrates \(\Theta(n^{2})\). So I know a formula *without* a \(\sum\)
would give me the answer I wanted. It didn't occur to me that it might be
possible to use calculus to remove the \(\sum\) from the equation. At this point
I knew I was stuck and decided to look up a guide.

After seeing a few solutions that I found somewhat confusing, I landed on [[https://codology.net/post/sicp-solution-exercise-1-14/][this
awesome article from Codology.net]]. They show how you can remove the summation,
and proposed this equation for count-change with 5 denominations:

\[
T(n,5)=\frac n{50}+1+\sum_{i=0}^{n/50}T(n-50i,1)
\]

Which, when expanded and simplified, demonstrates \(\Theta(n^{5})\) for 5
denominations.

Overall I'm relieved that I wasn't entirely off, given I haven't done math work
like this since college. It's inspired me to restart my remedial math courses, I
don't think I really grasped the nature of math as a tool of empowerment until
now.

** Exercise 1.15

*** Question A

#+begin_quote
The sine of an angle (specified in radians) can be computed by making use of the
approximation \(\sin x \approx x\) if \(x\) is sufficiently small, and the
trigonometric identity \(\sin x = 3\sin\frac{x}{3} - 4\sin^3\frac{x}{3}\)
to reduce the size of the argument of sin. (For purposes of this exercise an
angle is considered "sufficiently small" if its magnitude is not greater than
0.1 radians.) These ideas are incorporated in the following procedures:
#+end_quote

#+NAME: 1-15-deps
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))
#+end_src

#+begin_quote
How many times is the procedure ~p~ applied when src_scheme{(sine 12.15)} is
evaluated?
#+end_quote

*** Answer A

Let's find out!
#+NAME: 1-15-p-measure
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
  (if (not (> (abs angle) 0.1))
      (cons angle 0)
      (let ((x (sine (/ angle 3.0))))
        (cons (p (car x)) (+ 1 (cdr x))))))
#+end_src

#+NAME: 1-15-sine1215
#+BEGIN_SRC scheme -n :eval no-export  :exports both :results value
<<1-15-p-measure>>
(let ((xy (sine 12.15)))
  (list (car xy) (cdr xy)))
#+end_src

#+RESULTS[a951cb0c1f0af6041c8ea65b70c08abec9d7fd95]: 1-15-sine1215
:results:
| -0.39980345741334 | 5 |
:end:

~p~ is evaluated 5 times.

*** Question B

#+begin_quote
What is the order of growth in space and number of steps (as a function of ~a~)
used by the process generated by the sine procedure when src_scheme{(sine a)} is
evaluated?
#+end_quote

*** Answer B

#+NAME: 1-15-tab1
#+BEGIN_SRC scheme -n :eval no-export  :exports both :results silent value table
(use-srfis '(1))
<<1-15-p-measure>>
(let* ((vals (iota 300 0.1 0.1))
       (sines (map (λ (i)
                     (cdr (sine i)))
                   vals)))
  (zip vals sines))
#+end_src
#+NAME: 1-15-tab1-test
#+BEGIN_SRC scheme -n :eval no-export  :exports result :results value table
(use-srfis '(1))
<<1-15-p-measure>>
(let* ((vals (iota 10 0.1 0.1))
       (sines (map (λ (i)
                     (cdr (sine i)))
                   vals)))
  (zip vals sines))
#+end_src

Example output:
#+RESULTS[fb3135304f5470edbe145abf5ad93ef8829e4e8c]: 1-15-tab1-test
:results:
|                 0.1 | 0 |
|                 0.2 | 1 |
| 0.30000000000000004 | 2 |
|                 0.4 | 2 |
|                 0.5 | 2 |
|                 0.6 | 2 |
|  0.7000000000000001 | 2 |
|                 0.8 | 2 |
|                 0.9 | 2 |
|                 1.0 | 3 |
:end:
#+BEGIN_COMMENT
#+NAME: 1-15-smoothfill
#+begin_src gnuplot :var data=1-15-tab1 :file 1/fig/1-15-smoothfill.png :exports none :eval no-export
# This graph has a cool filled difference, but unfortunately I can't do
# steps with it, so it's disabled. :(
reset # helps with various issues in execution
set xlabel 'values of x'
set logscale x
set key top left
set style fill solid 1.00 border
set style function fillsteps below y

f(x) = log(x) + 2.3

plot data using 1:2:(f($1)) with filledcurves title 'function calls', \
     data using 1:(f($1)) with lines title 'log(x) + 2.3'
#+end_src

#+RESULTS[cda98404343075e48a2b594fa5d2b60803f911d3]: 1-15-smoothfill
:results:
[[file:1/fig/1-15-smoothfill.png]]
:end:
#+END_COMMENT

#+begin_src gnuplot :var data=1-15-tab1 :file 1/fig/1-15-step.png :exports results :eval no-export
reset # helps with various issues in execution
set xlabel 'values of x'
set logscale x
set key top left
set style fill solid 1.00 border
set style function fillsteps below

f(x) = log(x) + 2.3

plot data using 1:2 with fillsteps title 'function calls', \
     data using 1:(f($1)) with lines title 'log(x) + 2. 3'
#+end_src

#+RESULTS[460dc2cffdff776bf4e3a46cb26ac66180108b4a]:
:results:
file:1/fig/1-15-step.png
:end:

This graph shows that the number of times ~sine~ will be called is logarithmic.
- 0.1 to 0.2 are divided once
- 0.3 to 0.8 are divided twice
- 0.9 to 2.6 are divided three times
- 2.7 to 8 are divided four times
- 8.5 to 23.8 are divided five times

Given that the calls to ~p~ get stacked recursively, like this:
#+BEGIN_SRC scheme :noeval :exports code
(sine 12.15)
(p (sine 4.05))
(p (p (sine 1.35)))
(p (p (p (sine 0.45))))
(p (p (p (p (sine 0.15)))))
(p (p (p (p (p (sine 0.05))))))
(p (p (p (p (p 0.05)))))
(p (p (p (p 0.14950000000000002))))
(p (p (p 0.43513455050000005)))
(p (p 0.9758465331678772))
(p -0.7895631144708228)
-0.39980345741334
#+END_SRC

So I argue the space and time is \(\Theta(\log(n))\)


We can also prove this for the time by benchmarking the function:

#+NAME: 1-15-sine-bench
#+BEGIN_SRC scheme -n :noeval :tangle "1/Ex15/sine-bench.scheme" :exports code :results none
;; This execution takes too long for org-mode, so I'm doing it
;; externally and importing the results
(use-srfis '(1))
(use-modules (ice-9 format))
(load "../../mattbench.scm")
<<1-15-deps>>
(let* ((vals (iota 300 0.1 0.1))
       (times (map (λ (i)
                     (mattbench (λ () (sine i)) 1000000))
                   vals)))
  (with-output-to-file "sine-bench.dat" (λ ()
     (map (λ (x y)
           (format #t "~s~/~s~%" x y))
         vals times))))
#+END_SRC

#+begin_src gnuplot :file 1/fig/1-15-bench.png :exports both :eval no-export
reset # helps with various issues in execution
set xtics 0.5
set xlabel 'values of x'
set logscale x
set key top left
set style fill solid 1.00 border
#set style function fillsteps below

f(x) = (log(x) * a) + b
fit f(x) 'Ex15/sine-bench.dat' using 1:2 via a,b

plot 'Ex15/sine-bench.dat' using 1:2 with fillsteps title 'time to execute', \
     'Ex15/sine-bench.dat' using 1:(f($1)) with lines title sprintf('(log(x) * %.2f) + %.2f', a, b)
#+end_src

#+RESULTS[fb7f0aefd66103c1d2a3d67706e4323de589c4f9]:
:results:
[[file:1/fig/1-15-bench.png]]
:end:

**** 1.2.4 Exponentiation

Considering a few ways to compute the exponential of a given number.

#+begin_src scheme
(define (expt b n)
  (expt-iter b n 1))
(define (expt-iter b counter product)
  (if (= counter 0)
      product
      (expt-iter b (- counter 1) (* b product))))
#+end_src

This iterative procedure is essentially equivalent to:

\[b^{8} = b \cdot (b \cdot (b \cdot (b \cdot (b \cdot (b \cdot (b \cdot b))))))\]

But note it could be approached faster with squaring:

\[\begin{aligned}b^2 &= b \cdot b\\
b^4 &= b^2\cdot b^2\\
b^8 &= b^4 \cdot b^4\end{aligned}\]

** Exercise 1.16

*** Text

#+NAME: txt-expt
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (expt-rec b n)
  (if (= n 0) 
      1 
      (* b (expt-rec b (- n 1)))))

(define (expt-iter b n) 
  (define (iter counter product)
    (if (= counter 0)
        product
        (iter (- counter 1)
              (* b product))))
  (iter n 1))

(define (fast-expt b n)
  (cond ((= n 0) 
         1)
        ((even? n) 
         (square (fast-expt b (/ n 2))))
        (else 
         (* b (fast-expt b (- n 1))))))
#+end_src

*** Question

#+begin_quote
Design a procedure that evolves an iterative exponentiation process that uses
successive squaring and uses a logarithmic number of steps, as does fast-expt.
(Hint: Using the observation that \((b^{n/2})^2=(b^2)^{n/2}\), keep, along with
the exponent \(n\) and the base \(b\), an additional state variable \(a\) , and
define the state transformation in such a way that the product \({ab}^n\) is
unchanged from state to state. At the beginning of the process \(a\) is taken to
be 1, and the answer is given by the value of \(a\) at the end of the process.
In general, the technique of defining an /invariant quantity/ that remains
unchanged from state to state is a powerful way to think about the design of
iterative algorithms.)
#+end_quote

*** Diary

First I made this program which tries to use a false equivalence:
\[ab^2 = (a + 1)b^{n - 1}\]
#+NAME: fast-expt-iter-fail1
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
<<square>>
(define (fast-expt-iter b n)
  (define (iter b n a)
    (format #t "~&|~s~/~/|~s~/~/|~s|~%" b n a)
    (cond ((= n 1) (begin (format #t "~&|~s~/~/|~s~/~/|~s|~%" (* b a) 1 1)
                          (* b a)))
          ((even? n) (iter (square b)
                         (/ n 2)
                         a))
          (else (iter b (- n 1) (+ a 1)))))
  (format #t "|~a~/|~a~/|~a|~%" "base" "power" "variable")
  (format #t "~&|--|--|--|~%")
  (iter b n 1))
#+end_src

#+BEGIN_SRC scheme -n :eval no-export  :exports both :results output table :colnames yes
<<fast-expt-iter-fail1>>
<<try-these>>
(fast-expt-iter 2 6)
#+end_src

Here's what the internal state looks like during \(2^6\) (correct answer is 64):
#+RESULTS[314048443b97e46f3f43465460b4f52dc1e4a12c]:
:results:
| base | power | variable |
|------+-------+----------|
|    2 |     6 |        1 |
|    4 |     3 |        1 |
|    4 |     2 |        2 |
|   16 |     1 |        2 |
|   32 |     1 |        1 |
:end:

*** Answer

There are two key transforms to a faster algorithm. The first was already shown
in the text:

\[
    ab^n \to a(b^2)^{n/2}
\]

The second which I needed to deduce was this:

\[
    ab^n \to ((a \times b) \times b)^{n - 1}
\]

The solution essentially follows this logic:
- initialize \(a\) to 1
- If \( n \) is 1, return \(b * a\)
- else if \(n\) is even, halve \(n\), square \(b\), and iterate
- else \(n\) is odd, so subtract 1 from \(n\) and \(a \to a \times b\)

#+NAME: fast-expt-iter
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
<<square>>
(define (fast-expt-iter b n)
  (define (iter b n a)
    (cond ((= n 1) (* b a))
          ((even? n) (iter (square b)
                         (/ n 2)
                         a))
          (else (iter b (- n 1) (* b a)))))
  (iter b n 1))
#+end_src

#+BEGIN_SRC scheme -n :eval no-export  :exports yes :results value table
<<fast-expt-iter>>
<<try-these>>
(try-these (λ(x) (fast-expt-iter 3 x)) (cdr (iota 11)))
#+end_src

#+RESULTS[ae537d78c52d471bef9f5b0951596dc3d4340603]:
:results:
|  1 |     3 |
|  2 |     9 |
|  3 |    27 |
|  4 |    81 |
|  5 |   243 |
|  6 |   729 |
|  7 |  2187 |
|  8 |  6561 |
|  9 | 19683 |
| 10 | 59049 |
:end:

** Exercise 1.17

*** Question

#+begin_quote
The exponentiation algorithms in this section are based on performing
exponentiation by means of repeated multiplication. In a similar way, one can
perform integer multiplication by means of repeated addition. The following
multiplication procedure (in which it is assumed that our language can only add,
not multiply) is analogous to the expt procedure:
#+end_quote

#+BEGIN_SRC scheme -n
(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))
#+end_src

#+begin_quote
This algorithm takes a number of steps that is linear in \( b \). Now suppose we
include, together with addition, operations double, which doubles an integer,
and halve, which divides an (even) integer by 2. Using these, design a
multiplication procedure analogous to fast-expt that uses a logarithmic number
of steps.
#+end_quote

*** Answer

#+NAME: fast-mult-rec
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (double x)
  (+ x x))
(define (halve x)
  (/ x 2))
(define (fast-mult-rec a b)
  (cond ((= b 0) 0)
        ((even? b)
         (double (fast-mult-rec a (halve b)))) ; This was kind of a stretch to think of.G
         ;(fast-mult (double a) (halve b))) <== My first instinct is iterative
        (else (+ a (fast-mult-rec a (- b 1))))))
#+end_src

Proof it works:

#+BEGIN_SRC scheme -n :eval no-export  :exports yes :results value table
<<fast-mult-rec>>
<<try-these>>
(try-these (λ(x) (fast-mult-rec 3 x)) (cdr (iota 11)))
#+end_src

#+RESULTS[3ce2cd1f0e04c83aac17e721c2e17a937fc0cb25]:
:results:
|  1 |  3 |
|  2 |  6 |
|  3 |  9 |
|  4 | 12 |
|  5 | 15 |
|  6 | 18 |
|  7 | 21 |
|  8 | 24 |
|  9 | 27 |
| 10 | 30 |
:end:

** Exercise 1.18

*** Question

#+begin_quote
Using the results of Exercise 1.16 and Exercise 1.17, devise a procedure that
generates an iterative process for multiplying two integers in terms of adding,
doubling, and halving and uses a logarithmic number of steps.
#+end_quote

*** Diary

**** Comparison benchmarks:

#+BEGIN_SRC scheme -n :tangle 1/Ex1-18bench.scheme :exports code :results silent
(load "../mattbench.scm")
<<fast-mult-iter>>
<<fast-mult-rec>>
<<print-table>>
(print-table (list (list "fast-mult-rec" "fast-mult-iter")
                   (list (mattbench (λ() (fast-mult-rec 32 32)) 10000000)
                         (mattbench (λ() (fast-mult 32 32)) 10000000)))
             #:colnames #t)
#+END_SRC

| "fast-mult-rec" | "fast-mult-iter" |
|-----------------+------------------|
|          196.89 |           166.35 |

So the iterative version takes 0.84 times less to do \(32 \times 32\).

**** Hall of shame

Some of my /very/ incorrect ideas:
\[ab = (a+1)(b-1)\]
\[ab = \big(a+\Big(\frac{a}{2}\Big)(b-1)\big)\]
\[ab+c = \big(a(b-1)+(b+c)\big)\]

*** Answer

#+NAME: fast-mult-iter
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (double x)
  (+ x x))
(define (halve x)
  (/ x 2))
(define (fast-mult a b)
  (define (iter a b c)
    (cond ((= b 0) 0)
          ((= b 1) (+ a c))
          ((even? b)
           (iter (double a) (halve b) c))
          (else (iter a (- b 1) (+ a c)))))
  (iter a b 0))
#+end_src
#+BEGIN_SRC scheme -n :eval no-export  :exports yes :results value table
<<fast-mult-iter>>
<<try-these>>
(try-these (λ(x) (fast-mult 3 x)) (cdr (iota 11)))
#+end_src

#+RESULTS[900f6cc983a51f9e0902587546cbd7d746845b50]:
:results:
|  1 |  3 |
|  2 |  6 |
|  3 |  9 |
|  4 | 12 |
|  5 | 15 |
|  6 | 18 |
|  7 | 21 |
|  8 | 24 |
|  9 | 27 |
| 10 | 30 |
:end:

** Exercise 1.19

*** Question

#+begin_quote
There is a clever algorithm for computing the Fibonacci numbers in a logarithmic
number of steps. Recall the transformation of the state variables a and b in the
~fib-iter~ process of section 1-2-2:

\[a <- a + b\text{ and }b <- a\]

Call this transformation T, and observe that applying T over and over again n
times, starting with 1 and 0, produces the pair _Fib_(n + 1) and _Fib_(n). In
other words, the Fibonacci numbers are produced by applying \( T^n \), the nth
power of the transformation T, starting with the pair (1,0). Now consider T to
be the special case of p = 0 and q = 1 in a family of transformations \(
T_{(pq)} \), where \( T_{(pq)} \) transforms the pair (a,b) according to \( a <-
bq + aq + ap \) and \( b <- bp + aq \). Show that if we apply such a
transformation \( T_{(pq)} \) twice, the effect is the same as using a single
transformation \( T_{(p'q')} \) of the same form, and compute p' and q' in terms
of p and q. This gives us an explicit way to square these transformations, and
thus we can compute \( T^n \) using successive squaring, as in the `fast-expt'
procedure. Put this all together to complete the following procedure, which runs
in a logarithmic number of steps:
#+end_quote
#+BEGIN_SRC scheme -n :noeval  :exports code :results silent
(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   <??>      ; compute p'
                   <??>      ; compute q'
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
#+END_SRC

*** Diary

More succinctly put:

\[
    \text{Fib}_n \begin{cases}
        a \leftarrow a + b\\
        b \leftarrow a
    \end{cases}
\]
\[
    \text{Fib-iter}_{abpq} \begin{cases}
        a \leftarrow bq + aq + ap\\
        b \leftarrow bp + aq
    \end{cases}
\]

src_scheme{(T)} returns a transformation function based on the two numbers in
the attached list. so src_scheme{(T 0 1)} returns a fib function.

#+NAME: T-func
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (T p q)
  (λ (a b)
    (cons (+ (* b q) (* a q) (* a p))
          (+ (* b p) (* a q)))))

(define T-fib
  (T 0 1))

;; Repeatedly apply T functions:
(define (Tr f n)
  (Tr-iter f n 0 1))
(define (Tr-iter f n a b)
  (if (= n 0)
      a
      (let ((l (f a b)))
        (Tr-iter f (- n 1) (car l) (cdr l)))))
#+END_SRC

\[
    \text{T}_{pq}: a,b\mapsto \begin{cases}
        a \leftarrow bq + aq + ap\\
        b \leftarrow bp + aq
    \end{cases}
\]

#+NAME: T-test
#+BEGIN_SRC scheme -n :eval no-export  :exports both :results value table
<<T-func>>
<<try-these>>
(try-these (λ (x) (Tr (T 0 1) x)) (cdr (iota 11)))
#+END_SRC

#+RESULTS[b253f74cff9961bd33f160a88f16f5986ecc2d07]: T-test
:results:
|  1 |  1 |
|  2 |  1 |
|  3 |  2 |
|  4 |  3 |
|  5 |  5 |
|  6 |  8 |
|  7 | 13 |
|  8 | 21 |
|  9 | 34 |
| 10 | 55 |
:end:

*** Answer

#+NAME: fib-iter-T
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (fib-rec n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib-rec (- n 1))
                 (fib-rec (- n 2))))))
(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (+ (* p p)
                      (* q q))      ; compute p'
                   (+ (* p q)
                      (* q q)
                      (* q p))      ; compute q'
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
#+END_SRC

#+NAME: fib-iter-test
#+BEGIN_SRC scheme -n :eval no-export  :exports results :results output table :colnames yes
(use-srfis '(1))
<<fib-iter-T>>
<<print-table>>
(let* ((l (cdr (iota 11)))
       (fr (map fib-rec l))
       (fi (map fib l)))
  (print-table (cons (list "n" "fib-rec" "fib-iter")
                     (zip l fr fi))
               #:colnames #t))
#+END_SRC

#+RESULTS[30d4713e3cba0984d5cc3e0b400adc130f553a29]: fib-iter-test
:results:
| "n" | "fib-rec" | "fib-iter" |
|-----+-----------+------------|
|   1 |         1 |          1 |
|   2 |         1 |          1 |
|   3 |         2 |          2 |
|   4 |         3 |          3 |
|   5 |         5 |          5 |
|   6 |         8 |          8 |
|   7 |        13 |         13 |
|   8 |        21 |         21 |
|   9 |        34 |         34 |
:end:

** 1.2.5: Greatest Common Divisor

A greatest common divisor (or GCD) for two integers is the largest integer that
divides both of them. A GCD can be quickly found by transforming the problem
like so: \[a \% b = r\]

\[\text{GCD}(a, b) = \text{GCD}(b, r)\]

This eventually produces a pair where the second number is 0. Then, the GCD is
the other number in the pair. This is Euclid's Algorithm.

\[\begin{aligned}\text{GCD}(206,40) &= \text{GCD}(40,6)\\ &=
            \text{GCD}(6,4)\\ &= \text{GCD}(4,2)\\ &~ \text{GCD}(2,0) ~
            2\end{aligned}\]

#+begin_quote
  *Lamé's Theorem:* If Euclid's Algorithm requires \(k\) steps to compute the
   GCD of some pair, then the smaller number in the pair must be greater than or
   equal to the \(k^{th}\)Fibonacci number.
#+end_quote

** Exercise 1.20

*** Text

#+NAME: gcd
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
#+END_SRC

*** Question

#+begin_quote
The process that a procedure generates is of course dependent on the rules used
by the interpreter. As an example, consider the iterative src_scheme{gcd}
procedure given above. Suppose we were to interpret this procedure using
normal-order evaluation, as discussed in 1.1.5: The Substitution Model for Procedure Application. (The normal-order-evaluation
rule for src_scheme{if} is described in Exercise 1.5.) Using the substitution
method (for normal order), illustrate the process generated in evaluating
src_scheme{(gcd 206 40)} and indicate the src_scheme{remainder} operations that
are actually performed. How many src_scheme{remainder} operations are actually
performed in the normal-order evaluation of src_scheme{(gcd 206 40)}? In the
applicative-order evaluation?
#+end_quote

*** Answer

I struggled to understand this, but the key here is that normal-order evaluation
causes the unevaluated expressions to be duplicated, meaning they get evaluated
multiple times.

**** Applicative order

#+begin_src scheme
call (gcd 206 40)
(if)
(gcd 40 (remainder 206 40))
eval remainder before call
call (gcd 40 6)
(if)
(gcd 6 (remainder 40 6))
eval remainder before call
call (gcd 6 4)
(if)
(gcd 2 (remainder 4 2))
eval remainder before call
call (gcd 2 0)
(if)
;; => 2
#+end_src

#+begin_src scheme
;; call gcd
(gcd 206 40)

;; eval conditional
(if (= 40 0)
    206
    (gcd 40 (remainder 206 40)))

;; recurse
(gcd 40 (remainder 206 40))

; encounter conditional
(if (= (remainder 206 40) 0)
    40
    (gcd (remainder 206 40)
         (remainder 40 (remainder 206 40))))

; evaluate 1 remainder
(if (= 6 0)
    40
    (gcd (remainder 206 40)
         (remainder 40 (remainder 206 40))))

; recurse
(gcd (remainder 206 40)
     (remainder 40 (remainder 206 40)))

; encounter conditional
(if (= (remainder 40 (remainder 206 40)) 0)
    (remainder 206 40)
    (gcd (remainder 40 (remainder 206 40))
         (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))

; eval 2 remainder
(if (= 4 0)
    (remainder 206 40)
    (gcd (remainder 40 (remainder 206 40))
         (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))

; recurse
(gcd (remainder 40 (remainder 206 40))
     (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))

; encounter conditional
(if (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0)
    (remainder 40 (remainder 206 40))
    (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
         (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))

; eval 4 remainders
(if (= 2 0)
    (remainder 40 (remainder 206 40))
    (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
         (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))

; recurse
(gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
     (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))

; encounter conditional
(if (= (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 0)
    (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
    (gcd (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) (remainder a  (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))

; eval 7 remainders
(if (= 0 0)
    (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
    (gcd (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) (remainder a  (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))

; eval 4 remainders
(remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
; => 2
#+end_src

So, in normal-order eval, remainder is called 18 times, while in applicative order
it's called 5 times.

** 1.2.6: Example: Testing for Primality

Two algorithms for testing primality of numbers.

1. \(\Theta(\sqrt{n})\): Start with \(x = 2\), check for divisibility with
   \(n\), if not then increment \(x\) by 1 and check again. If \(x^2 > n\) and
   you haven't found a divisor, \(n\) is prime.
2. \(\Theta(\log n)\): Given a number \(n\), pick a random number \(a < n\) and
   compute the remainder of \(a^n\) modulo \(n\). If the result is not equal to
   \(a\), then \(n\) is certainly not prime. If it is \(a\), then chances are
   good that \(n\) is prime. Now pick another random number \(a\) and test it
   with the same method. If it also satisfies the equation, then we can be even
   more confident that \(n\) is prime. By trying more and more values of \(a\),
   we can increase our confidence in the result. This algorithm is known as the
   Fermat test.

#+begin_quote
  *Fermat's Little Theorem:* If \(n\) is a prime number and \(a\) is any
   positive integer less than \(n\), then \(a\) raised to the \(n^{th}\) power
   is congruent to \(a\) modulo \(n\). [Two numbers are /congruent modulo/ \(n\)
   if they both have the same remainder when divided by \(n\).]
#+end_quote

The Fermat test is a probabilistic algorithm, meaning its answer is likely to be
correct rather than guaranteed to be correct. Repeating the test increases the
likelihood of a correct answer.

** Exercise 1.21

*** Text

#+NAME: find-divisor-txt
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
<<square>>
(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) 
         n)
        ((divides? test-divisor n) 
         test-divisor)
        (else (find-divisor 
               n 
               (+ test-divisor 1)))))

(define (divides? a b)
  (= (remainder b a) 0))
#+END_SRC

*** Question

#+begin_quote
Use the smallest-divisor procedure to find the smallest divisor of each of the
following numbers: 199, 1999, 19999.
#+end_quote

*** Answer

#+BEGIN_SRC scheme -n :eval no-export  :exports both :results value table
<<find-divisor-txt>>
(map smallest-divisor '(199 1999 19999))
#+END_SRC

#+RESULTS[b3eac1941abc1f7ef3cd63a42e5167ad47fcdaf9]:
:results:
| 199 | 1999 | 7 |
:end:

** Exercise 1.22

*** Question

#+begin_quote
Most Lisp implementations include a primitive called src_scheme{runtime} that
returns an integer that specifies the amount of time the system has been running
(measured, for example, in microseconds). The following
src_scheme{timed-prime-test} procedure, when called with an integer \(n\),
prints \(n\) and checks to see if \(n\) is prime. If \(n\) is prime, the
procedure prints three asterisks followed by the amount of time used in
performing the test.
#+end_quote
#+NAME: prime-smallest-divisor
#+BEGIN_SRC scheme -n :eval no-export :exports code :results output
<<find-divisor-txt>>
(define (prime? n)
  (= n (smallest-divisor n)))
#+END_SRC
#+NAME: timed-prime-test-txt
#+BEGIN_SRC scheme -n :eval no-export :exports code :results output
<<prime-smallest-divisor>>
(define (timed-prime-test n)
  (newline)
  (display n) ;; Guile compatible \downarrow
  (start-prime-test n (get-internal-run-time)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (begin
        (report-prime (- (get-internal-run-time) 
                       start-time))
        n)
      #f))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))
#+END_SRC

#+begin_quote
Using this procedure, write a procedure src_scheme{search-for-primes} that
checks the primality of consecutive odd integers in a specified range. Use your
procedure to find the three smallest primes larger than 1000; larger than
10,000; larger than 100,000; larger than 1,000,000. Note the time needed to test
each prime. Since the testing algorithm has order of growth of
\(\Theta(\sqrt{n\))}, you should expect that testing for primes around 10,000
should take about \(\sqrt{10\)} times as long as testing for primes around 1000.
Do your timing data bear this out? How well do the data for 100,000 and
1,000,000 support the \(\Theta(\sqrt{n\))} prediction? Is your result compatible
with the notion that programs on your machine run in time proportional to the
number of steps required for the computation?
#+end_quote

*** Answer

**** Part 1

So this question is a little funky, because modern machines are so fast that the
single-run times can seriously vary.

#+NAME: search-primes-basic
#+BEGIN_SRC scheme -n :eval no-export  :exports both :results output
<<timed-prime-test-txt>>
(define (search-for-primes minimum goal)
  (define m (if (even? minimum)
                (+ minimum 1)
                (minimum)))
  (search-for-primes-iter m '() goal))
(define (search-for-primes-iter n lst goal)
  (if (= goal 0)
      lst
      (let ((x (timed-prime-test n)))
        (if (not (equal? x #f))
            (search-for-primes-iter (+ n 2) (cons x lst) (- goal 1))
            (search-for-primes-iter (+ n 2) lst goal)))))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export  :exports both :results output code
<<search-primes-basic>>
(let ((lt1000-1 (search-for-primes 1000 3)))
  (list "Primes > 1000" lt1000-1))
#+END_SRC

#+RESULTS[789a768bd75038c772a9f1e759006de07b1106de]:
#+begin_src scheme
1001
1003
1005
1007
1009 *** 1651
1011
1013 *** 1425
1015
1017
1019 *** 1375
#+end_src

There's proof it works. And here are the answers to the question:

#+BEGIN_SRC scheme -n :eval no-export  :exports both :results value table :rownames yes
<<search-primes-basic>>
(let ((lt1000-1 (search-for-primes 1000 3))
      (lt10000-1 (search-for-primes 10000 3))
      (lt100000-1 (search-for-primes 100000 3))
      (lt100000000-1 (search-for-primes 1000000 3)))
  (list
   (list "Primes > 1000" (reverse lt1000-1))
   (list "Primes > 10000" (reverse lt10000-1))
   (list "Primes > 100000" (reverse lt100000-1))
   (list "Primes > 100000000" (reverse lt100000000-1))
   ))
#+END_SRC

#+RESULTS[1591ff4ac17eefbd2a343012149c10f419199b20]:
:results:
| Primes > 1000      | (1009 1013 1019)          |
| Primes > 10000     | (10007 10009 10037)       |
| Primes > 100000    | (100003 100019 100043)    |
| Primes > 100000000 | (1000003 1000033 1000037) |
:end:

**** Part 2

Repeatedly re-running, it I see it occasionally jump to twice the time. I'm not
happy with this, so I'm going to refactor to use the ~mattbench2~ utility from
the root of the project folder.

#+NAME: mattbench2
#+begin_src scheme :exports code :eval no-export :results output
(define (mattbench2 f n)
  ;; Executes "f" for n times, and returns how long it took.
  ;; f is a lambda that takes no arguments, a.k.a. a "thunk"
  
  ;; Returns a list with car(last execution results) and cadr(time taken divided by iterations n)

  (define (time-getter) (get-internal-run-time))
  (define start-time (time-getter))
  (define (how-long) (- (time-getter) start-time))

  (define (iter i)
    (f)
    (if (<= i 0)
        (f) ;; return the results of the last function call
        (iter (- i 1))))

  (list (iter n) ;; result of last call of f
        (/ (how-long) (* n 1.0))));; Divide by iterations so changed n has no effect
#+end_src

I'm going to get some more precise times. First, I need a prime searching
variant that doesn't bother benchmarking. This will call ~prime?~, which will be
bound later since we'll be trying different methods.
#+NAME: search-for-primes-untimed
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (search-for-primes minimum goal)
  (define m (if (even? minimum)
                (+ minimum 1)
                (minimum)))
  (search-for-primes-iter m '() goal))
(define (search-for-primes-iter n lst goal)
  (if (= goal 0)
      lst
      (let ((x (prime? n)))
        (if (not (equal? x #f))
            (search-for-primes-iter (+ n 2) (cons n lst) (- goal 1))
            (search-for-primes-iter (+ n 2) lst goal)))))
#+END_SRC

I can benchmark these functions like so:
#+NAME: smallest-divisor-benchmark
#+BEGIN_SRC scheme -n :noeval :tangle 1/primebench/smd.scheme :exports both :results output table :colnames yes :rownames :yes
<<mattbench2>>
<<prime-smallest-divisor>>
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 1000000)
(define (testit f)
  (list (cadr (mattbench2 (λ() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
#+END_SRC

Here are the results (run externally from Org-Mode):

#+NAME: 1-22-smd
| 5425.223086 | 20772.332491 | 53577.240193 | 121986.712395 |

#+NAME: 1-22-smd-massage
#+BEGIN_SRC scheme :eval no-export :results value table :var data=1-22-smd :exports none :rownames no :colnames no
;(map (lambda(x y) (list x y))
<<transpose-list>>
(use-srfis '(1))
(zip
     '(1000 10000 100000 1000000)
     (car data))
#+END_SRC

#+RESULTS[d7791f01b4f72498262d52b8327962e122163a15]: 1-22-smd-massage
:results:
|    1000 |   5425.223086 |
|   10000 |  20772.332491 |
|  100000 |  53577.240193 |
| 1000000 | 121986.712395 |
:end:

#+begin_src gnuplot :var data=1-22-smd-massage :file 1/fig/1-22-1.png :exports results :eval no-export :rownames no :colnames no
reset
set logscale x
set xlabel 'minimum number'
set xtics rotate by -45
set title 'time to run prime search (x scaled log)'

f(x) = sqrt((x * a) + b)
fit f(x) data using 1:2 via a,b

plot data using 1:2 with linespoints title 'time to find primes', \
     data using 1:(f($1)) with linespoints title \
     sprintf('sqrt(x * %.2f + %.2f)', a, b)
#+end_src

#+RESULTS[27d02bff03e8cb41df0bcd04f4c853b65910088d]:
:results:
file:1/fig/1-22-1.png
:end:

The plot for the square root function doesn't quite fit the real one and I'm not
sure where the fault lies. I don't struggle to understand things like "this
algorithm is slower than this other one," but when asked to find or prove the
\(\Theta\) notation I'm pretty clueless;

** Exercise 1.23

*** Question

#+begin_quote
The ~smallest-divisor~ procedure shown at the start of this section does lots of
needless testing: After it checks to see if the number is divisible by 2 there
is no point in checking to see if it is divisible by any larger even numbers.
This suggests that the values used for test-divisor should not be 2, 3, 4, 5, 6,
\dots, but rather 2, 3, 5, 7, 9, \dots. To implement this change, define a procedure
~next~ that returns 3 if its input is equal to 2 and otherwise returns its input
plus 2. Modify the smallest-divisor procedure to use src_scheme{(next
test-divisor)} instead of src_scheme{(+ test-divisor 1)}. With
~timed-prime-test~ incorporating this modified version of ~smallest-divisor~,
run the test for each of the 12 primes found in Exercise 1.22. Since this
modification halves the number of test steps, you should expect it to run about
twice as fast. Is this expectation confirmed? If not, what is the observed ratio
of the speeds of the two algorithms, and how do you explain the fact that it is
different from 2?
#+end_quote

*** A Comedy of Error (just the one)

#+NAME: find-divisor-faster
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
<<square>>
(define (smallest-divisor n)
  (find-divisor n 2))

(define (next n)
  (if (= n 2)
      3
      (+ n 1)))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) 
         n)
        ((divides? test-divisor n) 
         test-divisor)
        (else (find-divisor 
               n 
               (next test-divisor)))))

(define (divides? a b)
  (= (remainder b a) 0))
#+END_SRC
#+NAME: smallest-divisor-benchmark
#+BEGIN_SRC scheme -n :noeval :tangle 1/primebench/smdf.scheme :exports code
<<mattbench2>>
<<find-divisor-faster>>
(define (prime? n)
  (= n (smallest-divisor n)))
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 1000000)
(define (testit f)
  (list (cadr (mattbench2 (λ() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
#+END_SRC

#+NAME: 1-22-smdf
| 6456.538118 | 25550.757304 | 66746.041644 | 148505.580638 |


#+NAME: 1-22-smdf-massage
#+BEGIN_SRC scheme :eval no-export :results value table :var smd=1-22-smd smdf=1-22-smdf :exports results :rownames no :colnames no
<<print-table-spaced>>
(use-srfis '(1))
(zip '("min" 1000 10000 100000 1000000)
     (cons "(+1)" (car smd))
     (cons "(next)" (car smdf)))
#+END_SRC

#+RESULTS[c27614e8028f15b657e68959798c723a002730b3]: 1-22-smdf-massage
:results:
|     min |         (+1) |       (next) |
|    1000 |   5507.42497 |   6366.99462 |
|   10000 |  20913.71497 |   24845.9193 |
|  100000 |  53778.74737 |  64756.73693 |
| 1000000 | 122135.60511 | 143869.63561 |
:end:

#+begin_src gnuplot :var data=1-22-smdf-massage :file 1/fig/1-22-2.png :exports results :eval no-export :rownames no :colnames no :cache no
reset
set logscale x
set xlabel 'minimum number'
set xtics rotate by -45
set ylabel 'time'
set title 'time to run prime search (x scaled log)'

plot data using 2:xticlabels(1) with linespoints title '(+ 1)', \
     data using 3:xticlabels(1) with linespoints title '(next)'
#+end_src

#+RESULTS[a092c209836cb659130fe0ad3bff2d3f23674f1b]:
:results:
[[file:1/fig/1-22-2.png]]
:end:

So it's /slower/ than before. Why?

Oh, that's why.
#+BEGIN_SRC scheme
(define (next n)
  (if (= n 2)
      3
      (+ n 1))) ;; <-- D'oh.
#+END_SRC

*** Answer

Ok, let's try that again.

#+NAME: find-divisor-faster-real
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
<<square>>
(define (smallest-divisor n)
  (find-divisor n 2))

(define (next n)
  (if (= n 2)
      3
      (+ n 2)))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) 
         n)
        ((divides? test-divisor n) 
         test-divisor)
        (else (find-divisor 
               n 
               (next test-divisor)))))

(define (divides? a b)
  (= (remainder b a) 0))
#+END_SRC
#+NAME: smallest-divisor-benchmark-real
#+BEGIN_SRC scheme -n :noeval :tangle 1/primebench/smdff.scheme :exports code
<<mattbench2>>
<<find-divisor-faster-real>>
(define (prime? n)
  (= n (smallest-divisor n)))
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 500000)
(define (testit f)
  (list (cadr (mattbench2 (λ() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
#+END_SRC

#+NAME: 1-22-smdff
| 3863.7424 | 13519.209814 | 33520.676384 | 73005.539932 |

#+NAME: 1-22-smdff-massage
#+BEGIN_SRC scheme :eval no-export :results value table :var smd=1-22-smd smdf=1-22-smdf smdff=1-22-smdff :exports results :rownames no :colnames no
<<print-table-spaced>>
(use-srfis '(1))
(zip '("min" "---" 1000 10000 100000 1000000)
     (append '("(+1)" "---") (car smd))
     (append '("(next-broken)" "---") (car smdf))
     (append '("(next-fixed)" "---") (car smdff)))
#+END_SRC

#+RESULTS[3a23c115d64c3bee2872b55f0746322d1d80471e]: 1-22-smdff-massage
:results:
|     min |          (+1) | (next-broken) | (next-fixed) |
|     --- |           --- |           --- |          --- |
|    1000 |   5425.223086 |   6456.538118 |    3863.7424 |
|   10000 |  20772.332491 |  25550.757304 | 13519.209814 |
|  100000 |  53577.240193 |  66746.041644 | 33520.676384 |
| 1000000 | 121986.712395 | 148505.580638 | 73005.539932 |
:end:

#+begin_src gnuplot :var data=1-22-smdff-massage :file 1/fig/1-22-3.png :exports results :noeval :rownames no :colnames no :hlines no :cache no
reset
set key autotitle columnheader
set logscale x
set xlabel 'minimum number'
set xtics rotate by -45
set ylabel 'time'
set title 'time to run prime search (x scaled log)'

plot data using 2:xticlabels(1) with linespoints, \
     data using 3:xticlabels(1) with linespoints, \
     data using 4:xticlabels(1) with linespoints
#+end_src

#+RESULTS:
:results:
[[file:1/fig/1-22-3.png]]
:end:

I had a lot of trouble getting this one to compile, I have to restart Emacs in
order to get it to render.

Anyways, there's the speedup that was expected. Let's compare the ratios.

Defining a new average that takes arbitrary numbers of arguments:
#+NAME: average-varargs
#+BEGIN_SRC scheme :eval no-export :results silent output :var smd=1-22-smd smdf=1-22-smdf smdff=1-22-smdff :exports code :rownames no :colnames no
(define (average . args)
  (let ((len (length args)))
    (/ (apply + args) len)))
#+END_SRC

Using it for percentage comparisons:
#+BEGIN_SRC scheme :eval no-export :results value table :var smd=1-22-smd smdf=1-22-smdf smdff=1-22-smdff :exports both :rownames no :colnames no
<<average-varargs>>
(list (cons "% speedup for broken (next)"
            (cons (format #f "~2$%"
                          (apply average
                                 (map (λ (x y) (* 100 (/ x y)))
                                      (car smd) (car smdf))))
                  #nil))
      (cons "% speedup for real (next)"
            (cons (format #f "~2$%"
                          (apply average
                                 (map (λ (x y) (* 100 (/ x y)))
                                      (car smd) (car smdff))))
                  #nil)))
#+END_SRC

#+RESULTS[6c5b471c24bb1e0fa43ce89ab354a29586b8dc54]:
:results:
| % speedup for broken (next) |  81.93% |
| % speedup for real (next)   | 155.25% |
:end:

Since this changed algorithm cuts out almost half of the steps, you might expect
something more like a 200% speedup. Let's try optimizing it further. Two observations:

1. The condition src_scheme{(divides? 2 n)} only needs to be run once at the
   start of the program.
2. Because it only needs to be run once, it doesn't need to be a separate
   function at all.

#+NAME: find-divisor-faster-real2
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
<<square>>
(define (smallest-divisor n)
  (if (divides? 2 n)                  ;; check for division by 2
      2
      (find-divisor n 3)))            ;; start find-divisor at 3

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) 
         n)
        ((divides? test-divisor n) 
         test-divisor)
        (else (find-divisor 
               n 
               (+ 2 test-divisor))))) ;; just increase by 2

(define (divides? a b)
  (= (remainder b a) 0))
#+END_SRC
#+NAME: smallest-divisor-benchmark-real2
#+BEGIN_SRC scheme -n :noeval :tangle 1/primebench/smdff2.scheme :exports code
<<mattbench2>>
<<find-divisor-faster-real2>>
(define (prime? n)
  (= n (smallest-divisor n)))
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 500000)
(define (testit f)
  (list (cadr (mattbench2 (λ() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
#+END_SRC


#+NAME: 1-22-smdff2
| 3151.259574 | 11245.20428 | 27803.067944 | 61997.275154 |

#+NAME: 1-22-smdff2-massage
#+BEGIN_SRC scheme :eval no-export :results value table :var smd=1-22-smd smdf=1-22-smdf smdff=1-22-smdff smdff2=1-22-smdff2 :exports results :rownames no :colnames no
<<print-table-spaced>>
(use-srfis '(1))
(zip '("min" "---" 1000 10000 100000 1000000)
     (append '("(+1)" "---") (car smd))
     (append '("(next-broken)" "---") (car smdf))
     (append '("(next-fixed)" "---") (car smdff))
     (append '("integrated" "---") (car smdff2)))
#+END_SRC

#+RESULTS[39aed0154d20c6f0dee74c868a7613701ebb1dea]: 1-22-smdff2-massage
:results:
|     min |          (+1) | (next-broken) | (next-fixed) |   integrated |
|     --- |           --- |           --- |          --- |          --- |
|    1000 |   5425.223086 |   6456.538118 |    3863.7424 |  3151.259574 |
|   10000 |  20772.332491 |  25550.757304 | 13519.209814 |  11245.20428 |
|  100000 |  53577.240193 |  66746.041644 | 33520.676384 | 27803.067944 |
| 1000000 | 121986.712395 | 148505.580638 | 73005.539932 | 61997.275154 |
:end:

#+begin_src gnuplot :var data=1-22-smdff2-massage :file 1/fig/1-22-4.png :exports results :rownames no :colnames no :hlines no :cache no
reset
set key autotitle columnheader
set logscale x
set xlabel 'minimum number'
set xtics rotate by -45
set ylabel 'time'
set title 'time to run prime search (x scaled log)'

plot data using 2:xticlabels(1) with linespoints, \
     data using 3:xticlabels(1) with linespoints, \
     data using 4:xticlabels(1) with linespoints, \
     data using 5:xticlabels(1) with linespoints
#+end_src

#+RESULTS:
:results:
file:1/fig/1-22-4.png
:end:

#+BEGIN_SRC scheme :eval no-export :results value table :var smd=1-22-smd smdf=1-22-smdf smdff=1-22-smdff smdff2=1-22-smdff2 :exports results :rownames no :colnames no
<<average-varargs>>
(define (print-percentage name lista listb)
  (list (format #f "% speedup for ~a" name)
        (format #f "~2$%"
                (apply average
                       (map (λ (x y) (* 100 (/ x y)))
                            lista listb)))))
(list (print-percentage "broken (next)" (car smd) (car smdf))
      (print-percentage "real (next)" (car smd) (car smdff))
      (print-percentage "optimized" (car smd) (car smdff2)))
#+END_SRC

#+RESULTS[2a8c88e516dcf2998063353d1be32f3b9838c7de]:
:results:
| % speedup for broken (next) |  81.93% |
| % speedup for real (next)   | 155.25% |
| % speedup for optimized     | 186.59% |
:end:

** Exercise 1.24

*** Text

#+NAME: expmod
#+BEGIN_SRC scheme :eval no-export :results output silent :exports code
<<square>>
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder 
          (square (expmod base (/ exp 2) m))
          m))
        (else
         (remainder 
          (* base (expmod base (- exp 1) m))
          m))))
#+END_SRC
#+NAME: fermat-test
#+BEGIN_SRC scheme :eval no-export :results output silent :exports code
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))
#+END_SRC
#+NAME: fast-prime
#+BEGIN_SRC scheme :eval no-export :results output silent :exports code
(define (fast-prime? n times)
  (cond ((= times 0) #t)
        ((fermat-test n) 
         (fast-prime? n (- times 1)))
        (else #f)))
#+END_SRC

*** Question

#+begin_quote
Modify the ~timed-prime-test~ procedure of [[Exercise 1.22]] to use ~fast-prime?~ (the
Fermat method), and test each of the 12 primes you found in that exercise. Since
the Fermat test has \(\Theta(\text{log}n)\) growth, how would you expect the
time to test primes near 1,000,000 to compare with the time needed to test
primes near 1000? Do your data bear this out? Can you explain any discrepancy
you find?
#+end_quote

*** Answer

#+NAME: fermat-bench
#+BEGIN_SRC scheme -n :noeval :tangle 1/primebench/fermat.scheme :exports code
<<mattbench2>>
<<expmod>>
<<fermat-test>>
<<fast-prime>>
(define fermat-iterations 2)
(define (prime? n)
  (fast-prime? n fermat-iterations))
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 500000)
(define (testit f)
  (list (cadr (mattbench2 (λ() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
#+END_SRC

#+NAME: 1-24-fermat
| 11175.799722 | 23518.62116 | 32150.745642 | 32679.766448 |

#+NAME: 1-24-massage
#+BEGIN_SRC scheme :eval no-export :results value table :var smd=1-22-smd smdff2=1-22-smdff2 fermat=1-24-fermat :exports results :rownames no :colnames no
<<print-table-spaced>>
(use-srfis '(1))
(zip '("min" "---" 1000 10000 100000 1000000)
     (append '("(+1)" "---") (car smd))
     (append '("integrated" "---") (car smdff2))
     (append '("fermat (2 guesses)" "---") (car fermat)))
#+END_SRC

#+RESULTS[c9241299552f4a1e84ecbb973fb1d1f9cca04fca]: 1-24-massage
:results:
|     min |          (+1) |   integrated | fermat (2 guesses) |
|     --- |           --- |          --- |                --- |
|    1000 |   5425.223086 |  3151.259574 |       11175.799722 |
|   10000 |  20772.332491 |  11245.20428 |        23518.62116 |
|  100000 |  53577.240193 | 27803.067944 |       32150.745642 |
| 1000000 | 121986.712395 | 61997.275154 |       32679.766448 |
:end:

#+begin_src gnuplot :var data=1-24-massage :file 1/fig/1-24-1.png :exports results :rownames no :colnames no :hlines no :cache no
reset
set key autotitle columnheader
set logscale x
set xlabel 'minimum number'
set xtics rotate by -45
set ylabel 'time'
set title 'time to run prime search (x scaled log)'

plot data using 2:xticlabels(1) with linespoints, \
     data using 3:xticlabels(1) with linespoints, \
     data using 4:xticlabels(1) with linespoints, \
     data using 5:xticlabels(1) with linespoints
#+end_src

#+RESULTS:
:results:
file:1/fig/1-24-1.png
:end:

It definitely looks to be advancing much slower than the other methods. I'd like
to see more of the function.

#+NAME: smallest-divisor-benchmark-real3
#+BEGIN_SRC scheme -n :noeval :tangle 1/primebench/more.scheme :exports code
<<mattbench2>>
<<find-divisor-faster-real>>
(define (prime? n)
  (= n (smallest-divisor n)))
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 100000)
(define (testit f)
  (list (cadr (mattbench2 (λ() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
#+END_SRC

#+NAME: fermat-bench2
#+BEGIN_SRC scheme -n :noeval :tangle 1/primebench/more.scheme :exports code
<<mattbench2>>
<<expmod>>
<<fermat-test>>
<<fast-prime>>
(define fermat-iterations 100)
(define (prime? n)
  (fast-prime? n fermat-iterations))
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 100000)
(define (testit f)
  (list (cadr (mattbench2 (λ() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
#+END_SRC

#+NAME: 1-24-massage2
#+BEGIN_SRC scheme :eval no-export :results value table :exports none :rownames no :colnames no :session scheme

(let ((table '((3802.45146 13397.91871 32948.31241 73237.64777 299326.76182 678512.75719 2064911.33345 7065717.58395 20198370.27007 60956807.83034) (237945.8945 319761.90842 391573.47557 448501.96232 614009.08547 661205.34772 700058.30723 2852221.29076 3717690.96246 3995948.05596))))
(use-srfis '(1))
(zip '("min" 1000 10000 100000 1000000 10000000 100000000 1000000000 10000000000 100000000000 1000000000000)
     (append '("integrated") (car table))
     (append '("fermat (100 guesses)") (cadr table))))
#+END_SRC

#+RESULTS[1cd094d12aae7b8d5baef1f5e2c9261f806cffc4]: 1-24-massage2
#+begin_EXAMPLE
|           min |     integrated | fermat (100 guesses) |
|          1000 |     3802.45146 |          237945.8945 |
|         10000 |    13397.91871 |         319761.90842 |
|        100000 |    32948.31241 |         391573.47557 |
|       1000000 |    73237.64777 |         448501.96232 |
|      10000000 |   299326.76182 |         614009.08547 |
|     100000000 |   678512.75719 |         661205.34772 |
|    1000000000 |  2064911.33345 |         700058.30723 |
|   10000000000 |  7065717.58395 |        2852221.29076 |
|  100000000000 | 20198370.27007 |        3717690.96246 |
| 1000000000000 | 60956807.83034 |        3995948.05596 |
#+end_EXAMPLE

#+begin_src gnuplot :var data=1-24-massage2 :file 1/fig/1-24-2.png :exports results :rownames no :colnames no :hlines no :cache no :eval no-export
reset
set key autotitle columnheader
set logscale xy
set xlabel 'minimum number'
set xtics rotate by -45
set ylabel 'time'
set title 'time to run prime search (x\&y scaled log)'

plot data using 2:xticlabels(1) with linespoints, \
     data using 3:xticlabels(1) with linespoints
#+end_src

#+RESULTS:
:results:
file:1/fig/1-24-2.png
:end:

For the life of me I have no idea what that bump is. Maybe it needs more
aggressive bignum processing there?

** Exercise 1.25

*** Question

#+begin_quote
Alyssa P. Hacker complains that we went to a lot of extra work in writing
~expmod~. After all, she says, since we already know how to compute
exponentials, we could have simply written
#+end_quote

#+BEGIN_SRC scheme -n 
(define (expmod base exp m)
  (remainder (fast-expt base exp) m))
#+END_SRC

#+begin_quote
Is she correct? Would this procedure serve as well for our fast prime tester?
Explain.
#+end_quote

*** Answer

In Alyssa's version of ~expmod~, the result of the ~fast-expt~ operation is
/extremely/ large. For example, in the process of checking for divisors of
1,001, the number 455 will be tried. src_scheme{(expt 455 1001)} produces an
integer 2,661 digits long. This is just one of the thousands of exponentiations
that ~smallest-divisor~ will perform. It's best to avoid this, so we use to our
advantage the fact that we only need to know the remainder of the
exponentiations. ~expmod~ breaks down the exponentiation into smaller steps and
performs ~remainder~ after every step, significantly reducing the memory
requirements.

As an example, let's trace (some of) the execution of src_scheme{(expmod 455 1001 1001)}:

#+BEGIN_SRC scheme
(expmod 455 1001 1001)
>  (even? 1001)
>  #f
>  (expmod 455 1000 1001)
>  >  (even? 1000)
>  >  #t
>  >  (expmod 455 500 1001)
>  >  >  (even? 500)
>  >  >  #t
;; ...
>  >  >  x11 (expmod 455 2 1001)
>  >  >  x11 >  (even? 2)
>  >  >  x11 >  #t
>  >  >  x11 >  (expmod 455 1 1001)
>  >  >  x11 >  >  (even? 1)
>  >  >  x11 >  >  #f
>  >  >  x11 >  >  (expmod 455 0 1001)
>  >  >  x11 >  >  1
>  >  >  x11 >  455
>  >  >  x11 >  (square 455)
>  >  >  x11 >  207025
>  >  >  x11 819
;; ...
>  >  >  (square 364)
>  >  >  132496
>  >  364
>  >  (square 364)
>  >  132496
>  364
455
#+END_SRC

You can see that the numbers remain quite manageable throughout this process. So
taking these extra steps actually leads to an algorithm that performs better.

** Exercise 1.26

*** Question

#+begin_quote
Louis Reasoner is having great difficulty doing Exercise 1.24. His ~fast-prime?~
test seems to run more slowly than his ~prime?~ test. Louis calls his friend Eva
Lu Ator over to help. When they examine Louis's code, they find that he has
rewritten the ~expmod~ procedure to use an explicit multiplication, rather than
calling ~square~:
#+end_quote

#+begin_src scheme -n
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder 
          (* (expmod base (/ exp 2) m) ;; <== hmm.
             (expmod base (/ exp 2) m))
          m))
        (else
         (remainder 
          (* base 
             (expmod base (- exp 1) m))
          m))))
#+end_src

#+begin_quote
"I don't see what difference that could make," says Louis. "I do." says Eva. "By
writing the procedure like that, you have transformed the \(\Theta(\log n)\)
process into a \(\Theta(n)\) process." Explain.
#+end_quote

*** Answer

Making the same function call twice isn't the same as using a variable twice --
Louis' version doubles the work, having two processes solving the exact same
problem. Since the number of processes used increases exponentially, this turns
\(\log n\) into \(n\).

** Exercise 1.27

*** Question

#+begin_quote
Demonstrate that the Carmichael numbers listed in Footnote 1.47 really do fool
the Fermat test. That is, write a procedure that takes an integer \(n\) and
tests whether \(a^n\) is congruent to \(a\) modulo \(n\) for every \(a < n\),
and try your procedure on the given Carmichael numbers.
#+end_quote
#+NAME: carmichael
| 561 | 1105 | 1729 | 2465 | 2821 | 6601 |

*** Answer

#+NAME: car-test
#+begin_src scheme -n :results silent :exports code :eval no-export
<<expmod>>
(define (car-test n)
  (define (check a)
    (= (remainder (expt a n) n)
       (remainder (modulo a n) n)))
  (every check
           (cddr (iota n))))
#+end_src

#+NAME: car-test-check
#+BEGIN_SRC scheme noeval :exports code :eval no-export
<<car-test>>
(list (car-test 12) ; <== false (not prime)
      (car-test 1009);<== true  (real prime)
      (car-test 561));<== true  (not prime,
                     ;      Carmichael number)
#+END_SRC

** Exercise 1.28

*** Question

#+begin_quote
One variant of the Fermat test that cannot be fooled is called the Miller-Rabin
test (Miller 1976; Rabin 1980). This starts from an alternate form of Fermat's
Little Theorem, which states that if \( n \) is a prime number and \( a \) is
any positive integer less than \( n \), then \( a \) raised to the \( (n-1) \)
-st power is congruent to 1 modulo \( n \). To test the primality of a number \(
n \) by the Miller-Rabin test, we pick a random number \( a<n \) and raise \( a
\) to the \( (n-1) \) -st power modulo \( n \) using the ~expmod~ procedure.
However, whenever we perform the squaring step in ~expmod~, we check to see if
we have discovered a "nontrivial square root of 1 modulo \( n \)," that is, a
number not equal to 1 or \( n-1 \) whose square is equal to 1 modulo \( n \). It
is possible to prove that if such a nontrivial square root of 1 exists, then \(
n \) is not prime. It is also possible to prove that if \( n \) is an odd number
that is not prime, then, for at least half the numbers \( a<n \), computing \(
an-1 \) in this way will reveal a nontrivial square root of 1 modulo \( n \).
(This is why the Miller-Rabin test cannot be fooled.) Modify the ~expmod~
procedure to signal if it discovers a nontrivial square root of 1, and use this
to implement the Miller-Rabin test with a procedure analogous to fermat-test.
Check your procedure by testing various known primes and non-primes. Hint: One
convenient way to make ~expmod~ signal is to have it return 0.
#+end_quote

*** Analysis

For the sake of verifying this, I want to get a bigger list of primes and
Carmichael numbers to verify against. I'll save them using Guile's built in
read/write functions that save Lisp lists to text:
#+NAME: findsomeprimes
#+BEGIN_SRC scheme :eval no-export :results output :exports code :tangle 1/Ex28/findsomeprimes.scheme
<<find-divisor-faster-real>>
(define (prime? n)
  (= n (smallest-divisor n)))
(call-with-output-file "Data/primes-1k_to_1mil.txt" (λ(port)
  (write (filter prime? (iota (- 1000000 1000) 1000))
         port)))
#+END_SRC

#+NAME: fermat-prime?
#+BEGIN_SRC scheme :eval no-export :results output silent :exports code
;; fermat prime test but checks *every* value from 2 to n-1
(define (fermat-prime? n)
  (define (iter a)
    (if (= a n)
        #f
        (if (= (expmod a n n) a)
            #t
            (iter (+ 1 a)))))
  (iter 2))
#+END_SRC

#+NAME: findcars
#+BEGIN_SRC scheme :eval no-export :results output silent :exports code :tangle 1/Ex28/findcars.scheme
(use-srfis '(1))
<<expmod>>
<<fermat-prime?>>
<<find-divisor-faster-real>>
(define (prime? n)
  (= n (smallest-divisor n)))
(call-with-output-file "Data/carmichael-verification.txt" (λ(port)
     (write (filter
             (λ(x) (and (fermat-prime? x)
                        (not (prime? x))))
             (iota (- 1000000 1000) 1000))
            port)))
#+END_SRC

This will be useful in various future functions:
#+NAME: get-lists-of-primes
#+BEGIN_SRC scheme :eval no-export :results output silent :exports code :cache no
(define list-of-primes (call-with-input-file "Data/primes-1k_to_1mil.txt" read))
(define list-of-carmichaels (call-with-input-file "Data/carmichael.txt" read))
#+END_SRC

#+BEGIN_SRC scheme :eval no-export :results output :exports both :cache no
(use-srfis '(1))
<<expmod>>
<<fermat-prime?>>
<<find-divisor-faster-real>>
(define (prime? n)
  (= n (smallest-divisor n)))
<<get-lists-of-primes>>
(define prime-is-working
  (and (and-map prime? list-of-primes)
       (not (and-map prime? list-of-carmichaels))))
(format #t "(prime?) is working: ~a~%"
        (if prime-is-working
            "Yes"
            "No"))
(define fermat-is-vulnerable
  (and (and-map fermat-prime? list-of-primes)
       (and-map fermat-prime? list-of-carmichaels)))
(format #t "(fermat-prime?) is vulnerable: ~a~%"
        (if fermat-is-vulnerable
            "Yes"
            "No"))
#+END_SRC

#+RESULTS:
:results:
#+begin_example
(prime?) is working: Yes
(fermat-prime?) is vulnerable: Yes
#+end_example
:end:

*** Answer

#+NAME: expmod-mr
#+BEGIN_SRC scheme -n :eval no-export :results output silent :exports code
<<square>>
(define (expmod-mr base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (let ((sqr
                (square (expmod-mr base (/ exp 2) m))))
           (if (= 1 (modulo sqr m))
               0
               (remainder sqr m))))
        (else
         (remainder 
          (* base (expmod-mr base (- exp 1) m))
          m))))
#+END_SRC
#+NAME: mr-test
#+BEGIN_SRC scheme :eval no-export :results output silent :exports code
(define (mr-test n)
  (define (try-it a)
    (let ((it (expmod-mr a n n)))
      (or (= it a)
          (= it 0))))
  (try-it (+ 1 (random (- n 1)))))
#+END_SRC
#+NAME: mr-prime
#+BEGIN_SRC scheme :eval no-export :results output silent :exports code
(define (mr-prime? n times)
  (cond ((= times 0) #t)
        ((mr-test n) 
         (mr-prime? n (- times 1)))
        (else #f)))
#+END_SRC

#+NAME: mr-verification
#+BEGIN_SRC scheme :eval no-export :results value :exports both :tangle 1/Ex28/mr_check.scheme
<<expmod-mr>>
<<mr-test>>
<<mr-prime>>
(define mr-times 100)
<<get-lists-of-primes>>
(format #t "      mr detects primes: ~a~%mr false-positives Carmichaels: ~a~%"
        (and-map (λ(x)(mr-prime? x mr-times)) list-of-primes)
      (and-map (λ(x)(mr-prime? x mr-times)) list-of-carmichaels))
#+END_SRC

#+RESULTS[949daa71bbf35095f8025130b9fb179b5308e7fa]: mr-verification
#+BEGIN_SRC 
      mr detects primes: #t
mr false-positives Carmichaels: #t
#+END_SRC

Shoot. And I thought I did a very literal interpretation of what the book asked.

Ah, I see the problem. I need to keep track of what the pre-squaring number was
and use that to determine whether the square is valid or not.

#+NAME: expmod-mr2
#+BEGIN_SRC scheme -n :eval no-export :results output silent :exports code
<<square>>
(define (expmod-mr base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         ;; Keep result and remainder seperate
         (let* ((result (expmod-mr base (/ exp 2) m))
                (rem (remainder (square result) m)))
           (if (and (not (= result 1))
                    (not (= result (- m 1)))
                    (= 1 rem))
               0 ;; non-trivial sqrt mod 1 is found
               rem)))
        (else
         (remainder 
          (* base (expmod-mr base (- exp 1) m))
          m))))
#+END_SRC
#+NAME: mr-verification2
#+BEGIN_SRC scheme :noeval :exports none :tangle 1/Ex28/mr_check2.scheme
<<expmod-mr2>>
<<mr-test>>
<<mr-prime>>
(define mr-times 100)
<<get-lists-of-primes>>
(format #t "      mr detects primes: ~a~%mr false-positives Carmichaels: ~a~%"
        (and-map (λ(x)(mr-prime? x mr-times)) list-of-primes)
      (and-map (λ(x)(mr-prime? x mr-times)) list-of-carmichaels))
#+END_SRC

Unfortunately this one has the same problem. What's the issue?

Sadly, there's a massive issue in ~mr-test~.
#+BEGIN_SRC scheme +n :eval no-export :results output silent :exports code
(define (mr-test n)
  (define (try-it a)
    (let ((it (expmod-mr a n n))) ;; Should be "a (- n 1) n"
      (or (= it a)    ;; Should be (= it 1)
          (= it 0)))) ;; Two strikes, you're out
  (try-it (+ 1 (random (- n 1)))))
#+END_SRC

One more time.
#+NAME: mr-test2
#+BEGIN_SRC scheme +n :eval no-export :results output silent :exports code
(define (mr-test n)
  (define (try-it a)
    (= 1 (expmod-mr a (- n 1) n)))
  (try-it (+ 1 (random (- n 1)))))
#+END_SRC

#+NAME: mr-verification2
#+BEGIN_SRC scheme -n :exports both :results output raw :tangle 1/Ex28/mr_check3.scheme
<<expmod-mr2>>
<<mr-test2>>
<<mr-prime>>
(define mr-times 100)
<<get-lists-of-primes>>
(format #t "      mr detects primes: ~a~%mr false-positives Carmichaels: ~a~%"
        (and-map (λ(x)(mr-prime? x mr-times)) list-of-primes)
      (and-map (λ(x)(mr-prime? x mr-times)) list-of-carmichaels))
#+END_SRC

#+BEGIN_SRC
     mr detects primes: #t
mr false-positives Carmichaels: #f
#+END_SRC

** 1.3: Formulating Abstractions with Higher-Order Procedures

Procedures that manipulate procedures are called /higher-order procedures/.

** 1.3.1: Procedures as Arguments

Let's say we have several different types of series that we want to sum.
Functions for each of these tasks will look very similar, so we're better off
defining a general function that expresses the /idea/ of summation, that can
then be passed specific functions to cause the specific behavior of the series.
Mathematicians express this as \(\sum\) ("sigma") notation.

For the program:

#+begin_src scheme
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
#+end_src

Which is equivalent to:

\[\sum^{b}_{n~a}term(n)~term(a)+term(next(a))+term(next(next(a)))+\cdots+term(b)\]

We can pass integers to ~a~ and ~b~ and functions to ~term~ and ~next~. Note
that in order to simply sum integers, we'd need to define and pass an identity
function to ~term~.

** Exercise 1.29

*** Text
#+NAME: sum
#+BEGIN_SRC scheme -n :eval no-export :results output silent :exports code
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
#+END_SRC
#+NAME: integral
#+BEGIN_SRC scheme -n :eval no-export :results output silent :exports code
(define (integral f a b dx)
  (define (add-dx x)
    (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b)
     dx))
#+END_SRC

*** Question

#+begin_quote
Simpson's Rule is a more accurate method of numerical integration than the
method illustrated above. Using Simpson's Rule, the integral of a function \(f\)
between \(a\) and \(b\) is approximated as

\[
{h\over 3}(y_0 + 4y_1 + 2y_2 + 4y_3 + 2y_4 + \dots + 2y_{n-2} + 4y_{n-1} + y_n)
\]

where \(h = (b - a) / n\), for some even integer \(n\), and \(y_k = f(a + kh)\).
(Increasing \(n\) increases the accuracy of the approximation.) Define a
procedure that takes as arguments \(f\), \(a\), \(b\), and \(n\) and returns the
value of the integral, computed using Simpson's Rule. Use your procedure to
integrate ~cube~ between 0 and 1 (with \(n = 100\) and \(n = 1000\)), and
compare the results to those of the ~integral~ procedure shown above.
#+end_quote

*** Answer

#+NAME: int-simp
#+BEGIN_SRC scheme -n :eval no-export :results output silent :exports code
(define (int-simp f a b n)
  (define h
    (/ (- b a)
     n))
  (define (gety k)
    (f (+ a (* k h))))
  (define (series-y sum k) ;; start with sum = y_0
    (cond ((= k n) (+ sum (gety k)));; and k = 1
          ((even? k) (series-y
                      (+ sum (* 2 (gety k)))
                      (+ 1 k)))
          (else (series-y
                 (+ sum (* 4 (gety k)))
                 (+ 1 k)))))
  (define sum-of-series (series-y (gety a) 1)) ;; (f a) = y_0
  (* (/ h 3) sum-of-series))
#+END_SRC

Let's compare these at equal levels of computational difficulty.
#+BEGIN_SRC scheme -n :noeval :exports both :results output table :tangle 1/Ex29-bench.scheme
<<mattbench2>>
<<print-table>>
(define (cube x)
  (* x x x))
<<sum>>
<<integral>>
<<int-simp>>

(define iterations 100000) ;; benchmark iterations
(define (run-test1)
  (integral cube 0.0 1.0 0.0008))
(define (run-test2)
  (int-simp cube 0.0 1.0 1000.0))
(print-table (list (list "integral dx:0.0008" "int-simp i:1000")
                   (list (run-test1) (run-test2))
                   (list (cadr (mattbench2 run-test1 iterations))
                         (cadr (mattbench2 run-test2 iterations))))
             #:colnames #t)
#+END_SRC

#+RESULTS[f1ab42d01728399d2e9c3b9f8c996a3766a58da4]:
:results:
|  integral dx:0.0008 |     int-simp i:1000 |
|---------------------+---------------------|
| 0.24999992000001311 | 0.25000000000000006 |
|         321816.2755 |         330405.8918 |
:end:

So, more accurate for roughly the same effort or less.

** Exercise 1.30

*** Question

#+begin_quote
The ~sum~ procedure above generates a linear recursion. The procedure can be
rewritten so that the sum is performed iteratively. Show how to do this by
filling in the missing expressions in the following definition:
#+end_quote

*** Answer

#+NAME: sum-iter
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (sum-iter term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ result (term a)))))
  (iter a 0))
#+END_SRC

Let's check the stats!
#+NAME: sum-bench
#+BEGIN_SRC scheme -n :noeval :exports results :results output :tangle 1/Ex30-bench.scheme
<<print-table>>
<<mattbench2>>
<<sum>>
<<sum-iter>>
(define iterations 1000000)
(define (test1)
  (sum + 1 1+ 1000))
(define (test2)
  (sum-iter + 1 1+ 1000))
(print-table (list
              (list "recursive" "iterative")
              (list (cadr (mattbench2 test1 iterations))
                   (cadr (mattbench2 test2 iterations))))
             #:colnames #t)
#+END_SRC

#+RESULTS:
|    recursive |    iterative |
|--------------+--------------|
| 30051.080005 | 19568.685587 |

** Exercise 1.31

*** Question A.1

#+begin_quote
The ~sum~ procedure is only the simplest of a vast number of similar
abstractions that can be captured as higher-order procedures. Write an analogous
procedure called ~product~ that returns the product of the values of a function
at points over a given range.
#+end_quote

*** Answer A.1

#+NAME: product-iter
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (product-iter term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (* result (term a)))))
  (iter a 1)) ;; start at 1 so it's not always 0
#+END_SRC

*** Question A.2

#+begin_quote
Show how to define ~factorial~ in terms of ~product~.
#+end_quote

*** Answer A.2

I was briefly stumped because ~product~ only counts upward. Then I realized
that's just how it's presented and it can go either direction, since addition
and multiplication are commutative. I look forward to building up a more
intuitive sense of numbers.
#+NAME: factorial-product
#+BEGIN_SRC scheme -n :eval no-export :exports both :results output
<<product-iter>>
(define (identity x)
  x)
(define (inc x)
  (1+ x))

(define (factorial n)
  (product-iter identity 1 inc n))

(display (factorial 7))
#+END_SRC

#+RESULTS[62b530c1156728394dbfd7f2df3aa06defdbe68c]: product-iter
:results:
#+begin_example
5040
#+end_example
:end:

*** Question A.3

#+begin_quote
Also use ~product~ to compute approximations to \(\pi\) using the formula

\[
{\pi\over 4} = {2\cdot 4\cdot 4\cdot 6\cdot 6\cdot 8\cdots\over
		   3\cdot 3\cdot 5\cdot 5\cdot 7\cdot 7\cdots}
\]
#+end_quote

*** Answer A.3

Once this equation is encoded, you just need to multiply it by two to get \(\pi\).

Fun fact: the formula is slightly wrong, it should start the series with \({1 \over 2}\).
#+NAME: pi-product
#+BEGIN_SRC scheme -n :eval no-export :exports both :results output
<<product-iter>>
(define (pi-product n)
  (define (div x)
    (let ((x1 (- x 1))
          (x2 (+ x 1)))
      (* (/ x x1) (/ x x2))))
  (* 2.0 (product-iter div 2 (lambda (z) (+ z 2)) n)))

(display (pi-product 100000))
#+END_SRC

#+RESULTS[ec9a51379631fed566dd2d3883f600356c3f0dd8]: pi-product
:results:
#+begin_example
3.1415769458228726
#+end_example
:end:

*** Question B

#+begin_quote
If your product procedure generates a recursive process, write one that
generates an iterative process. If it generates an iterative process, write one
that generates a recursive process.
#+end_quote

*** Answer B

#+NAME: product-rec
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (product-rec term a next b)
  (if (> a b)
      1
      (* (term a)
         (product-rec term (next a) next b))))
#+END_SRC

#+NAME: product-bench
#+BEGIN_SRC scheme -n :exports both :tangle 1/Ex31-bench.scheme
<<mattbench2>>
<<print-table>>
<<product-iter>>
(define (pi-product n)
  (define (div x)
    (let ((x1 (- x 1))
          (x2 (+ x 1)))
      (* (/ x x1) (/ x x2))))
  (* 2.0 (product-iter div 2 (lambda (z) (+ z 2)) n)))
<<product-rec>>
(define (pi-product-rec n)
  (define (div x)
    (let ((x1 (- x 1))
          (x2 (+ x 1)))
      (* (/ x x1) (/ x x2))))
  (* 2.0 (product-rec div 2 (lambda (z) (+ z 2)) n)))

(define iterations 50000)
(print-table
 (list (list "iterative" "recursive")
       (list (cadr (mattbench2 (λ()(pi-product 1000)) iterations))
             (cadr (mattbench2 (λ()(pi-product-rec 1000)) iterations))))
 #:colnames #t)
#+END_SRC

#+RESULTS:
|    iterative |    recursive |
|--------------+--------------|
| 1267118.0538 | 3067085.5323 |

** Exercise 1.32

*** Question A

#+begin_quote
Show that ~sum~ and ~product~ are both special cases of a still more general
notion called ~accumulate~ that combines a collection of terms, using some
general accumulation function:
#+end_quote

#+BEGIN_SRC scheme
(accumulate combiner null-value term a next b)
#+END_SRC

#+begin_quote
~accumulate~ takes as arguments the same term and range specifications as ~sum~
and ~product~, together with a ~combiner~ procedure (of two arguments) that
specifies how the current term is to be combined with the accumulation of the
preceding terms and a ~null-value~ that specifies what base value to use when
the terms run out. Write ~accumulate~ and show how ~sum~ and ~product~ can both
be defined as simple calls to ~accumulate~.
#+end_quote

*** Answer A

When I first did this question, I struggled a lot before realizing ~accumulate~
was much closer to the exact definitions of sum/product than I thought.
#+NAME: accumulate-iter
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (accumulate-iter combiner null-value term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a)
              (combiner result (term a)))))
  (iter a null-value))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export
<<accumulate-iter>>

;; here you can see definitions in terms of accumulate
(define (sum term a next b)
  (accumulate-iter + 0 term a next b))
(define (product term a next b)
  (accumulate-iter * 1 term a next b))

(define (identity x)
  x)
(define (inc x)
  (1+ x))

;; accumulate in action
(define (factorial n)
  (accumulate-iter * 1 identity 1 inc n))

(display (factorial 7))
#+END_SRC

#+RESULTS[4887ddb9da2fc846473c03144fb7dfe4f69aa8f1]:
:results:
#+begin_example
5040
#+end_example
:end:

*** Question B

#+begin_quote
If your ~accumulate~ procedure generates a recursive process, write one
that generates an iterative process.  If it generates an iterative process,
write one that generates a recursive process.
#+end_quote

*** Answer B

#+NAME: accumulate-rec
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (accumulate-rec combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a)
         (accumulate-rec combiner null-value
                         term (next a) next b))))
#+END_SRC

** Exercise 1.33

*** Question A

#+INDEX: filter
#+begin_quote
You can obtain an even more general version of ~accumulate~ by introducing the
notion of a filter on the terms to be combined. That is, combine only those
terms derived from values in the range that satisfy a specified condition. The
resulting ~filtered-accumulate~ abstraction takes the same arguments as
accumulate, together with an additional predicate of one argument that specifies
the filter. Write ~filtered-accumulate~ as a procedure. 
#+end_quote

*** Answer A

#+NAME: filtered-accumulate-iter
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (filtered-accumulate-iter
           predicate? combiner null-value
           term a next b)
  (define (iter a result)
    (cond ((> a b) result)
          ((predicate? a)
           (iter (next a)
                 (combiner result (term a))))
          (else (iter (next a)
                      result))))
  (iter a null-value))
#+END_SRC

*** Question B

Show how to express the following using ~filtered-accumulate~:

**** A

Find the sum of the squares of the prime numbers in the interval \(a\) to \(b\)
(assuming that you have a ~prime?~ predicate already written)

#+BEGIN_SRC scheme -n :eval no-export :results output :results both
(load "mattcheck.scm")
(define (square x)
  (* x x))
<<filtered-accumulate-iter>>
<<expmod-mr2>>
<<mr-test2>>
<<mr-prime>>
(define mr-times 100)
(define (prime? x)
  (mr-prime? x mr-times))
(define (prime-sum a b)
  (filtered-accumulate-iter prime? + 0
                            square a 1+ b))

(mattcheck-equal "1 prime correct"
                 (prime-sum 1008 1010)
                 (square 1009)) ;; 1009
(mattcheck-equal "many primes correct"
                 (prime-sum 1000 2001)
                 (apply +
                        (map square
                             (filter prime? (iota (- 2001 1000)
                                                  1000)))))
#+END_SRC

#+RESULTS[9d2efd935ed9abfe7480e0fd9117c25f7db9eb02]:
:results:
#+begin_example
SUCCEED at 1 prime correct
SUCCEED at many primes correct
#+end_example
:end:

**** B

#+begin_quote
Find the product of all the positive integers less than \(n\) that are
relatively prime to \(n\) (i.e., all positive integers \(i < n\) such that
\(\textsc{gcd}(i, n) = 1\).
#+end_quote

#+BEGIN_SRC scheme -n :eval no-export :results output :results both
(load "mattcheck.scm")
(define (square x)
  (* x x))
(define (id x) x)
<<filtered-accumulate-iter>>
<<gcd>>
(define (relative-prime? x y)
  (= 1 (gcd x y)))

(define (Ex_1-33B n)
  (filtered-accumulate-iter
   (λ(i) (relative-prime? i n))
   ,* 1 id
   1 1+ (1- n)))

(define (alternate n)
  (apply *
         (filter (λ(i) (relative-prime? i n))
                 (iota (- n 1) 1))))

(mattcheck-equal "Ex_1-33B"
                 (Ex_1-33B 100)
                 (alternate 100))
#+END_SRC

#+RESULTS[55bb2d7ee1ab4c812a9f57fd811be17be87b2093]:
:results:
#+begin_example
SUCCEED at Ex_1-33B
#+end_example
:end:

** 1.3.2: Constructing Procedures Using lambda

A procedure that's only used once is more conveniently expressed as the special
form ~lambda~.

Variables that are only briefly used in a limited scope can be specified with
the special form ~let~. Variables in ~let~ blocks override external variables.
The authors recommend using ~define~ for procedures and ~let~ for variables.

** Exercise 1.34

*** Question
#+begin_quote
Suppose we define the procedure
#+end_quote

#+BEGIN_SRC scheme
(define (f g) (g 2))
#+END_SRC

#+begin_quote
Then, we have
#+end_quote

#+BEGIN_SRC scheme
(f square)
; 4
(f (lambda (z) (* z (+ z 1))))
; 6
#+END_SRC

#+begin_quote
What happens if we (perversely) ask the interpreter to evaluate the combination
src_scheme{(f f)}? Explain.
#+end_quote

*** Answer

It ends up trying to execute ~2~ as a function.
#+BEGIN_SRC scheme -n :eval no-export :results output
;; Will be evaluated like this:
;;   (f f)
;;   (f 2)
;;   (2 2)
(define (f g) (g 2))
(f f)
#+END_SRC

#+RESULTS[fa3fee1227bd981f86a7f021bb6f63e9ad869b8e]:
:results:
#+begin_example
ice-9/boot-9.scm:1685:16: In procedure raise-exception:
Wrong type to apply: 2
#+end_example
:end:

** 1.3.3 Procedures as General Methods

The *half-interval method*: if \(f(a)<0<f(b)\), then \(f\) must have at least
one 0 between \(a\) and \(b\). To find 0, let \(x\) be the average of \(a\) and
\(b\), if \(f(x) < 0\) then 0 must be between \(x\) and \(b\), if \(f(x)>0\)
than 0 must be between \(a\) and \(x\).

The *fixed point* of a function satisfies the equation \[f(x)=x\]

For some functions, we can locate a fixed point by beginning with an initial
guess \(y\) and applying \(f(y)\) repeatedly until the value doesn't change
much.

*Average damping* can help converge fixed-point searches.

The symbol \(\mapsto\) ("maps to") can be considered equivalent to a lambda. For
example, \(x \mapsto x+x\) is equivalent to src_scheme{(lambda (x) (+ x x))}. In
English, "the function whose value at \(y\) is \(x/y\)". /Though it seems like
\(\mapsto\) doesn't necessarily describe a function, but the value of a function
at a certain point? Or maybe that would just be \(~\), ie \(f(x)~etc\)/

** Exercise 1.35

*** Text
#+NAME: close-enough-txt
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (close-enough? x y) 
  (< (abs (- x y)) 0.001))
#+END_SRC

#+NAME: fixed-point-txt
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define tolerance 0.00001)

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) 
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))
#+END_SRC

*** Question

#+begin_quote
Show that the golden ratio \(\varphi\) is a fixed point of the transformation
\(x \mapsto 1 + 1 / x\), and use this fact to compute \(\varphi\) by means of
the ~fixed-point~ procedure.
#+end_quote

*** Answer

#+NAME: golden-ratio
#+BEGIN_SRC scheme -n :eval no-export :results output
<<close-enough>>
<<fixed-point-txt>>
(define golden-ratio
  (fixed-point (λ(x)(+ 1 (/ 1 x)))
               1.0))

(display golden-ratio)
#+END_SRC

#+RESULTS[ab642d672c1d63abecbdf383dc53da955f5e11c7]: fixed-point-txt
:results:
#+begin_example
1.6180327868852458
#+end_example
:end:

** Exercise 1.36

*** Question

#+begin_quote
Modify ~fixed-point~ so that it prints the sequence of approximations it
generates, using the ~newline~ and ~display~ primitives shown in Exercise 1.22.
Then find a solution to \(x^x = 1000\) by finding a fixed point of \(x \mapsto
\log(1000) / \log(x)\). (Use Scheme's primitive ~log~ procedure, which computes
natural logarithms.) Compare the number of steps this takes with and without
average damping. (Note that you cannot start ~fixed-point~ with a guess of 1, as
this would cause division by \(\log(1) = 0\).)
#+end_quote

*** Answer

Using the ~display~ and ~newline~ functions at any great extent is pretty
exhausting, so I'll use ~format~ instead.
#+NAME: fixed-point-debug
#+BEGIN_SRC scheme -n :eval no-export :results silent
(use-modules (ice-9 format))
(define tolerance 0.00001)

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) 
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (format #t "~&~a~%" next)
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :results output :exports code
<<close-enough>>
<<fixed-point-debug>>
(fixed-point (λ(x) (/ (log 1000) (log x))) 1.1)
#+END_SRC

#+RESULTS[26e30764924462e2d22df8d8ba9a56af22698a31]:
:results:
72.47657378429035
1.6127318474109593
14.45350138636525
2.5862669415385087
7.269672273367045
3.4822383620848467
5.536500810236703
4.036406406288111
4.95053682041456
4.318707390180805
4.721778787145103
4.450341068884912
4.626821434106115
4.509360945293209
4.586349500915509
4.535372639594589
4.568901484845316
4.546751100777536
4.561341971741742
4.551712230641226
4.558059671677587
4.55387226495538
4.556633177654167
4.554812144696459
4.556012967736543
4.555220997683307
4.555743265552239
4.555398830243649
4.555625974816275
4.555476175432173
4.555574964557791
4.555509814636753
4.555552779647764
4.555524444961165
4.555543131130589
4.555530807938518
4.555538934848503
:end:

Undamped, fixed-point makes 37 guesses.

#+BEGIN_SRC scheme -n :eval no-export :results output :exports code
<<close-enough>>
<<fixed-point-debug>>
(define (average x y)
  (/ (+ x y) 2))
(fixed-point (λ(x) (average (log x) (/ (log 1000) (log x)))) 1.1)
#+END_SRC

#+RESULTS[c8b656c007db26b56776bc139a6cba1a86bb3755]:
:results:
36.28594198204734
2.7574149265729444
3.912351744086603
3.213980298130383
3.542082820324556
3.363310959347184
3.4540216132238184
3.4061901980695635
3.4309216866411916
3.418001560431991
3.4247152892453725
3.4212168715053366
3.42303720142058
3.4220893146379012
3.422582706729079
3.4223258347369994
3.4224595543381247
3.4223899401968296
3.4224261801254277
3.422407313956363
3.4224171354313153
:end:

Damped, it makes 21.

** Exercise 1.37

*** Question A

#+begin_quote
An infinite continued fraction is an expression of the form

\[ {f} = \cfrac{N_1}{D_1 + \cfrac{N_2}{D_2 + \cfrac{N_3}{D_3 + \dots}}} \]

As an example, one can show that the infinite continued fraction expansion with
the \(N_i\) and the \(D_i\) all equal to 1 produces \(1 / \varphi\), where
\(\varphi\) is the golden ratio (described in 1.2.2). One way to approximate an
infinite continued fraction is to truncate the expansion after a given number of
terms. Such a truncation---a so-called \(k\)-term finite continued
fraction}---has the form

\[ \cfrac{N_1}{D_1 + \cfrac{N_2}{\ddots + \cfrac{N_k}{D_k}}} \]

Suppose that ~n~ and ~d~ are procedures of one argument (the term index \(i\))
that return the \(N_i\) and \(D_i\) of the terms of the continued fraction.
Define a procedure ~cont-frac~ such that evaluating
src_scheme{(cont-frac n d k)} computes the value of the \(k\)-term finite continued
fraction.
#+end_quote

*** Answer A

A note: the "golden ratio" this code estimates is exactly =1.0= less than the
golden ratio anyone else seems to be talking about.
#+NAME: cont-frac
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (cont-frac n d k)
  (define (iter i result)
    (if (= i 0)
        result
        (iter (1- i) (/ (n i) (+ (d i) result)))))

  (iter (1- k) (/ (n k) (d k))))
#+END_SRC

*** Question B

Check your procedure by approximating \(1 / \varphi\) using

#+BEGIN_SRC scheme
(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           k)
#+END_SRC

for successive values of ~k~. How large must you make ~k~ in order to get an
approximation that is accurate to 4 decimal places?

*** Answer B

#+NAME: cont-frac-data
#+BEGIN_SRC scheme -n :eval no-export :results value table :exports results
<<cont-frac>>
(define (golden-ratio k)
  (cont-frac (λ(i) 1.0)(λ(i)1.0) k))

(map (λ(x y) (list x y))
     (iota 10 1)
      (map (λ(x)(- 0.61803398874989484820
                   (golden-ratio x)))
           (iota 10 1)))
#+END_SRC

#+RESULTS[c254d70f15375afe5614dfb4a165f1fa23fa4c6f]: cont-frac-data
:results:
|  1 |     -0.3819660112501051 |
|  2 |      0.1180339887498949 |
|  3 |    -0.04863267791677173 |
|  4 |    0.018033988749894814 |
|  5 |  -0.0069660112501050975 |
|  6 |   0.0026493733652794837 |
|  7 |  -0.0010136302977241662 |
|  8 |  0.00038692992636546464 |
|  9 | -0.00014782943192326314 |
| 10 |  5.6460660007306984e-05 |
:end:


#+begin_src gnuplot :var data=cont-frac-data :file 1/fig/1-36-1.png :exports results :cache no :eval no-export
reset
#set logscale xy
set xlabel 'iterations'
set xtics rotate by -45
set ylabel 'error'
set title 'distance from true golden ratio'

plot data using 2:xticlabels(1) with fillsteps fs solid 0.3 noborder lt 1 notitle,\
     data using 2:xticlabels(1) with steps lt 1 lw 4 title '(golden-ratio)'
#+end_src

#+RESULTS:
:results:
[[file:1/fig/1-36-1.png]]
:end:

\(k\) must be at least 10 to get precision of 4 decimal places.

*** Question C

#+begin_quote
If your ~cont-frac~ procedure generates a recursive process, write one that
generates an iterative process. If it generates an iterative process, write one
that generates a recursive process.
#+end_quote

*** Answer C

#+NAME: cont-frac-rec
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (cont-frac-rec n d k)
  (define (rec i)
    (if (= i k)
        (/ (n i) (d i))
        (/ (n i) (+ (d i) (rec (1+ i))))))

  (rec 1))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :results output :exports both
<<cont-frac>>
<<cont-frac-rec>>
(define (golden-ratio k)
  (cont-frac (λ(i) 1.0)(λ(i)1.0) k))
(define (golden-ratio-rec k)
  (cont-frac-rec (λ(i) 1.0)(λ(i)1.0) k))

(load "mattcheck.scm")
(mattcheck-equal "cont-frac iter and recursive equivalence"
           (golden-ratio-rec 15)
           (golden-ratio 15))
#+END_SRC

#+RESULTS[061d67cf4b680c4b50b710fad1cf7538691b71ac]:
:results:
#+begin_example
SUCCEED at cont-frac iter and recursive equivalence
#+end_example
:end:

** Exercise 1.38

*** Question

#+begin_quote
In 1737, the Swiss mathematician Leonhard Euler published a memoir /De
Fractionibus Continuis/, which included a continued fraction expansion for \(e -
2\), where \(e\) is the base of the natural logarithms. In this fraction, the
\(N_i\) are all 1, and the \(D_i\) are successively 1, 2, 1, 1, 4, 1, 1, 6, 1,
1, 8, \(\dots\). Write a program that uses your ~cont-frac~ procedure from
Exercise 1.37 to approximate \(e\), based on Euler's expansion.
#+end_quote

*** Answer

#+BEGIN_SRC scheme -n :eval no-export :results value :exports both
<<cont-frac>>
(define (euler k)
  (+ 2
     (cont-frac (λ(i) 1.0)
             (λ(i) (let ((j (1+ i)))
                     (if (= 0 (modulo j 3))
                         (* 2 (/ j 3))
                         1)))
             k)))

(euler 100)
#+END_SRC

#+RESULTS[a208d4dc1b978fe45e625fd5adc3de43be87dd9c]:
:results:
#+begin_example
2.7182818284590455
#+end_example
:end:

** Exercise 1.39

*** Question

#+begin_quote
A continued fraction representation of the tangent function was published in
1770 by the German mathematician J.H. Lambert:

\[ {\tan x} = \cfrac{x}{1 - \cfrac{x^2}{3 - \cfrac{x^2}{5 - \dots}}} \]

where \(x\) is in radians. Define a procedure src_scheme{(tan-cf x k)} that
computes an approximation to the tangent function based on Lambert's formula.
~k~ specifies the number of terms to compute, as in Exercise 1.37.
#+end_quote

*** Answer

#+BEGIN_SRC scheme -n :eval no-export :results value :exports both
<<cont-frac>>
(define (tan-cf x k)
  (cont-frac (λ(i) (if (= i 1)
                       x
                       (* x x -1.0)))
             (λ(i) (if (= i 1)
                       1.0
                       (- (* i 2.0) 1.0)))
             k))

(tan-cf 55 101)
#+END_SRC

#+RESULTS[a9f862c95bda0554e11a254c33a0772723442763]:
:results:
#+begin_example
-45.1830879105221
#+end_example
:end:

** 1.3.4 Procedures as Returned Values

Procedures can return other procedures, which opens up new ways to express
processes.

#+begin_quote
Newton's Method: \(g(x)=0\) is a fixed point of the function \(x \mapsto f(x)\)
where \[f(x)=x-\frac{g(x)}{Dg(x)}\]

Where \(x \mapsto g(x)\) is a differentiable function and \(Dg(x)\) is the
derivative of \(g\) evaluated at \(x\).
#+end_quote

** Exercise 1.40

*** Text
#+NAME: average-damp
#+BEGIN_SRC scheme -n :eval no-export :results silent :exports code
(define (average-damp f)
  (lambda (x) (average x (f x))))
#+END_SRC

#+NAME: dx
#+BEGIN_SRC scheme -n :eval no-export :results silent :exports code
(define dx 0.00001)
#+END_SRC

#+NAME: deriv
#+BEGIN_SRC scheme -n :eval no-export :results silent :exports code
(define (deriv g)
  (lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))
#+END_SRC

#+NAME: newtons-method
#+BEGIN_SRC scheme -n :eval no-export :results silent :exports code
(define (newton-transform g)
  (lambda (x) (- x (/ (g x) ((deriv g) x)))))
(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))
#+END_SRC
#+NAME: newtons-method-txt
#+BEGIN_SRC scheme -n :eval no-export :results silent :exports code
<<average>>
<<average-damp>>
<<dx>>
<<deriv>>
<<newtons-method>>
#+END_SRC

*** Question

#+begin_quote
Define a procedure ~cubic~ that can be used together with the ~newtons-method~
procedure in expressions of the form:
#+end_quote

#+BEGIN_SRC scheme
(newtons-method (cubic a b c) 1)
#+END_SRC

#+begin_quote
to approximate zeros of the cubic \(x^3 + ax^2 + bx + c\).
#+end_quote

*** Answer

#+NAME: cubic
#+BEGIN_SRC scheme -n :eval no-export :results silent :exports code
(define (cubic a b c)
  (lambda (x)
    (+ (expt x 3)
       (* a (expt x 2))
       (* b x)
       c)))
#+END_SRC

#+NAME: cubic-zero
#+BEGIN_SRC scheme -n :eval no-export :results silent :exports code
(define (cubic-zero a b c)
  (newtons-method (cubic a b c) 1))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :results value :exports code
<<fixed-point-txt>>
<<newtons-method-txt>>
<<cubic>>
<<cubic-zero>>

(cubic-zero 2 3 4)
#+END_SRC

#+RESULTS[b8fe4f9579a7f55cc0714e136ae1b983a07db228]:
:results:
#+begin_example
-1.6506291914330982
#+end_example
:end:

** Exercise 1.41

*** Question

#+begin_quote
Define a procedure ~double~ that takes a procedure of one argument as argument
and returns a procedure that applies the original procedure twice. For example,
if ~inc~ is a procedure that adds 1 to its argument, then src_scheme{(double inc)}
should be a procedure that adds 2. What value is returned by
#+end_quote

#+NAME: Ex1-41
#+BEGIN_SRC scheme :eval no-export
(((double (double double)) inc) 5)
#+END_SRC

*** Answer

#+NAME: double
#+BEGIN_SRC scheme :eval no-export :results silent
(define (double f)
  (λ (x)
    (f (f x))))
#+END_SRC

#+BEGIN_SRC scheme :eval no-export :results value
(define inc 1+)
<<double>>
<<Ex1-41>>
#+END_SRC

#+RESULTS[d378985b9b2b6be8eb74b8df173275c6bd56ae10]:
:results:
#+begin_example
21
#+end_example
:end:

**  Exercise 1.42

*** Question

#+begin_quote
Let \(f\) and \(g\) be two one-argument functions. The composition \(f\) after
\(g\) is defined to be the function \(x \mapsto f(g(x))\). Define a procedure
~compose~ that implements composition.
#+end_quote

*** Answer

#+NAME: compose
#+BEGIN_SRC scheme :eval no-export :results silent
(define (compose f g)
  (λ(x)
    (f (g x))))
#+END_SRC

#+BEGIN_SRC scheme :eval no-export :results value
<<compose>>
<<square>>
(define inc 1+)
((compose square inc) 6)
#+END_SRC

#+RESULTS[80a0d7155cb9d63a3166cc9ed13620258b09201d]:
:results:
#+begin_example
49
#+end_example
:end:

**  Exercise 1.43

*** Question

#+begin_quote
If \(f\) is a numerical function
and \(n\) is a positive integer, then we can form the \(n^{\mathrm{th}}\) repeated
application of \(f\), which is defined to be the function whose value at \(x\)
is \(f(f(\dots (f(x))\dots ))\).  For example, if \(f\) is the
function \(x \mapsto x + 1\), then the \(n^{\mathrm{th}}\) repeated application of \(f\) is
the function \(x \mapsto x + n\).  If \(f\) is the operation of squaring a
number, then the \(n^{\mathrm{th}}\) repeated application of \(f\) is the function that
raises its argument to the \(2^n\)-th power.  Write a procedure that takes as
inputs a procedure that computes \(f\) and a positive integer \(n\) and returns
the procedure that computes the \(n^{\mathrm{th}}\) repeated application of \(f\).
#+end_quote

*** Answer

#+NAME: repeated
#+BEGIN_SRC scheme :eval no-export :results silent
<<compose>>
(define (repeated f n)
  (if (= n 1)
      f
      (repeated (compose f f)
                (- n 1))))
#+END_SRC

#+BEGIN_SRC scheme :eval no-export :results value
<<square>>
<<repeated>>
(if (= ((repeated square 2) 5) 625)
    "Success"
    "Fail")
#+END_SRC

#+RESULTS[272bb6d728bab74579f0a931d49a14a7ad2a5498]:
:results:
#+begin_example
Success
#+end_example
:end:

**  Exercise 1.44

*** Question

#+INDEX: smoothing
#+begin_quote
The idea of smoothing a function is an important concept in signal processing.
If \(f\) is a function and \(dx\) is some small number, then the smoothed
version of \(f\) is the function whose value at a point \(x\) is the average of
\(f(x - dx)\), \(f(x)\), and \(f(x + dx)\). Write a procedure ~smooth~ that
takes as input a procedure that computes \(f\) and returns a procedure that
computes the smoothed \(f\). It is sometimes valuable to repeatedly smooth a
function (that is, smooth the smoothed function, and so on) to obtain the
\(n\)-fold smoothed function. Show how to generate the \(n\)-fold smoothed
function of any given function using ~smooth~ and ~repeated~ from Exercise 1.43.
#+end_quote

*** Answer

#+NAME: smooth
#+BEGIN_SRC scheme :eval no-export :results silent
<<average-varargs>>
(define (smooth f)
  (λ(x)
    (average (f (- x dx))
             (f x)
             (f (+ x dx)))))
(define (smooth-n f n)
  ((repeated smooth n) f))
#+END_SRC

**  Exercise 1.45

*** Question

#+begin_quote
We saw in 1.3.3 that attempting to compute square roots by naively finding a
fixed point of \(y \mapsto x / y\) does not converge, and that this can be fixed by
average damping. The same method works for finding cube roots as fixed points of
the average-damped \(y \mapsto x / y^2\). Unfortunately, the process does not work for
fourth roots---a single average damp is not enough to make a fixed-point search
for \(y \mapsto x / y^3\) converge. On the other hand, if we average damp twice (i.e.,
use the average damp of the average damp of \(y \mapsto x / y^3\)) the fixed-point
search does converge. Do some experiments to determine how many average damps
are required to compute \(n^{\mathrm{th}}\) roots as a fixed-point search based
upon repeated average damping of \(y \mapsto x / y^{n-1}\). Use this to implement a
simple procedure for computing \(n^{\mathrm{th}}\) roots using ~fixed-point~,
~average-damp~, and the ~repeated~ procedure of Exercise 1.43. Assume that any
arithmetic operations you need are available as primitives.
#+end_quote

*** Answer

So this is strange. Back in my original workthrough of this book, I'd decided
that finding an \(n\)th root required \(\lfloor\sqrt{n}\rfloor\) dampings. With
a solution like this:
#+BEGIN_SRC scheme :eval no-export :results silent
<<fixed-point-txt>>
<<repeated>>
<<average-damp>>
(define (sqrt n)
  (fixed-point
   (average-damp
    (lambda (y)
      (/ x y)))
   1.0))
(define (nth-root x n)
  (fixed-point
   ((repeated average-damp (ceiling (sqrt n)))
    (lambda (y)
      (/ x (expt y (- n 1)))))
   1.0))
#+END_SRC
While this solution appears to work fine, my experiments are suggesting that it
takes /less/ than \(\lfloor\sqrt{n}\rfloor\). For example, I originally thought
powers of 16 required four dampings, but this code isn't failing until it
reaches powers of 32.
#+NAME: repeated-z
#+BEGIN_SRC scheme :eval no-export :results silent
;; Version of "repeated" that can handle being asked to repeat zero times.
<<compose>>
<<identity>>
(define (repeated f n)
  (define (rec m)
  (if (= n 1)
      f
      (repeated (compose f f)
                (- n 1))))
  (if (= n 0)
      identity
      (rec n)))
#+END_SRC
#+NAME: limited-fixed-point
#+BEGIN_SRC scheme :eval no-export :results silent :exports code
;; version of "fixed-point" that will give up after a certain number of guesses.
(define (limited-fixed-point f first-guess)
  (define limit 5000)
  (define tolerance 0.00000001)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) 
       tolerance))
  (define (try guess tries)
    (if (= tries limit)
        "LIMIT REACHED"
        (let ((next (f guess)))
          (if (close-enough? guess next)
              next
              (try next (+ 1 tries))))))
    (try first-guess 1))
#+END_SRC
#+NAME: nth-damp-experiments
#+BEGIN_SRC scheme :eval no-export :results output :exports none
<<limited-fixed-point>>
<<average-varargs>>
<<repeated-z>>
<<average-damp>>
(define (try-damp base nth damp)
  (format #t "Root ~a, Damp ~a: ~a~%" nth damp
          (limited-fixed-point
           ((repeated average-damp damp)
            (lambda (y)
              (/ base (expt y (- nth 1)))))
           1.0)))
(define random-base 4)
(try-damp random-base 2 1)
(try-damp random-base 3 1)
(try-damp random-base 4 1)
(try-damp random-base 4 2)
(format #t "...~%")
(try-damp random-base 8 2)
(try-damp random-base 8 3)
(format #t "...~%")
(try-damp random-base 16 3)
(format #t "...~%")
(try-damp random-base 32 3)
(try-damp random-base 32 4)
#+END_SRC

#+RESULTS[baa7d010b67b75e2bd3a059b0a1b06b3875af0ba]: nth-damp-experiments
:results:
#+begin_example
Root 2, Damp 1: 2.0
Root 3, Damp 1: 1.5874010540873353
Root 4, Damp 1: LIMIT REACHED
Root 4, Damp 2: 1.414213562373095
...
Root 8, Damp 2: LIMIT REACHED
Root 8, Damp 3: 1.1892071085557818
...
Root 16, Damp 3: 1.0905077326652577
...
Root 32, Damp 3: LIMIT REACHED
Root 32, Damp 4: 1.0442737140494485
#+end_example
:end:

Let's automatically find how many dampings are necessary. We can make a program
that finds higher and higher \(n\)th roots, and adds another layer of damping
when it hits the error. It returns a list of \(n\)th roots along with how many
dampings were needed to find them.

#+NAME: nthtester
#+BEGIN_SRC scheme :eval no-export :results value table :exports code :hlines no :session scheme
<<fixed-point-txt>>
<<limited-fixed-point>>
<<repeated>>
<<average-damp>>
<<average>>
<<print-table>>
(define (sqrt x)
  (fixed-point
   (average-damp
    (lambda (y) (/ x y)))
   1.0))
(define (nth-tester base n-max)
  (define (iter ll)
    (let ((n (+ 2 (length ll))))
      (define (try damps)
        (let ((x (limited-fixed-point
                  ((repeated average-damp damps)
                   (lambda (y)
                     (/ base (expt y (- n 1)))))
                  1.1)))
          (if (string? x)
              (try (1+ damps))
              (list base n x damps))))
      (if (> n n-max)
          ll
          (iter (cons (try 1) ll)))))

  (iter '()))
(let* ((t (reverse (nth-tester 3 65))))
  (cons '("root" "result" "damps needed" "floor(sqrt(root))" "floor(log2(root))")
        (map (λ(x)
               (append x
                       (list (floor (sqrt (car x)))
                             (floor (/ (log (car x))(log 2))))))
             (map cdr t))))
#+END_SRC

#+RESULTS[d992ef4a748476608795d2c8a3fe54460d3f8a8a]: nthtester
:results:
| root |             result | damps needed | floor(sqrt(root)) | floor(log2(root)) |
|    2 | 1.7320508075688772 |            1 |               1.0 |               1.0 |
|    3 | 1.4422495728972309 |            1 |               1.0 |               1.0 |
|    4 | 1.3160740129524924 |            2 |               2.0 |               2.0 |
|    5 | 1.2457309390978177 |            2 |               2.0 |               2.0 |
|    6 |    1.2009369582204 |            2 |               2.0 |               2.0 |
|    7 | 1.1699308089776124 |            2 |               2.0 |               2.0 |
|    8 | 1.1472026821129655 |            3 |               2.0 |               3.0 |
|    9 | 1.1298309604123054 |            3 |               3.0 |               3.0 |
|   10 | 1.1161231685395683 |            3 |               3.0 |               3.0 |
|   11 | 1.1050314993438861 |            3 |               3.0 |               3.0 |
|   12 | 1.0958726922025126 |            3 |               3.0 |               3.0 |
|   13 | 1.0881822443361364 |            3 |               3.0 |               3.0 |
|   14 | 1.0816334006324368 |            3 |               3.0 |               3.0 |
|   15 | 1.0759896251411307 |            3 |               3.0 |               3.0 |
|   16 | 1.0710754830729146 |            3 |               4.0 |               4.0 |
|   17 |  1.066758117243043 |            3 |               4.0 |               4.0 |
|   18 | 1.0629350706173066 |            3 |               4.0 |               4.0 |
|   19 | 1.0595260635832688 |            3 |               4.0 |               4.0 |
|   20 |  1.056467307522174 |            3 |               4.0 |               4.0 |
|   21 | 1.0537074708846985 |            3 |               4.0 |               4.0 |
|   22 |  1.051204784758733 |            3 |               4.0 |               4.0 |
|   23 | 1.0489249192322252 |            3 |               4.0 |               4.0 |
|   24 | 1.0468393795110007 |            3 |               4.0 |               4.0 |
|   25 | 1.0449243484862798 |            3 |               5.0 |               4.0 |
|   26 | 1.0431597437151425 |            3 |               5.0 |               4.0 |
|   27 | 1.0415285013758537 |            3 |               5.0 |               4.0 |
|   28 |  1.040016054068828 |            3 |               5.0 |               4.0 |
|   29 | 1.0386098933815124 |            3 |               5.0 |               4.0 |
|   30 | 1.0372992018887395 |            3 |               5.0 |               4.0 |
|   31 | 1.0360745603591814 |            3 |               5.0 |               4.0 |
|   32 | 1.0349278294117377 |            4 |               5.0 |               5.0 |
|   33 | 1.0338516994340794 |            4 |               5.0 |               5.0 |
|   34 | 1.0328398949566373 |            4 |               5.0 |               5.0 |
|   35 | 1.0318868074940988 |            4 |               5.0 |               5.0 |
|   36 | 1.0309874779794508 |            4 |               6.0 |               5.0 |
|   37 | 1.0301374915678254 |            4 |               6.0 |               5.0 |
|   38 | 1.0293328804238742 |            4 |               6.0 |               5.0 |
|   39 | 1.0285701132080831 |            4 |               6.0 |               5.0 |
|   40 | 1.0278460087576442 |            4 |               6.0 |               5.0 |
|   41 |  1.027157691880423 |            4 |               6.0 |               5.0 |
|   42 |  1.026502589210212 |            4 |               6.0 |               5.0 |
|   43 | 1.0258783464077128 |            4 |               6.0 |               5.0 |
|   44 | 1.0252828248592394 |            4 |               6.0 |               5.0 |
|   45 | 1.0247141024331754 |            4 |               6.0 |               5.0 |
|   46 | 1.0241703948455623 |            4 |               6.0 |               5.0 |
|   47 | 1.0236501025835851 |            4 |               6.0 |               5.0 |
|   48 | 1.0231517295808754 |            4 |               6.0 |               5.0 |
|   49 | 1.0226739268075815 |            4 |               7.0 |               5.0 |
|   50 | 1.0222154464817517 |            4 |               7.0 |               5.0 |
|   51 | 1.0217751474551418 |            4 |               7.0 |               5.0 |
|   52 | 1.0213519544877643 |            4 |               7.0 |               5.0 |
|   53 | 1.0209448968817703 |            4 |               7.0 |               5.0 |
|   54 | 1.0205530691216933 |            4 |               7.0 |               5.0 |
|   55 | 1.0201756322085958 |            4 |               7.0 |               5.0 |
|   56 | 1.0198118076629914 |            4 |               7.0 |               5.0 |
|   57 | 1.0194608721653386 |            4 |               7.0 |               5.0 |
|   58 | 1.0191221527564327 |            4 |               7.0 |               5.0 |
|   59 | 1.0187950225306854 |            4 |               7.0 |               5.0 |
|   60 | 1.0184788967642957 |            4 |               7.0 |               5.0 |
|   61 |  1.018173221527439 |            4 |               7.0 |               5.0 |
|   62 | 1.0178775017280584 |            4 |               7.0 |               5.0 |
|   63 | 1.0175912519998893 |            4 |               7.0 |               5.0 |
|   64 |  1.017314024680506 |            4 |               8.0 |               6.0 |
|   65 | 1.0170453922678477 |            4 |               8.0 |               6.0 |
:end:

#+begin_src gnuplot :var data=nthtester :file 1/fig/1-45-1.png :exports results :rownames no :colnames no :hlines no :cache no :eval no-export :session nil
reset
set key autotitle columnheader
#set logscale xy
set xlabel 'dampings'
set xtics (2, 4, 8, 16, 24, 32, 36, 49, 64)
set ylabel 'powers'
set title 'dampings needed vs estimated'

plot data using 1:3 with linespoints, \
     data using 1:4 with linespoints, \
     data using 1:5 with linespoints
#+end_src

#+RESULTS:
:results:
[[file:1/fig/1-45-1.png]]
:end:

I've spent too much time on this problem already but I have to wonder about
floating-point issues, given that they are the core of the ~good-enough~
procedure. I have to wonder whether a ~fixed-point~ version that replaces the
~tolerance~ decision making, and instead retains the last three guesses and
checks for a loop.

**  Exercise 1.46

*** Question

#+begin_quote
Several of the numerical methods described in this chapter are instances of an
extremely general computational strategy known as /iterative improvement/.
Iterative improvement says that, to compute something, we start with an initial
guess for the answer, test if the guess is good enough, and otherwise improve
the guess and continue the process using the improved guess as the new guess.
Write a procedure ~iterative-improve~ that takes two procedures as arguments: a
method for telling whether a guess is good enough and a method for improving a
guess. ~iterative-improve~ should return as its value a procedure that takes a
guess as argument and keeps improving the guess until it is good enough. Rewrite
the ~sqrt~ procedure of 1.1.7 and the ~fixed-point~ procedure of 1.3.3 in terms
of ~iterative-improve~.
#+end_quote

*** Answer

#+NAME: iterative-improve
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (iterative-improve good-enough? improve)
  (λ(first-guess)
    (define (iter guess)
      (let ((next (improve guess)))
        (if (good-enough? guess next)
            next
            (iter next))))
    (iter first-guess)))
#+END_SRC
#+NAME: fixed-point-improve
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<iterative-improve>>
(define tolerance 0.00001)

(define (fixed-point-improve f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) 
       tolerance))
  ((iterative-improve close-enough? f) first-guess))
#+END_SRC
#+NAME: sqrt-improve
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<average>>
<<iterative-improve>>
(define (improve guess x)
  (average guess (/ x guess)))
(define (good-enough? guess x)
   (= (improve guess x) guess))
(define (sqrt-improve x)
  ((iterative-improve
    (λ(guess) (improve guess x))
    (λ(guess) (good-enough? guess x)))
   1.0))
#+end_src


#+BEGIN_SRC scheme -n :eval no-export :results output :exports both
(load "mattcheck2.scm")
<<fixed-point-txt>>
<<fixed-point-improve>>
(mattcheck "fixed-point-improve still working"
                 (fixed-point (λ(x)(+ 1 (/ 1 x))) 1.0)
                 (fixed-point-improve (λ(x)(+ 1 (/ 1 x))) 1.0))
<<sqrt>>
<<sqrt-improve>>
(mattcheck "sqrt-improve still working"
                 (sqrt 5)
                 (sqrt 5))
#+end_src

#+RESULTS[49e2502d17e839bb65d25dd9526ca0e38e76de3a]:
#+begin_EXAMPLE
SUCCEED at fixed-point-improve still working
SUCCEED at sqrt-improve still working
#+end_EXAMPLE

* Chapter 2: Building Abstractions with Data

The basic representations of data we've used so far aren't enough to deal with
complex, real-world phenomena. We need to combine these representations to form
*compound data*.

The technique of isolating how data objects are /represented/ from how they are
/used/ is called *data abstraction*.

** 2.1.1: Example: Arithmetic Operations for Rational Numbers

Lisp gives the procedures ~cons~, ~car~, and ~cdr~ to create *pairs*. This is an
easy system for representing rational numbers.

Note that the system proposed for representing and working with rational numbers
has *abstraction barriers* isolating different parts of the system. The parts
that use rational numbers don't know how the constructors and selectors for
rational numbers work, and the constructors and selectors use the underlying
Lisp interpreter's pair functions without caring how they work.

Note that these abstraction layers allow the developer to change the underlying
architecture without modifying the programs that depend on it.

**  Exercise 2.1

*** Text

#+NAME: rat-ops-txt
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))

(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))

(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))

(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))

(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))
#+end_src

#+NAME: make-rat-txt
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (make-rat n d) (cons n d))
(define (numer x) (car x))
(define (denom x) (cdr x))
#+end_src

#+NAME: print-rat-txt
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))
#+end_src

#+NAME: test-rats
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define one-half (make-rat 1 2))
(define one-third (make-rat 1 3))
(print-rat one-half)
(print-rat
 (mul-rat one-half one-third))
#+end_src
#+BEGIN_SRC scheme -n :eval no-export :results output :exports results
<<make-rat-txt>>
<<print-rat-txt>>
<<rat-ops-txt>>
<<test-rats>>
#+end_src

#+RESULTS[5284680400d64a3dbc6e21d0d8290e327844ee81]:
#+begin_EXAMPLE
1/2
1/6
#+end_EXAMPLE

*** Question

#+begin_quote
Define a better version of ~make-rat~ that handles both positive and negative
arguments. ~make-rat~ should normalize the sign so that if the rational number
is positive, both the numerator and denominator are positive, and if the
rational number is negative, only the numerator is negative.
#+end_quote

*** Answer

#+NAME: make-rat
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<abs>>
(define (make-rat n d)
  (cond ((not (or (< n 0)
              (< d 0)))
         (cons n d))
        ((and (< n 0)
              (< d 0))
         (cons (- n) (- d)))
        (else
         (cons (- (abs n)) (abs d)))))
(define (numer x) (car x))
(define (denom x) (cdr x))

;; Bonus: an attempt to optimize
(define (make-rat-opt n d)
  (let ((nn (< n 0))
        (dn (< d 0)))
    (cond ((not (or nn dn))
           (cons n d))
          ((and nn dn)
           (cons (- n) (- d)))
          (else
           (cons (- (abs n)) (abs d))))))
#+end_src
#+BEGIN_SRC scheme -n :eval no-export :results output :exports both
<<make-rat>>
<<print-rat-txt>>
<<rat-ops-txt>>
(load "mattcheck2.scm")
(mattcheck "make-rat double negative"
           (cons 1 2)
           (make-rat -1 -2))
(mattcheck "make-rat numerator negative"
           (cons -1 2)
           (make-rat -1 2))
(mattcheck "make-rat denominator negative"
           (cons -1 2)
           (make-rat 1 -2))
(mattcheck "make-rat-opt double negative"
           (cons 1 2)
           (make-rat-opt -1 -2))
(mattcheck "make-rat-opt numerator negative"
           (cons -1 2)
           (make-rat-opt -1 2))
(mattcheck "make-rat-opt denominator negative"
           (cons -1 2)
           (make-rat-opt 1 -2))
#+end_src

#+RESULTS[6a599c6ffbdd54a018b8f6fcc59203abdefb8621]:
#+begin_EXAMPLE
SUCCEED at make-rat double negative
SUCCEED at make-rat numerator negative
SUCCEED at make-rat denominator negative
SUCCEED at make-rat-opt double negative
SUCCEED at make-rat-opt numerator negative
SUCCEED at make-rat-opt denominator negative
#+end_EXAMPLE

#+BEGIN_SRC scheme -n :noeval :results output :exports results :tangle 2/Ex1-bench.scm
(use-modules (ice-9 format))
<<make-rat>>
<<print-rat-txt>>
<<rat-ops-txt>>
(load "../mattbench.scm")

(let ((tryit (λ(f)
               (f 1 2)
               (f -1 2)
               (f 1 -2)
               (f -1 -2))))

  (format #t "~&unoptimized make-rat: ~a~%"(mattbench2 (λ()(tryit make-rat)) 500000000))
  (format #t "~&optimized make-rat: ~a~%"(mattbench2 (λ()(tryit make-rat-opt)) 500000000)))
#+end_src

My "optimized" version shows no benefit at all:
#+RESULTS:
#+BEGIN_EXAMPLE
unoptimized make-rat: ((1 . 2) 231.74267794)
optimized make-rat: ((1 . 2) 233.99087033)
#+END_EXAMPLE

**  Exercise 2.2

*** Question

#+begin_quote
Consider the problem of representing line segments in a plane. Each segment is
represented as a pair of points: a starting point and an ending point. Define a
constructor ~make-segment~ and selectors ~start-segment~ and ~end-segment~ that
define the representation of segments in terms of points. Furthermore, a point
can be represented as a pair of numbers: the \(x\) coordinate and the \(y\)
coordinate. Accordingly, specify a constructor ~make-point~ and selectors
~x-point~ and ~y-point~ that define this representation. Finally, using your
selectors and constructors, define a procedure ~midpoint-segment~ that takes a
line segment as argument and returns its midpoint (the point whose coordinates
are the average of the coordinates of the endpoints). To try your procedures,
you'll need a way to print points:
#+end_quote

#+NAME: print-point
#+BEGIN_SRC scheme -n :eval no-export :output silent
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
#+END_SRC

*** Answer

#+NAME: make-point
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<average>>
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))
(define (make-segment start end)
  (cons start end))
(define (start-segment seg)
  (car seg))
(define (end-segment seg)
  (cdr seg))
(define (midpoint-segment seg)
  (make-point (average (x-point (start-segment seg))
                       (x-point (end-segment seg)))
              (average (y-point (start-segment seg))
                       (y-point (end-segment seg)))))
(define (midpoint-segment-opt seg)
  (let ((ax (x-point (start-segment seg)))
        (bx (x-point (end-segment seg)))
        (ay (y-point (start-segment seg)))
        (by (y-point (end-segment seg))))
  (make-point (average ax
                       bx)
              (average ay
                       by))))
#+end_src
#+NAME: midpoint-segment-test
#+BEGIN_SRC scheme -n :eval no-export :results output :exports both
<<make-point>>
(load "mattcheck2.scm")
(mattcheck "make-point"
           (list 1 2)
           (let ((p (make-point 1 2)))
             (list (x-point p)
                   (y-point p))))
(let* ((p1 (make-point 1 2))
      (p2 (make-point -1 -2))
      (s (make-segment p1 p2)))
  (mattcheck "make-segment"
             (list p1 p2)
             (list (start-segment s)
                   (end-segment s)))
  (mattcheck "midpoint-segment"
              (make-point 0 0)
              (midpoint-segment s))
  (mattcheck "midpoint-segment-opt"
              (make-point 0 0)
              (midpoint-segment-opt s)))
#+end_src

#+RESULTS[141746ba8a525e713c10e21026fc2a808eda58b8]: midpoint-segment-test
#+begin_EXAMPLE
SUCCEED at make-point
SUCCEED at make-segment
SUCCEED at midpoint-segment
SUCCEED at midpoint-segment-opt
#+end_EXAMPLE

#+BEGIN_SRC scheme -n :noeval :results output :exports results :tangle 2/Ex2-bench.scm
(use-modules (ice-9 format))
<<make-point>>
(load "../mattbench.scm")

(let* ((p1 (make-point 1.0 2.0))
       (p2 (make-point -1.0 -2.0))
       (s (make-segment p1 p2))
       (tryit (λ(f)
               (f s))))

  (format #t "~&unoptimized midpoint-segment: ~a~%" (mattbench2 (λ()(tryit midpoint-segment)) 50000000))
  (format #t "~&optimized midpoint-segment: ~a~%" (mattbench2 (λ()(tryit midpoint-segment-opt)) 50000000)))
#+end_src

And once again my bikeshedding is revealed:
#+RESULTS:
#+BEGIN_EXAMPLE
unoptimized make-rat: ((0.0 . 0.0) 326.94653558)
optimized make-rat: ((0.0 . 0.0) 331.83410742)
#+END_EXAMPLE

**  Exercise 2.3

*** Question

#+begin_quote
Implement a representation for rectangles in a plane. (Hint: You may want to
make use of Exercise 2.2.) In terms of your constructors and selectors, create
procedures that compute the perimeter and the area of a given rectangle. Now
implement a different representation for rectangles. Can you design your system
with suitable abstraction barriers, so that the same perimeter and area
procedures will work using either representation?
#+end_quote

*** Answer 1

I don't really like the "wishful thinking" process the book advocates but since
this question specifically regards abstraction, I'll start by writing the two
requested procedures first.

#+NAME: rect-area-peri
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (rect-area R)
  (* (rect-height R)
     (rect-width R)))

(define (rect-peri R)
  (* 2
     (+ (rect-height R)
        (rect-width R))))
#+end_src

So my "wishlist" is just for src_scheme{(rect-area R)} and src_scheme{(rect-width R)}.

So, my first implementation of a rectangle will be of a list of 3 points
\(\mathrm{ABC}\), with the fourth point \(\mathrm{D}\) being constructed from
the others. I haven't done geometry lessons in a while but logically I can
deduce that \(\mathrm{D}\) is as far from \(\mathrm{A}\) as \(\mathrm{B}\) is
from \(\mathrm{C}\), and as far from \(\mathrm{C}\) as \(\mathrm{A}\) is from
\(\mathrm{B}\). by experimentation I've figured out that
\(\mathrm{D}=\mathrm{A} + (\mathrm{C}-\mathrm{B})=\mathrm{C} +
(\mathrm{A}-\mathrm{B})\).

#+NAME: rect-4pt
#+BEGIN_SRC scheme -n :eval no-export :results silent
;;   AB = width
;;(0,1) (1,1)
;; A-----B
;; |     | BC = height
;; D-----C
;;(0,0) (1,0)
;; could be rotated any direction
<<square>>
<<make-point>>
(define (make-rect a b c)
  (cons (cons a b) c))
(define (rect-a R)
  (caar R))
(define (rect-b R)
  (cdar R))
(define (rect-c R)
  (cdr R))
;(define (rect-d R)
;  (make-point (x-point (rect-a R))
;              (y-point (rect-c R))))
;; Wait, this won't work if the rectangle is angled.

(define (sub-points a b)
  (make-point (- (x-point a)
                 (x-point b))
              (- (y-point a)
                 (y-point b))))

(define (add-points a b)
  (make-point (+ (x-point a)
                 (x-point b))
              (+ (y-point a)
                 (y-point b))))

(define (rect-d R)
  (let ((a (rect-a R))
        (b (rect-b R))
        (c (rect-c R)))
    (add-points a
                (sub-points c b))))
(define (rect-d-alt R) ; should be mathematically identical.
  (let ((a (rect-a R))
        (b (rect-b R))
        (c (rect-c R)))
    (add-points c
                (sub-points a b))))

;; this is incorrect
;(define (length-points a b)
;  (let ((diffP (sub-points a b)))
;    (+ (abs (x-point diffP))
;       (abs (y-point diffP)))))
(define (length-points a b)
  (let ((ax (x-point a))
        (ay (y-point a))
        (bx (x-point b))
        (by (y-point b)))
    (sqrt (+ (square (- ax bx))
          (square (- ay by))))))

(define (rect-height R)
  (abs (length-points (rect-b R)
                 (rect-c R))))
(define (rect-width R)
  (abs (length-points (rect-b R)
                 (rect-a R))))

(define (length-segment seg)
  (abs (length-points (start-segment seg)
                 (end-segment seg))))
#+end_src

#+NAME: rect-test
#+BEGIN_SRC scheme -n :eval no-export :results output :exports both
(load "mattcheck2.scm")

<<rect-4pt>>
<<rect-area-peri>>

(let* ((a (make-point 13 14))
       (b (make-point 14 14))
       (c (make-point 14 13))
       (d (make-point 13 13))
       (ABC (make-rect a b c))
       (CDA (make-rect c d a))
       (w (make-point -2.0 -2.0))
       (x (make-point -0.5 -0.5))
       (y (make-point -1.5 0.5))
       (z (make-point -3.0 -1.0))
       (WXY (make-rect w x y)))
  (mattcheck "make-rect"
             ABC
             (cons (cons a b) c))
  (mattcheck "rect-d and rect-d-alt (ABCD)"
             (rect-d ABC)
             (rect-d-alt ABC)
             d)
  (mattcheck "rect-d and rect-d-alt (CDAB)"
             (rect-d CDA)
             (rect-d-alt CDA)
             b)
  (mattcheck "rect-d and rect-d-alt (WXYZ)"
             (rect-d WXY)
             (rect-d-alt WXY)
             z)
  (mattcheck "rect-d and rect-d-alt (XYZW)"
             (rect-d (make-rect x y z))
             w)
  (mattcheck "rect-height ABC"
             (rect-height ABC)
             1)
  (mattcheck "rect-width ABC"
             (rect-width ABC)
             1)
  (mattcheck "rect-height WXY"
             (rect-height WXY)
             1.4142135623730951)
  (mattcheck "rect-width WXY"
             (rect-width WXY)
             2.1213203435596424)
  (mattcheck "rect-area ABCD"
             (rect-area ABC)
             (rect-area CDA)
             1)
  (mattcheck "rect-area WXYZ"
             (rect-area WXY)
             3.0)
  (mattcheck "rect-peri ABCD"
             (rect-peri ABC)
             4)
  (mattcheck "rect-peri WXYZ"
             (rect-peri WXY)
             7.0710678118654755))
#+end_src

#+RESULTS[1230dad0b67bba1d7069d74c6482009dd4cd5d37]: rect-test
#+begin_EXAMPLE
SUCCEED at make-rect
SUCCEED at rect-d and rect-d-alt (ABCD)
SUCCEED at rect-d and rect-d-alt (CDAB)
SUCCEED at rect-d and rect-d-alt (WXYZ)
SUCCEED at rect-d and rect-d-alt (XYZW)
SUCCEED at rect-height ABC
SUCCEED at rect-width ABC
SUCCEED at rect-height WXY
SUCCEED at rect-width WXY
SUCCEED at rect-area ABCD
SUCCEED at rect-area WXYZ
SUCCEED at rect-peri ABCD
SUCCEED at rect-peri WXYZ
#+end_EXAMPLE

*** Answer 2

My second implementation will be of a rectangle as an origin, height, width, and
angle. Basically, height and width are two vectors originating from origin, with
width going straight right and height offset \(90\deg\) from width. Angle is
added during conversion from Polar to Cartesian coordinates. In relation to my
1st implementation, point D is where the origin is.
#+NAME: rect-ohwa
#+BEGIN_SRC scheme -n :eval no-export :results silent :session scheme
<<make-point>>
;; origin is a (make-point), hwa are floats
(define (make-rect origin height width angle)
  (cons (cons origin height)
        (cons width angle)))

(define (rect-origin R)
  (caar R))
(define rect-d rect-origin)
(define (rect-height R)
  (cdar R))
(define (rect-width R)
  (cadr R))
(define (rect-angle R)
  (cddr R))

;; I underestimated how much math this would take.
(define (add-points a b)
  (make-point (+ (x-point a)
                 (x-point b))
              (+ (y-point a)
                 (y-point b))))

(define pi (* 4 (atan 1.0)))
(define (radian deg)
  (* deg (/ pi 180.0)))
(define (vector-to-xy distance angle)
      ;; rect-c: (cos(Theta),sin(Theta)) * width
      (make-point (* (cos (radian angle))
                     distance)
                  (* (sin (radian angle))
                     distance)))
      ;; could also be rotated by 90 degrees just by using
      ;;   (-sin(Theta),cos(Theta)) * height
(define (rect-c R)
  (add-points
   (rect-origin R)
   (vector-to-xy (rect-width R) (rect-angle R))))
(define (rect-a R)
  (add-points
   (rect-origin R)
   (vector-to-xy (rect-height R)
                 (+ 90 (rect-angle R)))))
(define (rect-b R)
  (add-points
   (rect-origin R)
   (add-points
    (vector-to-xy (rect-width R) (rect-angle R))
    (vector-to-xy (rect-height R)
                  (+ 90 (rect-angle R))))))
#+end_src

#+NAME: rect-test2
#+BEGIN_SRC scheme -n :eval no-export :results output :exports both
(load "mattcheck2.scm")

<<rect-ohwa>>
<<rect-area-peri>>

(let* ((a (make-point 13.0 14.0))
       (b (make-point 14.0 14.0))
       (c (make-point 14.0 13.0))
       (d (make-point 13.0 13.0))
       (ABC (make-rect d 1 1 0))
       (CDA (make-rect b 1 1 180))
       (w (make-point -2.0 -2.0))
       (x (make-point -2.5 1.5))
       (y (make-point -1.5 0.5))
       (z (make-point -3.0 -1.0))
       (wxy-height 1.4142135623730951)
       (wxy-width 2.1213203435596424)
       (WXY (make-rect z wxy-height wxy-width 45)))
  (mattcheck "make-rect"
             ABC
             (cons (cons d 1) (cons 1 0)))
  (mattcheck "rect-b (ABCD)"
             (rect-b ABC)
             b)
  (mattcheck "rect-b (CDAB)"
             (rect-b CDA)
             d)
  (mattcheck "rect-b (WXYZ)"
             (rect-b WXY)
             x)
  (mattcheck "rect-height"
             (rect-height WXY)
             wxy-height)
  (mattcheck "rect-width"
             (rect-width WXY)
             wxy-width)
  (mattcheck "rect-area ABCD"
             (rect-area ABC)
             (rect-area CDA)
             1)
  (mattcheck "rect-area WXYZ"
             (rect-area WXY)
             3.0)
  (mattcheck "rect-peri ABCD"
             (rect-peri ABC)
             4)
  (mattcheck "rect-peri WXYZ"
             (rect-peri WXY)
             7.0710678118654755))
#+end_src

#+RESULTS[68186716ddc449e54bf88d08c60cbf7256e70641]: rect-test2
#+begin_EXAMPLE
SUCCEED at make-rect
SUCCEED at rect-b (ABCD)
SUCCEED at rect-b (CDAB)
SUCCEED at rect-b (WXYZ)
SUCCEED at rect-height
SUCCEED at rect-width
SUCCEED at rect-area ABCD
SUCCEED at rect-area WXYZ
SUCCEED at rect-peri ABCD
SUCCEED at rect-peri WXYZ
#+end_EXAMPLE

** 2.1.3: What Is Meant by Data?

We can consider data as being a collection of selectors and constructors,
together with specific conditions that these procedures must fulfill in order to
be a valid representation. For example, in the case of our rational number
implementation, for rational number \(x\) made with numerator \(n\) and
denominator \(d\), dividing the result of src_scheme{(numer x)} over the result
of src_scheme{(denom x)} should be equivalent to dividing \(n\) over \(d\).

**  Exercise 2.4

*** Question

#+begin_quote
Here is an alternative procedural representation of pairs. For this
representation, verify that src_scheme{(car (cons x y))} yields ~x~ for any
objects ~x~ and ~y~.
#+end_quote

#+NAME: alt-pairs-txt
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (cons x y)
  (lambda (m) (m x y)))
(define (car z)
  (z (lambda (p q) p)))
#+END_SRC

#+begin_quote
What is the corresponding definition of ~cdr~? (Hint: To verify that this works,
make use of the substitution model of 1.1.5.)
#+end_quote

*** Answer

First, let's explain with the substitution model.
#+BEGIN_SRC scheme -n :eval no-export :results silent
(cons 0 1)
(lambda (m) (m 0 1))

(car (lambda (m) (m 0 1)))
((lambda (m) (m 0 1)) (lambda (p q) p))
(lambda (0 1) 0)
0
(cdr (lambda (m) (m 0 1)))
((lambda (m) (m 0 1)) (lambda (p q) q))
(lambda (0 1) 1)
1
#+END_SRC

Now for implementation.
#+NAME: alt-pairs
#+BEGIN_SRC scheme -n :eval no-export :results output :exports both
(load "mattcheck2.scm")
<<alt-pairs-txt>>
(define (cdr z)
  (z (lambda (p q) q)))

(let ((pair (cons 0 1)))
  (mattcheck "car"
             (car pair)
             0)
  (mattcheck "cdr"
             (cdr pair)
             1))
#+END_SRC

#+RESULTS[24aebdc670f62e62b39d29c568b3e881d59dbcf1]: alt-pairs
#+begin_EXAMPLE
| (0 . 0) | (0 . 1) | (0 . 2) | (0 . 3) | (0 . 4) | (0 . 5) | (0 . 6) |
| (1 . 0) | (1 . 1) | (1 . 2) | (1 . 3) | (1 . 4) | (1 . 5) | (1 . 6) |
| (2 . 0) | (2 . 1) | (2 . 2) | (2 . 3) | (2 . 4) | (2 . 5) | (2 . 6) |
| (3 . 0) | (3 . 1) | (3 . 2) | (3 . 3) | (3 . 4) | (3 . 5) | (3 . 6) |
| (4 . 0) | (4 . 1) | (4 . 2) | (4 . 3) | (4 . 4) | (4 . 5) | (4 . 6) |
| (5 . 0) | (5 . 1) | (5 . 2) | (5 . 3) | (5 . 4) | (5 . 5) | (5 . 6) |
| (6 . 0) | (6 . 1) | (6 . 2) | (6 . 3) | (6 . 4) | (6 . 5) | (6 . 6) |
#+end_EXAMPLE

**  Exercise 2.5 :optional:

*** Question

#+begin_quote
Show that we can represent pairs of nonnegative integers using only numbers and
arithmetic operations if we represent the pair \(a\) and \(b\) as the integer
that is the product \(2^a 3^b\). Give the corresponding definitions of the
procedures ~cons~, ~car~, and ~cdr~.
#+end_quote

*** Answer

This one really blew my mind inside-out when I first did it. Basically, because
the two numbers are coprime, you can factor out the unwanted number and be left
with the desired one.

#+begin_quote
Where \(x\) is the scrambled number, \(p\) is the base we want to remove, \(q\)
is the base we want to retrieve from and \(y\) is the value exponentiating
\(p\), the original number is retrieved by dividing \(x\) by \(p\) for \(y\)
number of times, and then applying \(\log_{q}\) to the result.
#+end_quote

First, let's make ~cons~.
#+NAME: cons-nnint
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (cons-nnint a b)
  (* (expt 2 a) (expt 3 b)))
(define (cons-nnint-debug a b) ;; DEBUG
  (let* ((aa (expt 2 a))
         (bb (expt 3 b))
         (ab (* aa bb)))
    (display aa)
    (newline)
    (display bb)
    (newline)
    (display ab)
    (newline)
    ab))
#+END_SRC

Also, Guile doesn't have a function for custom logs so let's define that now.
#+NAME: logn
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (logn b p)
  (/ (log p) (log b)))
#+END_SRC

Let's do some analysis to see how these numbers are related.
#+NAME: 2-5-table
#+BEGIN_SRC scheme -n :eval no-export :results value table :exports both :wrap
<<cons-nnint>>
(let*
    ((tablesize 7)
     (inputs (map (λ(x)
                    (map (λ(y)
                           (cons x y))
                         (iota tablesize)))
                  (iota tablesize)))
     (outputs (map (λ(row)
                     (map (λ(col)
                            (cons-nnint (car col) (cdr col)))
                          row))
                   inputs)))
  outputs)
#+END_SRC

#+RESULTS[f749743950b6e317a8e20ab5b434c3bdb7a358c4]: 2-5-table
|  1 |   3 |   9 |   27 |   81 |   243 |   729 |
|  2 |   6 |  18 |   54 |  162 |   486 |  1458 |
|  4 |  12 |  36 |  108 |  324 |   972 |  2916 |
|  8 |  24 |  72 |  216 |  648 |  1944 |  5832 |
| 16 |  48 | 144 |  432 | 1296 |  3888 | 11664 |
| 32 |  96 | 288 |  864 | 2592 |  7776 | 23328 |
| 64 | 192 | 576 | 1728 | 5184 | 15552 | 46656 |

Here are our scrambled numbers. 

#+NAME: 2-5-table2
#+BEGIN_SRC scheme -n :eval no-export :results value table :exports both :var data=2-5-table
;; To find a number of some base in some column,
;; First divide by unwantedbase for targetcol number of times
<<repeated>>
(let ((targetcol 2)
      (unwantedbase 3))
  (map (λ(row)
         (map (λ(item)
                ((repeated (λ(x) 
                             (/ x unwantedbase)) targetcol)
                 item))
                row))
       data))
#+END_SRC

#+RESULTS[0c7b79127cc7f944c0915bac19a6e5275cd87389]: 2-5-table2
| 1/9  | 1/3  |  1 |   3 |   9 |   27 |   81 |
| 2/9  | 2/3  |  2 |   6 |  18 |   54 |  162 |
| 4/9  | 4/3  |  4 |  12 |  36 |  108 |  324 |
| 8/9  | 8/3  |  8 |  24 |  72 |  216 |  648 |
| 16/9 | 16/3 | 16 |  48 | 144 |  432 | 1296 |
| 32/9 | 32/3 | 32 |  96 | 288 |  864 | 2592 |
| 64/9 | 64/3 | 64 | 192 | 576 | 1728 | 5184 |

The numbers from our target column onwards are integers, with the target column
being linearly exponentiated by 2 because the original numbers were linear.

#+NAME: 2-5-table3
#+BEGIN_SRC scheme -n :eval no-export :results value table :exports both :var data=2-5-table2
<<logn>>
(let ((wantedbase 2))
  (map (λ(row)
         (map (λ(item)
                (format #f "~6,3f" (logn 2 item)))
                row))
       data))
#+END_SRC

#+RESULTS[36dd324367b48addac3960ee0675f28de84481b0]: 2-5-table3
| -3.170 | -1.585 | 0.000 | 1.585 | 3.170 |  4.755 |  6.340 |
| -2.170 | -0.585 | 1.000 | 2.585 | 4.170 |  5.755 |  7.340 |
| -1.170 |  0.415 | 2.000 | 3.585 | 5.170 |  6.755 |  8.340 |
| -0.170 |  1.415 | 3.000 | 4.585 | 6.170 |  7.755 |  9.340 |
|  0.830 |  2.415 | 4.000 | 5.585 | 7.170 |  8.755 | 10.340 |
|  1.830 |  3.415 | 5.000 | 6.585 | 8.170 |  9.755 | 11.340 |
|  2.830 |  4.415 | 6.000 | 7.585 | 9.170 | 10.755 | 12.340 |

Now the second column has recovered its original values. Although we didn't know
what the original integer values were, we can now tell which column has the
correct numbers by looking at which are integer values.

We can use this sign of a correct result in the proposed ~car~ and ~cdr~ procedures.

#+NAME: nnint-test
#+BEGIN_SRC scheme -n :eval no-export :results value table :exports both
<<cons-nnint>>
<<logn>>
(use-srfis '(1))
(define (all-your-base ab unwanted wanted)
  (if (equal? (modulo ab unwanted) 0)
      (all-your-base (/ ab unwanted) unwanted wanted)
      (if (equal? (modulo ab wanted) 0)
          (round (logn wanted ab))
          "This number isn't a factor!")))
(define (car-nnint ab)
  (all-your-base ab 3 2))
(define (cdr-nnint ab)
  (all-your-base ab 2 3))

(let* ((initvalues '((2 3) (4 5) (7 2)))
       (conslist (map (λ(x)
                        (apply cons-nnint x))
                      initvalues))
       (carlist (map (λ(x)
                       (car-nnint x))
                     conslist))
       (cdrlist (map (λ(x)
                       (cdr-nnint x))
                     conslist)))
  (map (λ(x y) (cons x y))
       (list "pairs" "cons'd" "car" "cdr")
       (list initvalues conslist carlist cdrlist)))
#+END_SRC

#+RESULTS[93e78e368bd1c1d5d50a5e2d73888ee2e23a409c]: nnint-test
| pairs  | (2 3) | (4 5) | (7 2) |
|--------+-------+-------+-------|
| cons'd |   108 |  3888 |  1152 |
| car    |   2.0 |   4.0 |   7.0 |
| cdr    |   3.0 |   5.0 |   2.0 |

**  Exercise 2.6 :optional:

*** Question

#+begin_quote
In case representing pairs as procedures wasn't mind-boggling enough, consider
that, in a language that can manipulate procedures, we can get by without
numbers (at least insofar as nonnegative integers are concerned) by implementing
0 and the operation of adding 1 as
#+end_quote

#+NAME: lc-zero-add1
#+BEGIN_SRC scheme -n :eval no-export
(define zero (λ (f) (λ (x) x)))
(define (add-1 n)
  (λ (f) (λ (x) (f ((n f) x)))))
#+END_SRC

#+begin_quote
This representation is known as /Church numerals/, after its inventor, Alonzo
Church, the logician who invented the \lambda-calculus.

Define src_scheme{one} and src_scheme{two} directly (not in terms of
src_scheme{zero} and src_scheme{add-1}). (Hint: Use substitution to evaluate
src_scheme{(add-1 zero)}). Give a direct definition of the addition procedure
src_scheme{+} (not in terms of repeated application of src_scheme{add-1}).
#+end_quote

*** Answer

First, let's check out src_scheme{(add-1 zero)}.
#+BEGIN_SRC scheme -n
(define zero (λ (f) (λ (x) x)))
(define (add-1 n)
  (λ (f) (λ (x)
           (f ((n f) x)))))

(add-1 zero)
((λ (f) (λ (x)
          (f ((zero f) x)))))
((λ (f) (λ (x)
          (f ((λ (x) x) x)))))
((λ (f) (λ (x)
          (f x))))
#+END_SRC

So from this I believe the correct definition of one and two are:
#+BEGIN_SRC scheme -n :eval no-export :exports both
(load "mattcheck2.scm")
(define one
  (λ (f) (λ (x)
           (f x))))
(define two
  (λ (f) (λ (x)
            (f (f x)))))

(mattcheck "1 = 1+0"
           1
           ((one 1+) 0))
(mattcheck "2 = 1+1+0"
           2
           ((two 1+) 0))

(define (add a b)
  (λ (f) (λ (x)
           ((a f) ((b f) x)))))

(mattcheck "3 = 1+2 = (1+0) + (1+1+0)"
           3
           (((add one two) 1+) 0))
#+END_SRC

#+RESULTS[12c88e9dd92087809182a4956164401f3dd5dd37]:
#+begin_EXAMPLE
SUCCEED at 1 = 1+0
SUCCEED at 2 = 1+1+0
SUCCEED at 3 = 1+2 = (1+0) + (1+1+0)
#+end_EXAMPLE

**  Exercise 2.7

*** Text

#+NAME: interval-txt
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))
(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
(define (div-interval x y)
  (mul-interval
   x
   (make-interval (/ 1.0 (upper-bound y))
                  (/ 1.0 (lower-bound y)))))
#+END_SRC

*** Question

#+begin_quote
Alyssa's program is incomplete because she has not specified the implementation
of the interval abstraction. Here is a definition of the interval constructor:
#+end_quote

#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (make-interval a b) (cons a b))
#+END_SRC

#+begin_quote
Define selectors ~upper-bound~ and ~lower-bound~ to complete the
implementation.
#+end_quote

*** Answer

#+NAME: make-interval
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<interval-txt>>

;; Makes more sense to me to test
;; order in the constructor than selector
(define (make-interval a b)
  (if (> a b)
      (cons a b)
      (cons b a)))

(define (upper-bound i)
  (car i))
(define (lower-bound i)
  (cdr i))
#+END_SRC

**  Exercise 2.8

*** Question

#+begin_quote
Using reasoning analogous to Alyssa's, describe how the difference of two
intervals may be computed. Define a corresponding subtraction procedure, called
~sub-interval~.
#+end_quote

*** Answer

I would argue that with one interval subtracted from the other, the lowest
possible value is the lower of the first subtracted from the /upper/ of the
second, and the highest is the upper of the first subtracted from the lower of
the second.
#+NAME: sub-interval
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (sub-interval x y)
  (make-interval (- (lower-bound x) (upper-bound y))
                 (- (upper-bound x) (lower-bound y))))
#+END_SRC

**  Exercise 2.9

*** Question
#+begin_quote
The /width/ of an interval is half of the difference between its upper and lower
bounds. The width is a measure of the uncertainty of the number specified by the
interval. For some arithmetic operations the width of the result of combining
two intervals is a function only of the widths of the argument intervals,
whereas for others the width of the combination is not a function of the widths
of the argument intervals. Show that the width of the sum (or difference) of two
intervals is a function only of the widths of the intervals being added (or
subtracted). Give examples to show that this is not true for multiplication or
division.
#+end_quote

*** Answer

My first interpretation of the question was that it asked whether width
operations are /distributive/. For example, multiplication is distributive:

\[
  a(b+c) = (a \times b)+(a \times c)
\]

For this I wrote the following tests:

#+NAME: interval-width
#+BEGIN_SRC scheme -n :eval no-export :results output
(load "mattcheck2.scm")
<<make-interval>>
<<sub-interval>>

(define (halve x)
  (/ x 2))

(define (width-interval I)
  (halve (- (upper-bound I)
            (lower-bound I))))

(let* ((ia (make-interval 10.1 9.9))
       (ib (make-interval 5.2 4.8))
       (Aab (add-interval ia ib))
       (Sab (sub-interval ia ib))
       (Mab (mul-interval ia ib))
       (Dab (div-interval ia ib)))
  (mattcheck-float "ia width = roughly .1"
                   0.1
                   (width-interval ia))
  (mattcheck-float "ib width = roughly .2"
                   0.2
                   (width-interval ib))
  (mattcheck-float "width addition is distributive"
                   (width-interval Aab)
                   (+ (width-interval ia)
                      (width-interval ib)))
  (mattcheck-float "width subtraction is distributive"
                   (width-interval Sab)
                   (- (width-interval ia)
                      (width-interval ib)))
  (mattcheck-float "width multiplication is distributive"
                   (width-interval Mab)
                   (* (width-interval ia)
                      (width-interval ib)))
  (mattcheck-float "width division is distributive"
                   (width-interval Dab)
                   (/ (width-interval ia)
                      (width-interval ib))))
#+END_SRC

#+RESULTS[fd604189d7982cfc00149ec25da8bbcd60053aa1]: interval-width
#+begin_EXAMPLE
<unknown-location>: warning: possibly unbound variable `mattcheck-float'
SUCCEED at ia width = roughly .1
SUCCEED at ib width = roughly .2
SUCCEED at width addition is distributive
FAIL at width subtraction is distributive
expected: -0.10000000000000053
returned: 0.2999999999999998
FAIL at width multiplication is distributive
expected: 0.01999999999999995
returned: 2.5
FAIL at width division is distributive
expected: 0.4999999999999978
returned: 0.10016025641025639
#+end_EXAMPLE

However upon rereading the question I see that it could be rephrased as "in what
operations can you calculate the resulting interval's width with only the widths
of the argument intervals?"

Basically, for argument interval \(x\) and \(y\) and result interval \(z\):

#+begin_quote
=IF= \(z = x + y\) \\
=THEN= \(z_{width} = x_{width} + y_{width}\) \\
=IF= \(z = x - y\) \\
=THEN= \(z_{width} = x_{width} + y_{width}\) \\
Multiplied or divided widths cannot be determined from widths alone.
#+end_quote

So, let's try that again.

#+NAME: interval-operations
#+BEGIN_SRC scheme -n :eval no-export :results output
(load "mattcheck2.scm")
<<make-interval>>
<<sub-interval>>

(define (halve x)
  (/ x 2))

(define (width-interval I)
  (halve (- (upper-bound I)
            (lower-bound I))))

(let* ((ia (make-interval 10.1 9.9))
       (ib (make-interval 5.2 4.8))
       (Aab (add-interval ia ib))
       (Sab (sub-interval ia ib)))
  (mattcheck-float "ia width = roughly .1"
                   0.1
                   (width-interval ia))
  (mattcheck-float "ib width = roughly .2"
                   0.2
                   (width-interval ib))
  (mattcheck-float "width(ia+ib) = width(ia) + width(ib)"
                   (width-interval Aab)
                   (+ (width-interval ia)
                      (width-interval ib)))
  (mattcheck-float "width(ia-ib) = width(ia) + width(ib)"
                   (width-interval Sab)
                   (+ (width-interval ia)
                      (width-interval ib))))
#+END_SRC

#+RESULTS[4b92c98c1711878ce321a2a589bb65308d703ad6]: interval-operations
#+begin_EXAMPLE
SUCCEED at ia width = roughly .1
SUCCEED at ib width = roughly .2
SUCCEED at width(ia+ib) = width(ia) + width(ib)
SUCCEED at width(ia-ib) = width(ia) + width(ib)
#+end_EXAMPLE

**  Exercise 2.10

*** Question

#+begin_quote
Ben Bitdiddle, an expert systems programmer, looks over Alyssa's shoulder and
comments that it is not clear what it means to divide by an interval that spans
zero. Modify Alyssa's code to check for this condition and to signal an error if
it occurs.
#+end_quote

*** Answer

#+BEGIN_SRC scheme -n
(define (interval-spans-zero? I)
  (and (> upper-bound 0)
       (< lower-bound 0)))
(define (div-interval x y)
  (if (interval-spans-zero? y)
      "DIV-INTERVAL ERROR: denominator spans zero"
      (mul-interval
       x
       (make-interval (/ 1.0 (upper-bound y))
                      (/ 1.0 (lower-bound y))))))
#+END_SRC

**  Exercise 2.11

*** Question

#+begin_quote
In passing, Ben also cryptically comments: ``By testing the signs of the
endpoints of the intervals, it is possible to break src_scheme{mul-interval}
into nine cases, only one of which requires more than two multiplications.''
Rewrite this procedure using Ben's suggestion.
#+end_quote

*** Answer

This problem doesn't appear to have a beautiful, elegant answer.

Let's examine the nine cases.

#+NAME: checking-multiples
#+BEGIN_SRC scheme -n :eval no-export :results value table
(use-modules (ice-9 format))
(use-srfis '(1))
(load "mattcheck2.scm")
<<make-interval>>
<<sub-interval>>

(define (matt-examine-mult f)
  (let* ((pp (make-interval 3 2))
         (pn (make-interval 3 -5))
         (pn2 (make-interval 1 -0.5))
         (nn (make-interval -5 -7))
         (listofpairs (list
                       (list pp pp)
                       (list pp pn)
                       (list pp nn)
                       (list pn pp)
                       (list pn pn)
                       (list pn pn2) ;;<- edge case to catch incomplete
                       (list pn nn)  ;;   multiplication functions
                       (list nn pp)
                       (list nn pn)
                       (list nn nn)))
         (givesign (λ(x)
                     (if (negative? x)
                         "-"
                         "+")))
         (print-sign (λ(I)
                       (format #f "~a ~a"
                               (givesign (upper-bound I))
                               (givesign (lower-bound I)))))
         (print-int (λ(I)
                      (format #f "~a/~a"
                              (upper-bound I)
                              (lower-bound I))))
         (print-ints (λ(I J)
                       (format #f "~a times ~a"
                               (print-int I)
                               (print-int J))))
         (results (map (λ(p)
                         (apply f p))
                       listofpairs)))
    (list
     (map (λ(p)
            (apply print-ints p))
          listofpairs)
     (map print-int results)
     (map (λ(I)
            (print-sign I))
          results)
     (map (λ(p)
            (format #f "~a // ~a"
                    (print-sign (car p))
                    (print-sign (cadr p))))
          listofpairs))))
(cons
 (list "problem" "result" "signs" "problem signs")
 (apply zip 
        (matt-examine-mult mul-interval)))
#+END_SRC

#+RESULTS[eb1646265584f59fe337c3987aebbcc0a224664e]: checking-multiples
| problem           | result   | signs | problem signs |
|-------------------+----------+-------+---------------|
| 3/2 times 3/2     | 9/4      | + +   | + + // + +    |
| 3/2 times 3/-5    | 9/-15    | + -   | + + // + -    |
| 3/2 times -5/-7   | -10/-21  | - -   | + + // - -    |
| 3/-5 times 3/2    | 9/-15    | + -   | + - // + +    |
| 3/-5 times 3/-5   | 25/-15   | + -   | + - // + -    |
| 3/-5 times 1/-0.5 | 3.0/-5.0 | + -   | + - // + -    |
| 3/-5 times -5/-7  | 35/-21   | + -   | + - // - -    |
| -5/-7 times 3/2   | -10/-21  | - -   | - - // + +    |
| -5/-7 times 3/-5  | 35/-21   | + -   | - - // + -    |
| -5/-7 times -5/-7 | 49/25    | + +   | - - // - -    |

#+NAME: mul-interval-opt
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (mul-interval-opt x y)
  (let ((xu (upper-bound x))
        (xl (lower-bound x))
        (yu (upper-bound y))
        (yl (lower-bound y)))
    (define p? positive?)
    (define n? negative?)
    (define (check-signs? a b x y) ;; pass functions
      (and (a xu)
           (b xl)
           (x yu)
           (y yl)))
    (define (same-signs?)
      (or (check-signs? p? p? p? p?)
          (check-signs? n? n? n? n?)))
    (define (alt-signs?)
      (or (check-signs? p? p? n? n?)
          (check-signs? n? n? p? p?)))
    (cond ((same-signs?)
           (make-interval (* xu yu)
                          (* xl yl)))
          ((alt-signs?)
           (make-interval (* xl yu)
                          (* xu yl)))
          ((check-signs? p? p? p? n?)
           (make-interval (* xu yu)
                          (* xu yl)))
          ((check-signs? p? n? p? p?)
           (make-interval (* xu yu)
                          (* xl yu)))
          ((check-signs? p? n? p? n?)
           (let ((p1 (* xu yu))
                 (p2 (* xu yl))
                 (p3 (* xl yu))
                 (p4 (* xl yl)))
             (make-interval (max p1 p2 p3 p4)
                            (min p1 p2 p3 p4))))
          ((check-signs? p? n? n? n?)
           (make-interval (* xl yl)
                          (* xu yl)))
          ((check-signs? n? n? p? n?)
           (make-interval (* xl yl)
                          (* xl yu))))))
#+END_SRC

#+NAME: checking-optimized
#+BEGIN_SRC scheme -n :eval no-export :results output
(use-modules (ice-9 format))
(use-srfis '(1))
(load "mattcheck2.scm")
<<make-interval>>
<<sub-interval>>
<<mul-interval-opt>>

(define (matt-mult-consistency f1 f2)
  (let* ((pp (make-interval 3 2))
         (pn (make-interval 3 -5))
         (pn2 (make-interval 1 -0.5))
         (nn (make-interval -5 -7))
         (listofpairs (list
                       (list "pp*nn" pp pp)
                       (list "pp*pn" pp pn)
                       (list "pp*nn" pp nn)
                       (list "pn*pp" pn pp)
                       (list "pn*pn" pn pn)
                       (list "pn*pn2" pn pn2) ;;<- edge case to catch incomplete
                       (list "pn*nn" pn nn)  ;;   multiplication functions
                       (list "nn*pp" nn pp)
                       (list "nn*pn" nn pn)
                       (list "nn*nn" nn nn))))
    (map (λ(l)
           (mattcheck (car l)
                      (apply f1 (cdr l))
                      (apply f2 (cdr l))))
         listofpairs)))

(matt-mult-consistency mul-interval mul-interval-opt)
#+END_SRC

#+RESULTS[b10bdc030d52d0922553653de7d1c79c8080a0af]: checking-optimized
#+begin_EXAMPLE
SUCCEED at pp*nn
SUCCEED at pp*pn
SUCCEED at pp*nn
SUCCEED at pn*pp
SUCCEED at pn*pn
SUCCEED at pn*pn2
SUCCEED at pn*nn
SUCCEED at nn*pp
SUCCEED at nn*pn
SUCCEED at nn*nn
#+end_EXAMPLE

#+NAME: mult-benchmark
#+BEGIN_SRC scheme -n :noeval :results output :exports results :tangle 2/Ex11-bench.scm
(define iters 10000000)
(load "../mattbench.scm")
<<make-interval>>
<<sub-interval>>
<<mul-interval-opt>>
(let* ((pp (make-interval 3 2))
       (pn (make-interval 3 -5))
       (pn2 (make-interval 1 -0.5))
       (nn (make-interval -5 -7))
       (listofpairs (list
                     (list pp pp)
                     (list pp pn)
                     (list pp nn)
                     (list pn pp)
                     (list pn pn)
                     (list pn pn2) ;;<- edge case to catch incomplete
                     (list pn nn)  ;;   multiplication functions
                     (list nn pp)
                     (list nn pn)
                     (list nn nn))))
  (format #t "Unoptimized mul-interval: ~a"
          (cdr (mattbench2 (λ()
                             (map (λ(l)
                                    (apply mul-interval l))
                                  listofpairs))
                           iters)))
  (format #t "Unoptimized mul-interval: ~a"
          (cdr (mattbench2 (λ()
                             (map (λ(l)
                                    (apply mul-interval-opt l))
                                  listofpairs))
                           iters)))
  )
#+END_SRC

#+RESULTS: mul-benchmark
#+BEGIN_EXAMPLE
Unoptimized mul-interval: (5231.8421225)
Optimized mul-interval: (2526.5896437)
#+END_EXAMPLE

So as expected, about twice as fast!

**  Exercise 2.12

*** Question

After debugging her program, Alyssa shows it to a potential user, who complains
that her program solves the wrong problem. He wants a program that can deal with
numbers represented as a center value and an additive tolerance; for example, he
wants to work with intervals such as \(3.5 \pm 0.15\) rather than [3.35, 3.65].
Alyssa returns to her desk and fixes this problem by supplying an alternate
constructor and alternate selectors:

#+NAME: interval-center-width
#+BEGIN_SRC scheme -n
(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))
(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))
(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))
#+END_SRC

Unfortunately, most of Alyssa's users are engineers. Real engineering situations
usually involve measurements with only a small uncertainty, measured as the
ratio of the width of the interval to the midpoint of the interval. Engineers
usually specify percentage tolerances on the parameters of devices, as in the
resistor specifications given earlier.

Define a constructor src_scheme{make-center-percent} that takes a center and a
percentage tolerance and produces the desired interval. You must also define a
selector src_scheme{percent} that produces the percentage tolerance for a given
interval. The src_scheme{center} selector is the same as the one shown above.

*** Answer

#+NAME: reciprocal
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (reciprocal x)
  (/ 1 x))
#+END_SRC
#+NAME: interval-percent
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<reciprocal>>
<<make-interval>>
<<sub-interval>>
<<interval-center-width>>

(define (make-center-percent c pt)
  (let ((pp (* c
               (* pt 0.01))))
    (make-interval (- c pp) (+ c pp))))
(define (percent I)
  (* 100.0
     (/ (width I)
        (center I))))
#+END_SRC

#+NAME: checking-interval-percent
#+BEGIN_SRC scheme -n :eval no-export :results output
<<interval-percent>>
(load "mattcheck2.scm")
  (define (roughly-eq? a b)
    ;; error size varies with magnitude of fp
    ;; so dx must vary too.
    (define dx (* a 0.000001))
    (and (> a (- b dx))
         (< a (+ b dx))))
(define (interval-roughly-eq? I J)
  (and (roughly-eq? (upper-bound I) (upper-bound J))
       (roughly-eq? (lower-bound I) (lower-bound J))))

(let* ((i1 (make-interval 105.0 95.0))
      (i2 (make-center-width 100.0 5))
      (i3 (make-center-percent 100.0 5))
      (i1a (upper-bound i1)))
  (mattcheck "make-center-width"
             i1
             i2)
  (mattcheck "make-center-percent"
             i1
             i3)
  (mattcheck "percent"
             (percent i1)
             (percent i3)
             5.0)
  (mattcheck+ "make-center-percent is consistent"
              (list i1 i3)
              #:eql? interval-roughly-eq?))
#+END_SRC

#+RESULTS[805f7bbb69cfddbd7c91eedb1bd952a41877fe7f]: checking-interval-percent
#+begin_EXAMPLE
SUCCEED at make-center-width
SUCCEED at make-center-percent
SUCCEED at percent
SUCCEED at make-center-percent is consistent
#+end_EXAMPLE

**  Exercise 2.13 :optional:

*** Question

#+begin_quote
Show that under the assumption of small percentage tolerances there is a simple
formula for the approximate percentage tolerance of the product of two intervals
in terms of the tolerances of the factors. You may simplify the problem by
assuming that all numbers are positive.
#+end_quote

*** Answer

I should've written this function a while ago.
#+NAME: echo
#+BEGIN_SRC scheme -n :eval no-export :results silent
(use-modules (ice-9 format))
(define (stringit . args)
  (string-append
   (apply string-append
    (map (λ(x)
          (format #f "~a " x))
        args))))
(define (echo . args)
  (format #t "~&~a~%" (apply stringit args)))
#+END_SRC

Now, let's examine how interval percents relate to each other.

#+NAME: checking-interval-relations
#+BEGIN_SRC scheme -n :eval no-export :results output
<<echo>>
<<interval-percent>>
<<mul-interval-opt>>

(let* ((i1 (make-center-width 100 5))
       (i2 (make-center-width 200 5))
       (M12 (mul-interval-opt i1 i2)))
  (echo "intervals 1 and 2:" i1 i2)
  (echo "width of 1 and 2:" (width i1) (width i2))
  (echo "percent of 1 and 2:" (percent i1) (percent i2))
  (echo "i1*i2 = " M12)
  (echo "width M12:" (width M12))
  (echo "percent M12:" (percent M12)))
#+END_SRC

#+RESULTS[c7bf5a5d43464607ef3302188104e67ec1235c24]: checking-interval-relations
#+begin_EXAMPLE
intervals 1 and 2: (105 . 95) (205 . 195) 
width of 1 and 2: 5 5 
percent of 1 and 2: 5.0 2.5 
i1*i2 =  (21525 . 18525) 
width M12 1500 
percent M12 7.490636704119851 
#+end_EXAMPLE

Perhaps percent\((A\times B) =\)percent\((A)+\)percent\((B)\)?

#+NAME: checking-interval-relations2
#+BEGIN_SRC scheme -n :eval no-export :results output
<<echo>>
<<interval-percent>>
<<mul-interval-opt>>

(let* ((i1 (make-center-percent 40 0.1))
       (i2 (make-center-percent 200 0.4))
       (M12 (mul-interval-opt i1 i2)))
  (echo "percent of 1 and 2:" (percent i1) (percent i2))
  (echo "percent M12:" (percent M12)))
#+END_SRC

#+RESULTS[8fccf6198fb4c9f4fba0c52e6e5ec4f3bb2dd284]: checking-interval-relations2
#+begin_EXAMPLE
percent of 1 and 2: 0.09999999999999788 0.40000000000000563 
percent M12: 0.499998000008 
#+end_EXAMPLE

**  Exercise 2.14

*** Question

#+begin_quote
After considerable work, Alyssa P. Hacker delivers her finished system. Several
years later, after she has forgotten all about it, she gets a frenzied call from
an irate user, Lem E. Tweakit. It seems that Lem has noticed that the formula
for parallel resistors can be written in two algebraically equivalent ways:

\[
\frac{R_1 R_2}{R_1 + R_2}
\]

and

\[
\frac{1}{\frac{1}{R_1} + \frac{1}{R_2}}
\]

He has written the following two programs, each of which computes the
parallel-resistors formula differently:
#+end_quote

#+NAME: par-resistors
#+BEGIN_SRC scheme -n :eval no-export
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))

(define (par2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval
     one (add-interval (div-interval one r1)
                       (div-interval one r2)))))
#+END_SRC

#+begin_quote
Lem complains that Alyssa's program gives different answers for the two ways of
computing. This is a serious complaint.

Demonstrate that Lem is right. Investigate the behavior of the system on a
variety of arithmetic expressions. Make some intervals \(A\) and \(B\), and use
them in computing the expressions \(A / A\) and \(A / B\). You will get the most
insight by using intervals whose width is a small percentage of the center
value. Examine the results of the computation in center-percent form (see
Exercise 2.12).
#+end_quote

*** Answer

#+NAME: resistor-testing
#+BEGIN_SRC scheme -n :eval no-export :results output
<<echo>>
<<interval-percent>>
<<mul-interval-opt>>
<<par-resistors>>

(let* ((A (make-center-percent 10 1))
       (B (make-center-percent 10 0.01))
       (p1 (par1 A B))
       (p2 (par2 A B)))
  (echo "A,B:" A B)
  (echo "par1(A,B):" p1)
  (echo "par2(A,B):" p2)
  (echo "percent(par1):" (percent p1))
  (echo "percent(par2):" (percent p2))
  (echo "center(par1):" (center p1))
  (echo "center(par2):" (center p2)))

(echo "So these two have inconsistent effects on the width.")
(newline)
(echo "It should also be noted that floating-point errors accumulate.")
(echo "Take a look at the error on these (correct answer is 1)")

(let* ((A (make-center-percent 10 1))
       (p1 (div-interval
            (div-interval
             (mul-interval A A)
             A)
            A))
       (p2 (div-interval
            (div-interval
             (div-interval
              (mul-interval
               (mul-interval A A)
               A)
              A)
             A)
            A)))
  (echo "p1:" (center p1))
  (echo "p2:" (center p2)))
#+END_SRC

#+RESULTS[328809af4974fa00f964a66bcef767df4e52c98e]: resistor-testing
#+begin_EXAMPLE
A,B: (10.1 . 9.9) (10.001 . 9.999) 
par1(A,B): (5.076139504497713 . 4.924635590269141) 
par2(A,B): (5.025128103079449 . 4.974626865671642) 
percent(par1): 1.5149217214958663 
percent(par2): 0.5050247487625606 
center(par1): 5.000387547383427 
center(par2): 4.999877484375546 
So these two have inconsistent effects on the width. 

It should also be noted that floating-point errors accumulate. 
Take a look at the error on these (correct answer is 1) 
p1: 1.0008001600240033 
p2: 1.0018006601460259 
#+end_EXAMPLE

**  Exercise 2.15

*** Question

#+begin_quote
Eva Lu Ator, another user, has also noticed the different intervals computed by
different but algebraically equivalent expressions. She says that a formula to
compute with intervals using Alyssa's system will produce tighter error bounds
if it can be written in such a form that no variable that represents an
uncertain number is repeated. Thus, she says, src_scheme{par2} is a "better"
program for parallel resistances than src_scheme{par1}. Is she right? Why?
#+end_quote

*** Answer

If I am correct in understanding that "uncertain number" means "a number with an
error tolerance", than ~par2~ /is/ better -- it only uses two instances of
variables with error tolerance, while ~par1~ uses four.

It should be noted that this system does not directly translate to algebraic
expressions. For example, take these expressions:

\[A + A = 2A\]
\[A - A = 0\]
\[A / A = 1\]

Note that these do not hold up in practice with uncertain numbers:


#+NAME: EX2-15
#+BEGIN_SRC scheme -n :eval no-export :results output
<<echo>>
<<interval-percent>>
<<mul-interval-opt>>

(define A (make-center-percent 10 1))
(echo "A+A = 2A !=" (add-interval A A))
(echo "A-A = 0 !=" (sub-interval A A))
(echo "A/A = 1 !=" (div-interval A A))
#+END_SRC

#+RESULTS[c98481168e2d14b4c88fbfee3ca435ee9544c2eb]: EX2-15
#+begin_EXAMPLE
A+A = 2A != (20.2 . 19.8) 
A-A = 0 != (0.1999999999999993 . -0.1999999999999993) 
A/A = 1 != (1.02020202020202 . 0.9801980198019803) 
#+end_EXAMPLE

**  Exercise 2.16 :optional:

*** Question

#+begin_quote
Explain, in general, why equivalent algebraic expressions may lead to different
answers. Can you devise an interval-arithmetic package that does not have this
shortcoming, or is this task impossible? (Warning: This problem is very
difficult.)
#+end_quote

*** Answer

It is /indeed/ very difficult, because from what I'm seeing online, no interval
system without these issues exists. To avoid these issues, interval mathematics
would need to satisfy the conditions for a *field* -- and failing that, needs to
only use each variable once, which becomes impossible as soon as you encounter
an expression as simple as \(x^2\).

GitHub user "=diiq=" has an incredible analysis of this, which can be found here:
[[https://gist.github.com/diiq/1f39df0e54b2137bb07e7e04b11cb075]]

** 2.2: Hierarchical Data and the Closure Property

~cons~ pairs can be used to construct more complex data-types.

file:2/cons-cells.jpeg

The ability to combine things using an operation, then combine those results
using the same operation, can be called the *closure property*. ~cons~ can
create pairs whose elements are pairs, which satisfies the closure property.
This property enables you to create hierarchical structures. We've already
regularly used the closure property in creating procedures composed of other
procedures.

#+begin_quote
  *Definitions of "closure"*

  The use of the word "closure" here comes from abstract algebra, where a set of
  elements is said to be closed under an operation if applying the operation to
  elements in the set produces an element that is again an element of the set.
  The Lisp community also (unfortunately) uses the word "closure" to describe a
  totally unrelated concept: A closure is an implementation technique for
  representing procedures with free variables. We do not use the word "closure"
  in this second sense in this book.
#+end_quote

** 2.2.1: Representing Sequences

- *sequence* :: An ordered collection of data objects.
- *list* :: A sequence of ~cons~ pairs.

#+BEGIN_SRC scheme
(cons 1
      (cons 2
            (cons 3
                  (cons 4 nil))))
(list 1 2 3 4)
;; both evaluate to '(1 2 3 4)
#+END_SRC


An aside: many parts of this book have covered ways to solve problems by
splitting problems into simple recursive solutions. I may be getting ahead of
myself, but I wanted to note how the ~cons~ pair system goes hand-in-hand with
this. For example, when going over a list ~l~ with function ~f~:
#+BEGIN_SRC scheme :eval no-export :results value
(define (map f l)
  (if (null? l)
      #nil
      (cons (f (car l))
            (map f (cdr l)))))

(map (λ(x)(* x 2))
     (list 1 2 3 4))
#+END_SRC

#+RESULTS[e2464f1ca2c69060ca4476041917eb97b5c43c5e]:
#+begin_EXAMPLE
| 2 | 4 | 6 | 8 |
#+end_EXAMPLE

** Exercise 2.17

*** Question

#+begin_quote
Define a procedure
src_scheme{last-pair} that returns the list that contains only the last element of a
given (nonempty) list:
#+end_quote

#+BEGIN_SRC scheme
(last-pair (list 23 72 149 34))
;; (34)
#+END_SRC

*** Answer

#+NAME: last-pair
#+BEGIN_SRC scheme :eval no-export :results silent
(define (last-pair l)
  (let ((a (car l))
        (d (cdr l)))
    (if (= 1 (length d))
        d
        (last-pair d))))
#+END_SRC
#+BEGIN_SRC scheme :eval no-export :results value
<<last-pair>>
(last-pair (list 23 72 149 34))
#+END_SRC

#+RESULTS[92b3f391da7b9ca2894a07d71692d4de07c5377f]:
#+begin_EXAMPLE
| 34 |
#+end_EXAMPLE

** Exercise 2.18

*** Question
#+begin_quote
Define a procedure src_scheme{reverse} that takes a list as argument and returns
a list of the same elements in reverse order:
#+end_quote

#+BEGIN_SRC scheme
(reverse (list 1 4 9 16 25))
;; (25 16 9 4 1)
#+END_SRC

*** Answer

#+NAME: reverse
#+BEGIN_SRC scheme :eval no-export :results silent
(define (reverse l)
  (define len (length l))
  (define (iter i result)
    (if (< (1- len) i)
        result
        (iter (+ i 1)
              (cons (list-ref l i)
                    result))))
  (iter 0 '()))
#+END_SRC
#+BEGIN_SRC scheme :eval no-export :results value
<<reverse>>
(reverse (list 23 72 149 34))
#+END_SRC

#+RESULTS[c2b867c136d1561f95ea2814ed53cf08104e76b3]:
| 34 | 149 | 72 | 23 |

** Exercise 2.19

*** Question

#+begin_quote
Consider the change-counting program of 1.2.2. It would be nice to be able to
easily change the currency used by the program, so that we could compute the
number of ways to change a British pound, for example. As the program is
written, the knowledge of the currency is distributed partly into the procedure
src_scheme{first-denomination} and partly into the procedure
src_scheme{count-change} (which knows that there are five kinds of U.S. coins).
It would be nicer to be able to supply a list of coins to be used for making
change.

We want to rewrite the procedure src_scheme{cc} so that its second argument is a
list of the values of the coins to use rather than an integer specifying which
coins to use. We could then have lists that defined each kind of currency:
#+end_quote

#+BEGIN_SRC scheme
(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
#+END_SRC

#+begin_quote
We could then call src_scheme{cc} as follows:
#+end_quote

#+BEGIN_SRC scheme
(cc 100 us-coins)
; 292
#+END_SRC

#+begin_quote
To do this will require changing the program src_scheme{cc} somewhat. It will
still have the same form, but it will access its second argument differently, as
follows:
#+end_quote

#+NAME: cc-lists
#+BEGIN_SRC scheme -n :results silent :eval no-export
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination
                 coin-values))
            (cc (- amount
                   (first-denomination
                    coin-values))
                coin-values)))))
#+END_SRC

#+begin_quote
Define the procedures src_scheme{first-denomination},
src_scheme{except-first-denomination}, and src_scheme{no-more?} in terms of
primitive operations on list structures. Does the order of the list
src_scheme{coin-values} affect the answer produced by src_scheme{cc}? Why or why
not?
#+end_quote

*** Answer

#+NAME: Ex-2-19
#+BEGIN_SRC scheme :eval no-export :results silent
<<cc-lists>>

(define us-coins 
  (list 50 25 10 5 1))
(define uk-coins 
  (list 100 50 20 10 5 2 1 0.5))

(define first-denomination car)
(define except-first-denomination cdr)
(define no-more? null?)
#+END_SRC

#+BEGIN_SRC scheme :eval no-export :results value
<<Ex-2-19>>
(list
 (cc 100 us-coins)
 (cc 100 (reverse us-coins))
 (cc 100 (list 50 10 25 5 1)))
#+END_SRC

#+RESULTS[1440dcdbebd75dfa0ad49b760cd48a05b374a9b8]:
#+begin_EXAMPLE
| 292 | 292 | 292 |
#+end_EXAMPLE

Apparently, the order of the list does /not/ affect the value. However, it does effect the execution time, with small-to-large coin lists taking more time than large-to-small.

#+NAME: cc-list-benchmark
#+BEGIN_SRC scheme -n :noeval :results output :exports results :tangle 2/Ex19-bench.scm
(define iters 50000)
(load "../mattbench.scm")
<<Ex-2-19>>
(let ((rev-us-coins (reverse us-coins)))
  (format #t "decreasing values: ~a~%"
          (cdr (mattbench2 (λ()
                             (cc 100 us-coins))
                           iters)))
  (format #t "increasing values: ~a~%"
          (cdr (mattbench2 (λ()
                             (cc 100 rev-us-coins))
                           iters))))
#+END_SRC

#+RESULTS: cc-list-benchmark
#+begin_example
decreasing values: (357503.80704)
increasing values: (823460.64376)
#+end_example

** Exercise 2.20

*** Question

#+begin_quote
Use =[dotted-pair]= notation to write a procedure src_scheme{same-parity} that takes one or
more integers and returns a list of all the arguments that have the same
even-odd parity as the first argument.  For example,
#+end_quote

#+BEGIN_SRC scheme
(same-parity 1 2 3 4 5 6 7)
; (1 3 5 7)
(same-parity 2 3 4 5 6 7)
; (2 4 6)
#+END_SRC

*** Answer

#+NAME: same-parity
#+BEGIN_SRC scheme -n :eval no-export :result silent
(define (same-parity . rest)
  (define same?
    (if (even? (car rest))
        even?
        odd?))
  (define (iter l results)
    (if (null? l)
         results
        (let ((a (car l)))
          (iter (cdr l)
                (if (same? a)
                    (cons a results)
                    results)))))
  (iter (reverse rest) '()))

;; Attempting to remove the reversing
(define (same-parity2 . args)
  (define first (car args))
  (define same?
    (if (even? first)
        even?
        odd?))
  (define (iter l results)
    (if (null? l)
        results
        (let ((a (car l))
              (d (cdr l)))
          (if (same? a)
              (iter d (append results
                              (cons a #nil)))
              (iter d results)))))
  (iter (cdr args) (cons first #nil)))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :results value
<<same-parity>>
(list
 (same-parity 1 2 3 4 5 6 7)
 (same-parity2 2 3 4 5 6 7))
#+END_SRC

#+RESULTS[fc9b426af98cdf036973b2b682d4e8fae21e8e41]:
#+begin_EXAMPLE
| 1 | 3 | 5 | 7 |
| 2 | 4 | 6 |   |
#+end_EXAMPLE

#+NAME: same-parity-benchmark
#+BEGIN_SRC scheme -n :noeval :results output :exports results :tangle 2/Ex20-bench.scm
(define iters 500000)
(load "../mattbench.scm")
<<same-parity>>
(let ((l (cddr (iota 100))))
  (format #t "same-parity: ~a~%"
          (cdr (mattbench2 (λ()
                             (apply same-parity l))
                           iters)))
  (format #t "same-parity2: ~a~%"
          (cdr (mattbench2 (λ()
                             (apply same-parity2 l))
                           iters))))
#+END_SRC

#+RESULTS: same-parity-benchmark
#+BEGIN_EXAMPLE
same-parity: (10003.483436)
same-parity2: (56007.042334)
#+END_EXAMPLE

Once again, my attempts to optimize are a complete failure. I'm guessing that
the act of traversing the whole list in the call to ~append~ is the problem.

** Exercise 2.21

*** Question

#+begin_quote
The procedure src_scheme{square-list} takes a list of numbers as argument and
returns a list of the squares of those numbers.
#+end_quote

#+BEGIN_SRC scheme
(square-list (list 1 2 3 4))
;; (1 4 9 16)
#+END_SRC

#+begin_quote
Here are two different definitions of src_scheme{square-list}. Complete both of
them by filling in the missing expressions:
#+end_quote

#+BEGIN_SRC scheme -n
(define (square-list items)
  (if (null? items)
      nil
      (cons <??> <??>)))
(define (square-list items)
  (map <??> <??>))
#+END_SRC

*** Answer

#+NAME: square-list
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<square>>
(define (square-list-manual items)
  (if (null? items)
      #nil
      (cons (square (car items))
            (square-list-manual (cdr items)))))
(define (square-list items)
  (map square items))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :exports both :results value table
<<square-list>>
(let ((l (list 2 3 4 5 6)))
  (list l
        (square-list-manual l)
        (square-list l)))
#+END_SRC

#+RESULTS[25d4496062bb94eb4e767a7e36578714e9c3b629]:
#+begin_EXAMPLE
| 2 | 3 |  4 |  5 |  6 |
| 4 | 9 | 16 | 25 | 36 |
| 4 | 9 | 16 | 25 | 36 |
#+end_EXAMPLE

** Exercise 2.22

*** Questions

#+begin_quote
Louis Reasoner tries to rewrite the first src_scheme{square-list} procedure of
Exercise 2.21 so that it evolves an iterative process:
#+end_quote

#+BEGIN_SRC scheme -n
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items nil))
#+END_SRC

#+begin_quote
Unfortunately, defining src_scheme{square-list} this way produces the answer
list in the reverse order of the one desired. Why?

Louis then tries to fix his bug by interchanging the arguments to
src_scheme{cons}:
#+end_quote

#+BEGIN_SRC scheme -n
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square (car things))))))
  (iter items nil))
#+END_SRC

#+begin_quote
This doesn't work either.  Explain.
#+end_quote

*** Answer

I'm positive I've made this exact mistake before, though this is likely not
recorded.

The first form of src_scheme{square-list} produces a correct list in reverse order:

#+BEGIN_SRC scheme
(square-list (iota 6))
(25 16 9 4 1 0)
#+END_SRC

This is because he is prepending to the list every iteration.

While the second produces a broken list, which is literally backwards:
#+BEGIN_SRC scheme -n
(square-list (iota 6))
((((((#nil . 0) . 1) . 4) . 9) . 16) . 25)
;; Equivalent to:
(cons (cons (cons (cons (cons (cons #nil
                                    0)
                              1)
                        4)
                  9)
            16)
      25)
#+END_SRC

Since Lisp was designed with the ~cons pair~ structure of list-building, it
needed to define a "correct" direction for the pairs to go. Since the Western
world thinks left-to-right, they made it so that the left (first) cell is for
content, and the right is for the pointer to the next pair. However, this means
that you can't append to a list without first traveling its length and changing
the src_scheme{nil} marking the end to a pointer to your new pair. Since that is
a lot of list traveling, it makes more sense to src_scheme{cons} your list
together in reverse and then calling src_scheme{reverse} only once at the end of
the procedure.

** Exercise 2.23

*** Question

#+begin_quote
The procedure src_scheme{for-each} is similar to src_scheme{map}. It takes as
arguments a procedure and a list of elements. However, rather than forming a
list of the results, src_scheme{for-each} just applies the procedure to each of
the elements in turn, from left to right. The values returned by applying the
procedure to the elements are not used at all---src_scheme{for-each} is used
with procedures that perform an action, such as printing. For example,
#+end_quote

#+BEGIN_SRC scheme -n
(for-each (lambda (x)
            (newline)
            (display x))
          (list 57 321 88))
;; 57
;; 321
;; 88
#+END_SRC

#+begin_quote
The value returned by the call to src_scheme{for-each} (not illustrated above)
can be something arbitrary, such as true. Give an implementation of
src_scheme{for-each}.
#+end_quote

*** Answer

#+NAME: for-each-mine
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (for-each-mine proc items)
  (define (iter l)
    (if (null? l)
        #t
        (begin (proc (car l))
               (iter (cdr l)))))
  (iter items))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :results output
<<for-each-mine>>
(for-each-mine (λ(x)(display x)(display " ")) (list "all" "your" "base"))
(for-each (λ(x)(display x)(display " ")) (list "are" "belong" "to" "us"))
#+END_SRC

#+RESULTS[97f7b4879e8dbad6864e9651b39d957072f54621]:
#+begin_EXAMPLE
all your base are belong to us 
#+end_EXAMPLE

** Exercise 2.24

*** Text Definitions

#+NAME: count-leaves
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (count-leaves x)
  (cond ((null? x) 0)
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x))
                 (count-leaves (cdr x))))))
#+END_SRC

*** Question

#+begin_quote
Suppose we evaluate the expression src_scheme{(list 1 (list 2 (list 3 4)))}.
Give the result printed by the interpreter, the corresponding box-and-pointer
structure, and the interpretation of this as a tree (as in Figure 2.6).
#+end_quote

*** Answer

This is sort of a trick question -- on first reading, I read it like a series of ~cons~ statements. Looking again, though, I can see that the correct formulation is as follows:
#+BEGIN_SRC scheme -n :eval no-export :results output :exports both
<<echo>>
(let ((l1 (list 1 (list 2 (list 3 4))))
      (l2 (cons 1
                (cons
                 (cons 2
                       (cons
                        (cons 3
                              (cons 4
                                    #nil))
                        #nil))
                 #nil))))
  (echo "textbook version:" l1)
  (echo "cons'd version:" l2))
#+END_SRC

#+RESULTS[7db9abab1fe2f100e098940e4505323400de476f]:
#+begin_EXAMPLE
textbook version: (1 (2 (3 4))) 
cons'd version: (1 (2 (3 4))) 
#+end_EXAMPLE

Dot and box version:
#+BEGIN_SRC dot :file 2/fig/24-dotandbox.png :exports results :eval no-export
/* Why doesn't "arrowtail=dot" work? It is a mystery. */
digraph {
    newrank = true;
    compound = true;

    node [shape=ellipse,margin=0];
    subgraph sg0 {
        cluster = true;
        color = lightgrey;
        shape = rounded;
        style = filled;
        label = "'(1 (2 (3 4)))";
        cellA [shape=none,label=<
              <table border="0" cellborder="1" cellspacing="0">
                     <tr>
                        <td port="car">&nbsp;*&nbsp;</td>
                        <td port="cdr">&nbsp;</td>
                    </tr>
                </table> >];
        cellA:car:s -> "1":n [shape=ellipse];
        cellAa [shape=none,label=<
               <table border="0" cellborder="1" cellspacing="0">
                <tr>
                 <td port="car">&nbsp;*&nbsp;</td>
                 <td port="cdr">X</td>
                </tr>
               </table>>];
                
        cellA:cdr:c -> cellAa:car:w [tailclip=false,dir=both,arrowtail=dot,dir=both,tailclip=false];
        cellAa:car:s -> cellB:car:n;
        subgraph sg1 {
            cluster = true;
            color = white;
            shape = rounded;
            style = filled;
            label = "'(2 (3 4))";
            cellB [shape=none,label=<
                <table border="0" cellborder="1" cellspacing="0">
                        <tr>
                            <td port="car">&nbsp;*&nbsp;</td>
                            <td port="cdr">&nbsp;</td>
                        </tr>
                    </table> >];
            cellB:car:s -> "2":n [shape=ellipse];
            cellBb [shape=none,label=<
                <table border="0" cellborder="1" cellspacing="0">
                    <tr>
                    <td port="car">&nbsp;*&nbsp;</td>
                    <td port="cdr">X</td>
                    </tr>
                </table>>];

            cellB:cdr:c -> cellBb:car:w [tailclip=false,dir=both,arrowtail=dot,dir=both,tailclip=false];
            cellBb:car:s -> cellC:car:n;
            subgraph sg2 {
                cluster = true;
                color = lightgrey;
                shape = rounded;
                style = filled;
                label = "'(3 4)";
                cellC [shape=none,label=<
                    <table border="0" cellborder="1" cellspacing="0">
                            <tr>
                                <td port="car">&nbsp;*&nbsp;</td>
                                <td port="cdr">&nbsp;</td>
                            </tr>
                        </table> >];
                cellC:car:s -> "3":n [shape=ellipse];
                cellC:cdr:c -> cellD:car:w [tailclip=false,dir=both,arrowtail=dot,dir=both,tailclip=false];
                subgraph sg3 {
                    cluster = true;
                    color = white;
                    shape = rounded;
                    style = filled;
                    label = "'(4)";
                    cellD [shape=none,label=<
                        <table border="0" cellborder="1" cellspacing="0">
                            <tr>
                            <td port="car">&nbsp;*&nbsp;</td>
                            <td port="cdr">X</td>
                            </tr>
                        </table>>];

                    cellD:car:s -> "4":n;
                };
            };
        };
    };
    { rank = same; cellA; cellAa; };
    { rank = same; "1"; cellB; cellBb; };
    { rank = same; "2"; cellC; cellD; };
    { rank = same; "3"; "4"; };
}
#+end_src

#+RESULTS[5e93cb48cc6fceab2c633d425f66162262af2005]:
:results:
[[file:2/fig/24-dotandbox.png]]
:end:

Tree version:
#+BEGIN_SRC dot :file 2/fig/24-tree.png :exports results :eval no-export
digraph {
    node [shape=none,margin=0];
    "(1 (2 (3 4)))":s -> "1";
    "(1 (2 (3 4)))":s -> "(2 (3 4))";
    "(2 (3 4))":s -> "2";
    "(2 (3 4))":s -> "(3 4)";
    "(3 4)":s -> "3";
    "(3 4)":s -> "4";
}
#+END_SRC

#+RESULTS[a845b46b004192cb2595d312eb6c40aa94c94931]:
:results:
[[file:2/fig/24-tree.png]]
:end:

** Exercise 2.25

*** Question

#+begin_quote
Give combinations of src_scheme{car}s and src_scheme{cdr}s that will pick 7 from
each of the following lists:
#+end_quote

#+BEGIN_SRC scheme
(1 3 (5 7) 9)
((7))
(1 (2 (3 (4 (5 (6 7))))))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :results output
<<echo>>
(let ((l1 (list 1 3 (list 5 7) 9))
      (l2 (list (list 7)))
      (l3 (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7))))))))
  (echo (car (cdaddr l1))
        (caar l2)
        (cadadr (cadadr (cadadr l3)))))
#+END_SRC

#+RESULTS[5dd3e45a2df968170f6a2b00efe33964161ed387]:
#+begin_EXAMPLE
7 7 7 
#+end_EXAMPLE

** Exercise 2.26

*** Question

#+begin_quote
Suppose we define src_scheme{x} and src_scheme{y} to be two lists:
#+end_quote

#+BEGIN_SRC scheme
(define x (list 1 2 3))
(define y (list 4 5 6))
#+END_SRC

#+begin_quote
What result is printed by the interpreter in response to evaluating each of the
following expressions:
#+end_quote

#+BEGIN_SRC scheme
(append x y)
(cons x y)
(list x y)
#+END_SRC

*** Answer

#+BEGIN_SRC scheme -n :eval no-export :results output
<<echo>>
(let* ((x (list 1 2 3))
      (y (list 4 5 6))
      (e1 (append x y))
      (e2 (cons x y))
      (e3 (list x y)))
  (echo "(append x y):" e1)
  (echo "(cons x y):" e2)
  (echo "(list x y):" e3))
#+END_SRC

#+RESULTS[81ffb47c04cdae841253c59cf9d416ab5c4d6b10]:
#+begin_EXAMPLE
(append x y): (1 2 3 4 5 6) 
(cons x y): ((1 2 3) 4 5 6) 
(list x y): ((1 2 3) (4 5 6)) 
#+end_EXAMPLE

** Exercise 2.27

*** Question

Modify your src_scheme{reverse} procedure of Exercise 2.18 to produce a
src_scheme{deep-reverse} procedure that takes a list as argument and returns as
its value the list with its elements reversed and with all sublists
deep-reversed as well. For example,

#+BEGIN_SRC scheme
(define x (list (list 1 2) (list 3 4)))
x
;; ((1 2) (3 4))
(reverse x)
;; ((3 4) (1 2))
(deep-reverse x)
;; ((4 3) (2 1))
#+END_SRC

*** Answer

#+NAME: deep-reverse
#+BEGIN_SRC scheme :eval no-export :results silent
(define (deep-reverse l)
  (define len (length l))
  (define (iter i result)
    (if (< (1- len) i)
        result
        (iter (+ i 1)
              (cons (let ((here (list-ref l i)))
                      (if (pair? here)
                          (deep-reverse here)
                          here))
                    result))))
  (iter 0 '()))
#+END_SRC
#+BEGIN_SRC scheme :eval no-export :results value code
<<deep-reverse>>
(deep-reverse (list (list 1 2) (list 3 4)))
#+END_SRC

#+RESULTS[fa54e5f7043136e95170dd1071f5dff1f0845d9e]:
#+begin_src scheme
((4 3) (2 1))
#+end_src

** Exercise 2.28

*** Question

Write a procedure src_scheme{fringe} that takes as argument a tree (represented
as a list) and returns a list whose elements are all the leaves of the tree
arranged in left-to-right order. For example,

#+BEGIN_SRC scheme
(define x (list (list 1 2) (list 3 4)))
(fringe x)
;; (1 2 3 4)
(fringe (list x x))
;; (1 2 3 4 1 2 3 4)
#+END_SRC

*** Answer

#+NAME: fringe
#+BEGIN_SRC scheme :eval no-export :results silent
(define (fringe l)
  (if (null? l)
      #nil
      (let ((a (car l))
            (d (cdr l)))
        (append (if (pair? a)
                    (fringe a)
                    (list a))
                (fringe d)))))
#+END_SRC
#+BEGIN_SRC scheme :eval no-export :results value code :wrap src
<<fringe>>
(fringe (list (list 1 (list 2 3)) (list 4 5)))
#+END_SRC

#+RESULTS[6080592c2d871b7b64340ee9af439d3da32beb90]:
#+begin_src
(1 2 3 4 5)
#+end_src

** Exercise 2.29: Binary Mobiles

*** Text Definitions

#+NAME: mobile-constructors-list
#+BEGIN_SRC scheme :eval no-export :results silent
(define (make-mobile left right)
  (list left right))

(define (make-branch length structure)
  (list length structure))
#+END_SRC

*** Question A: Selectors

#+begin_quote
Write the corresponding selectors src_scheme{left-branch} and
src_scheme{right-branch}, which return the branches of a mobile, and
src_scheme{branch-length} and src_scheme{branch-structure}, which return the
components of a branch.
#+end_quote

*** Answer A

#+NAME: mobile-selectors-list
#+BEGIN_SRC scheme :eval no-export :results silent
<<mobile-constructors-list>>
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (cadr mobile))
(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (cadr branch))
#+END_SRC

*** Question B: total-weight

#+begin_quote
Using your selectors, define a procedure src_scheme{total-weight} that returns
the total weight of a mobile.
#+end_quote

*** Answer B

#+NAME: mobile-total-weight
#+BEGIN_SRC scheme :eval no-export :results silent
(define (total-weight mobile)
  (let ((leftS (branch-structure (left-branch mobile)))
        (rightS (branch-structure (right-branch mobile))))
    (+ (if (number? leftS)
           leftS
           (total-weight leftS))
       (if (number? rightS)
           rightS
           (total-weight rightS)))))
#+END_SRC


#+BEGIN_SRC scheme :eval no-export :results value
<<mobile-selectors-list>>
<<mobile-total-weight>>

(let ((M1 (make-mobile
           (make-branch 5 5)
           (make-branch 1
                        (make-mobile (make-branch 2 2)
                                     (make-branch 2 3)))))
      (M2 (make-mobile
           (make-branch 2
                        (make-mobile
                         (make-branch 2 2)
                         (make-branch 2 2)))
           (make-branch 2
                        (make-mobile
                         (make-branch 2 2)
                         (make-branch 2 2))))))
  (list (total-weight M1)
        (total-weight M2)))
#+END_SRC

#+RESULTS[889a3f8b4d827393dd7f03f5bb525c215ef6df8f]:
#+begin_EXAMPLE
| 10 | 8 |
#+end_EXAMPLE

*** Question C: Balancing

A mobile is said to be *balanced* if the torque applied by its top-left branch is
equal to that applied by its top-right branch (that is, if the length of the
left rod multiplied by the weight hanging from that rod is equal to the
corresponding product for the right side) and if each of the submobiles hanging
off its branches is balanced. Design a predicate that tests whether a binary
mobile is balanced.

*** Answer C

I can imagine a ton of ways I could shoot myself in the foot by starting with
optimization, so let's just try to nail down exactly what needs to happen.

#+NAME: mobile-balanced-dumb
#+BEGIN_SRC scheme :eval no-export :results silent
(define (total-torque branch)
  (let ((len (branch-length branch))
        (struct (branch-structure branch)))
    (* len
       (if (number? struct)
           struct
           (let ((lbs (branch-structure (left-branch struct)))
                 (rbs (branch-structure (right-branch struct))))
             (+ (total-weight lbs)
                (total-weight rbs)))))))
(define (balanced? mobile)
  (let* ((l (left-branch mobile))
         (ls (branch-structure l))
         (r (right-branch mobile))
         (rs (branch-structure r))
         (l-balanced (if (number? ls)
                         #t
                         (balanced? ls)))
         (r-balanced (if (number? rs)
                         #t ;; Fixed: accidentally used ls again.
                         (balanced? rs))))
    (if (and l-balanced r-balanced)
        (= (total-torque l)
           (total-torque r))
        #f)))
#+END_SRC

I'll also need a modified src_scheme{total-weight} that can notice when its
argument is a non-mobile and just return the value.

#+NAME: mobile-total-weight-2
#+BEGIN_SRC scheme :eval no-export :results silent
(define (total-weight mobile)
  (if (number? mobile)
      mobile ;; this is a weight, just return it
      (let ((leftS (branch-structure (left-branch mobile)))
            (rightS (branch-structure (right-branch mobile))))
        (+ (if (number? leftS)
               leftS
               (total-weight leftS))
           (if (number? rightS)
               rightS
               (total-weight rightS))))))
#+END_SRC

#+BEGIN_SRC scheme :eval no-export :results output
<<echo>>
<<mobile-selectors-list>>
<<mobile-total-weight-2>>
<<mobile-balanced-dumb>>
(define M1 ;; all segments unbalanced
  (make-mobile
   (make-branch 5 5) ;; torque 25 = 5*5
   (make-branch 1 ;; torque 5 = (2 + 3) * 1
                (make-mobile (make-branch 2 2)
                             (make-branch 2 3)))))
(define M2 ;; all segments balanced as they are duplicates
  (make-mobile
   (make-branch 2 ;; torque 8 = 2*(2+2)
                (make-mobile
                 (make-branch 2 2)
                 (make-branch 2 2)))
   (make-branch 2
                (make-mobile
                 (make-branch 2 2)
                 (make-branch 2 2)))))
(define M3 ;; equal torque, but one segment is unbalanced.
  (make-mobile
   (make-branch 2 ;; torque 12 = 2*(4+2)
                (make-mobile
                 (make-branch 2 4) ;; torque 8 = 2*4
                 (make-branch 4 2))) ;torque 8 = 4*2
   (make-branch 3 ;; torque 12 = 3*(1+3)
                (make-mobile
                 (make-branch 1 1) ;; torque 1
                 (make-branch 1 3))))) ;; torque 3
(define M4 ;; equal torque
  (make-mobile
   (make-branch 2 ;; torque 12 = 2*(4+2)
                (make-mobile
                 (make-branch 2 4) ;; torque 8 = 2*4
                 (make-branch 4 2))) ;torque 8 = 4*2
   (make-branch 3 ;; torque 12 = 3*(1+3)
                (make-mobile
                 (make-branch 3 1) ;; torque 3
                 (make-branch 1 3))))) ;; torque 3
(define (isbalanced? Name Status)
  (define Success "is balanced!")
  (define Failure "is not balanced!")
  (if (eq? Status #t)
      (echo Name Success)
      (echo Name Failure)))
(isbalanced? "M1" (balanced? M1))
(isbalanced? "M2" (balanced? M2))
(isbalanced? "M3" (balanced? M3))
(isbalanced? "M4" (balanced? M4))
#+END_SRC

#+RESULTS[88a2604f1b945099eb77cd8d0a535f75cb070c24]:
#+begin_EXAMPLE
M1 is not balanced! 
M2 is balanced! 
M3 is not balanced! 
M4 is balanced! 
#+end_EXAMPLE

This one took quite some fiddling. First I struggled to figure out exactly how I
should juggle of torque, weight, and balance. For example, a mobile is balanced
if the torques of its branches are equal, and if every submobile is also
balanced, with torque being defined as length\(\times\)weight. Note that it's
the /weight/, not its submobile's /torque/.

TODO: I'd like to come back and make an optimized version that doesn't have to
crawl the tree multiple times. Maybe getting torque/weight/balanced status at
the same time?

*** Question D: Implementation shakeup

#+begin_quote
Suppose we change the representation of mobiles so that the constructors are
#+end_quote

#+NAME: mobile-constructors-cons
#+BEGIN_SRC scheme :eval no-export :results silent
(define (make-mobile left right)
  (cons left right))

(define (make-branch length structure)
  (cons length structure))
#+END_SRC

#+begin_quote
How much do you need to change your programs to convert to the new representation?
#+end_quote

*** Answer D

Ideally I should only need to change the selectors, like this:

#+NAME: mobile-selectors-cons
#+BEGIN_SRC scheme :eval no-export :results silent
<<mobile-constructors-cons>>
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (cdr mobile))
(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (cdr branch))
#+END_SRC

Now, if I run the same code, I should get the same result:

#+BEGIN_SRC scheme :eval no-export :results output
<<echo>>
<<mobile-selectors-cons>>
<<mobile-total-weight-2>>
<<mobile-balanced-dumb>>
(define M1 ;; all segments unbalanced
  (make-mobile
   (make-branch 5 5) ;; torque 25 = 5*5
   (make-branch 1 ;; torque 5 = (2 + 3) * 1
                (make-mobile (make-branch 2 2)
                             (make-branch 2 3)))))
(define M2 ;; all segments balanced as they are duplicates
  (make-mobile
   (make-branch 2 ;; torque 8 = 2*(2+2)
                (make-mobile
                 (make-branch 2 2)
                 (make-branch 2 2)))
   (make-branch 2
                (make-mobile
                 (make-branch 2 2)
                 (make-branch 2 2)))))
(define M3 ;; equal torque, but one segment is unbalanced.
  (make-mobile
   (make-branch 2 ;; torque 12 = 2*(4+2)
                (make-mobile
                 (make-branch 2 4) ;; torque 8 = 2*4
                 (make-branch 4 2))) ;torque 8 = 4*2
   (make-branch 3 ;; torque 12 = 3*(1+3)
                (make-mobile
                 (make-branch 1 1) ;; torque 1
                 (make-branch 1 3))))) ;; torque 3
(define M4 ;; equal torque
  (make-mobile
   (make-branch 2 ;; torque 12 = 2*(4+2)
                (make-mobile
                 (make-branch 2 4) ;; torque 8 = 2*4
                 (make-branch 4 2))) ;torque 8 = 4*2
   (make-branch 3 ;; torque 12 = 3*(1+3)
                (make-mobile
                 (make-branch 3 1) ;; torque 3
                 (make-branch 1 3))))) ;; torque 3
(define (isbalanced? Name Status)
  (define Success "is balanced!")
  (define Failure "is not balanced!")
  (if (eq? Status #t)
      (echo Name Success)
      (echo Name Failure)))
(isbalanced? "M1" (balanced? M1))
(isbalanced? "M2" (balanced? M2))
(isbalanced? "M3" (balanced? M3))
(isbalanced? "M4" (balanced? M4))
#+END_SRC

#+RESULTS[9e3d1eab5aeb21aea820e55943c032458e5bb9e7]:
#+begin_EXAMPLE
M1 is not balanced! 
M2 is balanced! 
M3 is not balanced! 
M4 is balanced! 
#+end_EXAMPLE

** Exercise 2.30

*** Question

Define a procedure
src_scheme{square-tree} analogous to the src_scheme{square-@/list} procedure of
[[Exercise 2.21]].  That is, src_scheme{square-tree} should behave as follows:

#+BEGIN_SRC scheme -n
(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
;; (1 (4 (9 16) 25) (36 49))
#+END_SRC

Define src_scheme{square-tree} both directly (i.e., without using any higher-order
procedures) and also by using src_scheme{map} and recursion.

*** Answer

#+NAME: square-tree
#+BEGIN_SRC scheme :eval no-export :results silent
<<square>>
(define (square-tree-discrete tree)
  (cond ((null? tree) '())
        ((not (pair? tree)) (square tree))
        (else (cons (square-tree-discrete (car tree))
                    (square-tree-discrete (cdr tree))))))

(define (square-tree-map tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (square-tree-map sub-tree)
             (square sub-tree)))
       tree))
#+END_SRC

#+BEGIN_SRC scheme :eval no-export :results output
(load "mattcheck2.scm")
<<square-tree>>
(let ((testlist
       (list 1
             (list 2 (list 3 4) 5)
             (list 6 7)))
      (answer
       (list 1
             (list 4 (list 9 16) 25)
             (list 36 49))))
  (mattcheck "square-tree-discrete"
             (square-tree-discrete testlist)
             answer)
  (mattcheck "square-tree-map"
             (square-tree-map testlist)
             answer))
#+END_SRC

#+RESULTS[e9e27db8ac9027cdcd1420c84234ff2a64f3a768]:
#+begin_EXAMPLE
SUCCEED at square-tree-discrete
SUCCEED at square-tree-map
#+end_EXAMPLE

While writing that, I ran headfirst into a lesson I've had to repeatedly learn: default Guile functions end their lists with src_scheme{'()} which does not match equality with lists ended with src_scheme{#nil}.
#+BEGIN_SRC scheme :eval no-export :results output
(let ((parens-list (cons 1 (cons 2 (cons 3 '()))))
      (nil-list (cons 1 (cons 2 (cons 3 #nil)))))
  (display parens-list)(display " <== ends with '()")
  (newline)
  (display nil-list)(display " <== ends with #nil")
  (newline)
  (display "Are these two lists equal? > ")
  (display (equal? parens-list nil-list))
  (newline)
  (display "Does Guile consider #nil and '() equal? > ")
  (display (equal? #nil '()))
  (newline)
  (display "What about #nil and #f? > ")
  (display (equal? #nil #f)))
#+END_SRC

#+RESULTS[8942f65fc2e98e535b33a5aa21d98cc3e5ca0036]:
#+begin_EXAMPLE
(1 2 3) <== ends with '()
(1 2 3) <== ends with #nil
Are these two lists equal? > #f
Does Guile consider #nil and '() equal? > #f
What about #nil and #f? > #f
#+end_EXAMPLE

** Exercise 2.31

*** Question

#+begin_quote
Abstract your answer to [[Exercise 2.30]] to produce a procedure
src_scheme{tree-map} with the property that src_scheme{square-tree} could be
defined as
#+end_quote

#+BEGIN_SRC scheme
(define (square-tree tree) (tree-map square tree))
#+END_SRC

*** Answer

#+NAME: tree-map
#+BEGIN_SRC scheme :eval no-export :results silent
(define (tree-map f tree)
  (cond ((null? tree) '())
        ((not (pair? tree)) (f tree))
        (else (cons (tree-map f (car tree))
                    (tree-map f (cdr tree))))))
#+END_SRC
#+BEGIN_SRC scheme :eval no-export :results output
(load "mattcheck2.scm")
<<tree-map>>
<<square>>
(define (square-tree-tm tree)
  (tree-map square tree))
(let ((testlist
       (list 1
             (list 2 (list 3 4) 5)
             (list 6 7)))
      (answer
       (list 1
             (list 4 (list 9 16) 25)
             (list 36 49))))
  (mattcheck "square-tree-tm"
             (square-tree-tm testlist)
             answer))
#+END_SRC

#+RESULTS[6adef597c27ce19e16711d7a4f8c643e736ea197]:
#+begin_EXAMPLE
SUCCEED at square-tree-tm
#+end_EXAMPLE

** Exercise 2.32

*** Question

#+begin_quote
We can represent a set as a list of distinct elements, and we can represent the
set of all subsets of the set as a list of lists. For example, if the set is
src_scheme{(1 2 3)}, then the set of all subsets is src_scheme{(() (3) (2) (2 3)
(1) (1 3) (1 2) (1 2 3))}. Complete the following definition of a procedure that
generates the set of subsets of a set and give a clear explanation of why it
works:
#+end_quote

#+BEGIN_SRC scheme
(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map <??> rest)))))
#+END_SRC

*** Answer

#+NAME: subsets
#+BEGIN_SRC scheme :eval no-export :results silent
(define (subsets s)
  (if (null? s)
      (list '())
      (let ((rest (subsets (cdr s))))
        (append rest (map (λ(x)
                            (cons (car s) x))
                          rest)))))
#+END_SRC

#+BEGIN_SRC scheme :eval no-export :results output
<<subsets>>
(load "mattcheck2.scm")
(let ((answer
       (list '()
             (list 3)
             (list 2) (list 2 3)
             (list 1) (list 1 3)
             (list 1 2) (list 1 2 3))))
  (mattcheck "subsets"
             (subsets (list 1 2 3))
             answer))
#+END_SRC

#+RESULTS[fd91c5ab43cd94c6fcc25aced6b3a8a7d9ad7d3e]:
#+begin_EXAMPLE
SUCCEED at subsets
#+end_EXAMPLE

Essentially, src_scheme{subsets} is rotating through members of the list in a
similar way that a counter incrementing rotates through all numbers in its
base. For a list with items \(1\) to \(n\), ~subsets~ makes a list with the last
item, \([n]\), then lists \([n-1]\) and \([n-1, n]\), then lists \([n-2][n-2,
n-1][n-2,n]\), then \([n-3][n-3,n-2][n-3,n-1][n-3,n]\) and so on.

I'd like to try adding some debugging statements to subsets and see if it might
help clarify the operation.

#+NAME: echo-return
#+BEGIN_SRC scheme :eval no-export :results silent
<<echo>>
(define (doit f x)
  (f x) ;; this probably has a formal lambda calculus name
  x)    ;; but I don't know what it is
(define (echo-return x)
  (doit echo x))
#+END_SRC
#+BEGIN_SRC scheme :eval no-export :results output
<<subsets>>
<<echo-return>>
(define (subsets-debug s)
  (echo "Enter with" s "{")
  (let ((a1
         (if (null? s)
             (echo-return (list '()))
             (let ((rest (subsets-debug (cdr s))))
               (echo "[ iter" (car s) "over" rest "]")
               (append rest (map (λ(x)
                                   (let ((y (cons (car s) x)))
                                     (format #t "~a " y)
                                     y))
                                 rest))))))
    (echo "} end" s)
    a1))
(let ((answer
       (list '()
             (list 3)
             (list 2) (list 2 3)
             (list 1) (list 1 3)
             (list 1 2) (list 1 2 3))))
  (subsets-debug (list 1 2 3))
  answer)
#+END_SRC

#+RESULTS[6f69cef209e382eab3d630e741c2a8a917048153]:
#+begin_EXAMPLE
Enter with (1 2 3) { 
Enter with (2 3) { 
Enter with (3) { 
Enter with () { 
(()) 
} end () 
[ iter 3 over (()) ] 
(3) 
} end (3) 
[ iter 2 over (() (3)) ] 
(2) (2 3) 
} end (2 3) 
[ iter 1 over (() (3) (2) (2 3)) ] 
(1) (1 3) (1 2) (1 2 3) 
} end (1 2 3) 
#+end_EXAMPLE

** 2.2.3: Sequences as Conventional Interfaces

Abstractions are an important part of making code clearer and more easy to
understand. One beneficial manner of abstraction is making available
conventional interfaces for working with compound data, such as ~filter~ and
~map~.

This allows for easily making "signal-flow" conceptions of processes:

#+begin_src mermaid :file 2/fig/t_2-2-3.png
graph TD;
    A(enumerate: tree leaves)-->B(filter: odd?);
    B-->C(map: square);
    C-->D(accumulate: +, 0);
#+end_src

#+RESULTS:
#+ATTR_LATEX: :width 0.3\linewidth
[[file:2/fig/t_2-2-3.png]]

** Exercise 2.33: The flexibility of ~(accumulate)~

*** Text Definitions

#+NAME: accumulate
#+BEGIN_SRC scheme :eval no-export :results silent
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op 
                      initial 
                      (cdr sequence)))))
#+END_SRC

*** Question

#+begin_quote
Fill in the missing expressions to complete the following definitions of some basic list-manipulation operations as accumulations.
#+end_quote

#+BEGIN_SRC scheme
(define (map p sequence)
  (accumulate (lambda (x y) <??>) nil sequence))
(define (append seq1 seq2)
  (accumulate cons <??> <??>))
(define (length sequence)
  (accumulate <??> 0 sequence))
#+END_SRC

*** Answer

#+NAME: accumulate-forms
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (map-acc p sequence)
  (accumulate (lambda (x y)
                (cons (p x) y))
              '() sequence))
(define (append-acc seq1 seq2)
  (accumulate cons seq2 seq1))
(define (length-acc sequence)
  (accumulate (λ(x y)
                (1+ y))
              0 sequence))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :results output
(load "mattcheck2.scm")
<<accumulate>>
<<accumulate-forms>>
<<square>>
(let ((l (list 1 2 3 4)))
  (mattcheck "map"
             (map square l)
             (map-acc square l))
  (mattcheck "append"
             (append l l)
             (append-acc l l))
  (mattcheck "length"
             (length l)
             (length-acc l)))
#+END_SRC

#+RESULTS[9d96e74f1f9774cf266e9950663a8b58b6e3b538]:
#+begin_EXAMPLE
SUCCEED at map
SUCCEED at append
SUCCEED at length
#+end_EXAMPLE

** Exercise 2.34

*** Question

#+begin_quote
Evaluating a polynomial in \(x\) at a given value of \(x\) can be formulated as
an accumulation. We evaluate the polynomial

\[ a_n x^n + a_{n-1} x^{n-1} + \dots + a_1 x + a_0 \]

using a well-known algorithm called /Horner's rule/, which structures the
computation as

\[ (\dots (a_n x + a_{n-1}) x + \dots + a_1) x + a_0. \]

In other words, we start with \(a_n\), multiply by \(x\), add \(a_{n-1\)},
multiply by \(x\), and so on, until we reach \(a_0\).

Fill in the following template to produce a procedure that evaluates a
polynomial using Horner's rule.  Assume that the coefficients of the polynomial
are arranged in a sequence, from \(a_0\) through \(a_n\).
#+end_quote

#+BEGIN_SRC scheme
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) <??>)
              0
              coefficient-sequence))
#+END_SRC

#+begin_quote
For example, to compute \(1 + 3x + 5x^3 + x^5\) at \(x = 2\) you
would evaluate
#+end_quote

#+BEGIN_SRC scheme
(horner-eval 2 (list 1 3 0 5 0 1))
#+END_SRC

*** Answer

#+NAME: horner-eval
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms)
                (+ this-coeff
                   (* higher-terms x)))
              0
              coefficient-sequence))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :results output
(load "mattcheck2.scm")
<<accumulate>>
<<horner-eval>>
(mattcheck "horner-eval"
           (horner-eval 2 (list 1 3 0 5 0 1))
           79)
#+END_SRC

#+RESULTS[2ad17fe7e2cbf6e3f054954dd9ed7f42fd3b798b]:
#+begin_EXAMPLE
SUCCEED at horner-eval
#+end_EXAMPLE

This one was very satisfying. It essentially "delays" the exponentiation, carrying it out per stage, by rewriting this:

\(1 + 3 \times 2 + 5 \times 2^3 + 2^5\)

Into this operation, left to right:

\[ 0+1*2+0*2+0*2+3*2+1 \]


** Exercise 2.35

*** Question

#+begin_quote
Redefine src_scheme{count-leaves} from
2.2.2 as an accumulation:
#+end_quote

*** Answer

#+NAME: count-leaves-acc
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (count-leaves-acc t)
  (accumulate (λ(i total)
                (+ i total))
              0 (map (λ(x)
                       (if (pair? x)
                           (count-leaves-acc x)
                           1))
                     t)))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :results output
(load "mattcheck2.scm")
<<accumulate>>
<<count-leaves>>
<<count-leaves-acc>>
(let ((l (list (list (list 1 2 3) 4) (list 5 (list 6 7) 8))))
  (mattcheck "count-leaves-acc"
              (count-leaves l)
              (count-leaves-acc l)))
#+END_SRC

#+RESULTS[c6429013d876e42bed1937bc4eb5b64e0621fa50]:
#+begin_EXAMPLE
SUCCEED at count-leaves-acc
#+end_EXAMPLE

** Exercise 2.36: Accumulate across multiple lists

*** Question

#+begin_quote
The procedure src_scheme{accumulate-n} is similar to src_scheme{accumulate}
except that it takes as its third argument a sequence of sequences, which are
all assumed to have the same number of elements. It applies the designated
accumulation procedure to combine all the first elements of the sequences, all
the second elements of the sequences, and so on, and returns a sequence of the
results. For instance, if src_scheme{s} is a sequence containing four sequences,
src_scheme{((1 2 3) (4 5 6) (7 8 9) (10 11 12))}, then the value of
src_scheme{(accumulate-n + 0 s)} should be the sequence src_scheme{(22 26 30)}.
Fill in the missing expressions in the following definition of
src_scheme{accumulate-n}:
#+end_quote

#+BEGIN_SRC scheme
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init <??>)
            (accumulate-n op init <??>))))
#+END_SRC

*** Answers

#+NAME: accumulate-n
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      '()
      (cons (accumulate op init
                        (map car seqs))
            (accumulate-n op init
                          (map cdr seqs)))))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :results output
(load "mattcheck2.scm")
<<accumulate>>
<<accumulate-n>>
(let ((s (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12))))
  (mattcheck "accumulate-n"
             (accumulate-n + 0 s)
             (list 22 26 30)))
#+END_SRC

#+RESULTS[63440285ad7749602e346c425c99c13c896ec758]:
#+begin_EXAMPLE
SUCCEED at accumulate-n
#+end_EXAMPLE

** Exercise 2.37: Enter the matrices

*** Question

/See full quote in book./

Suppose we represent vectors as lists, and matrices as lists of vectors. For example:

\[
\left(
\begin{array}{cccc}
  1 & 2 & 3 & 4 \\
  4 & 5 & 6 & 6 \\
  6 & 7 & 8 & 9
\end{array}
\right)

\texttt{((1 2 3 4) (4 5 6 6) (6 7 8 9))}
\]

Define these operations:
#+BEGIN_SRC scheme -n
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
(define (matrix-*-vector m v)
  (map <??> m))
(define (transpose mat)
  (accumulate-n <??> <??> mat))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map <??> m)))
    #+END_SRC
*** Answer

#+NAME: matrix-ops
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
(define (matrix-*-vector m v)
  (map (λ(row)
         (dot-product v row))
       m))
(define (transpose mat)
  (accumulate-n cons '() mat))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (λ(row)
           (map (λ(col)
                  (dot-product row col))
                cols))
           m)))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :results output
(load "mattcheck2.scm")
<<echo>>
<<accumulate>>
<<accumulate-n>>
<<matrix-ops>>
(let* ((v1 (list 1 2 3 4))
      (v2 (list 5 6 7 8))
      (m1 (list v1 v2))
      (m1t (list (list 1 5)
                (list 2 6)
                (list 3 7)
                (list 4 8)))
      (m1-*-m1t (list (list 30 70)
                      (list 70 174))))
  (mattcheck "transpose"
             (transpose m1)
             m1t)
  (mattcheck "dot-product"
             (dot-product v1 v2)
             70)
  (mattcheck "matrix-*-vector"
             (matrix-*-vector m1 v1)
             (list 30 70))
  (mattcheck "matrix-*-matrix"
             (matrix-*-matrix m1 m1t)
             m1-*-m1t))
#+END_SRC

#+RESULTS[52c63f277ca222100ce639c3912830bfde495f09]:
#+begin_EXAMPLE
SUCCEED at transpose
SUCCEED at dot-product
SUCCEED at matrix-*-vector
SUCCEED at matrix-*-matrix
#+end_EXAMPLE

I struggled a lot with what order things should be processed and applied in.
Some of that came from never having done matrix multiplication before now. I
would probably still not understand it if I hadn't found [[https://youtu.be/MfN1lqArwAg][Herb Gross' lecture
regarding matrix operations]].

The other issue is nested map operations. I find it easy to read Python-ish
code like this:

#+begin_src python
# Pseudocode
for row in m1:
    for column in m2t:
        for a,b in row,column:
            answer[i:j] += a*b
#+end_src

But much harder to comprehend Lisp code like this:

#+begin_src scheme
(map (λ(row)
       (map (λ(col)
              (dot-product row col))
            m1t))
     m1)
#+end_src

I must have a mental block in the way I think about map operations.

** Exercise 2.38: fold-right

*** Question A

#+begin_quote
The src_scheme{accumulate} procedure
is also known as src_scheme{fold-right}, because it combines the first element of
the sequence with the result of combining all the elements to the right.  There
is also a src_scheme{fold-left}, which is similar to src_scheme{fold-right}, except that
it combines elements working in the opposite direction:
#+end_quote

#+NAME: fold-left
#+BEGIN_SRC scheme
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
#+END_SRC

#+begin_quote
What are the values of
#+end_quote

#+BEGIN_SRC scheme
(fold-right / 1 (list 1 2 3))
(fold-left / 1 (list 1 2 3))
(fold-right list nil (list 1 2 3))
(fold-left list nil (list 1 2 3))
#+END_SRC

*** Answer A

#+BEGIN_SRC scheme -n :eval no-export :results output
<<accumulate>>
(define fold-right accumulate)
<<fold-left>>
<<echo>>
(echo "(fold-right / 1 (list 1 2 3)):" (fold-right / 1 (list 1 2 3)))
(echo "(fold-left / 1 (list 1 2 3)):" (fold-left / 1 (list 1 2 3)))
(echo "(fold-right list nil (list 1 2 3))" (fold-right list '() (list 1 2 3)))
(echo "(fold-left list nil (list 1 2 3))" (fold-left list '() (list 1 2 3)))
#+END_SRC

#+RESULTS[edb1fd1da51fab72944ecd7d48d6c7fb5fcecf0c]:
#+begin_EXAMPLE
(fold-right / 1 (list 1 2 3)): 3/2 
(fold-left / 1 (list 1 2 3)): 1/6 
(fold-right list nil (list 1 2 3)) (1 (2 (3 ()))) 
(fold-left list nil (list 1 2 3)) (((() 1) 2) 3) 
#+end_EXAMPLE

*** Question B

#+begin_quote
Give a property that src_scheme{op} should satisfy to guarantee that
src_scheme{fold-right} and src_scheme{fold-left} will produce the same values
for any sequence.
#+end_quote

*** Answer B

They would need to be commutative, like addition and multiplication.

#+BEGIN_SRC scheme -n :eval no-export :results output
(load "mattcheck2.scm")
<<accumulate>>
(define fold-right accumulate)
<<fold-left>>
<<echo>>

(let* ((l (list 1 2 3 4 5))
      (lr (reverse l)))
  (mattcheck "commutative addition"
             (fold-right + 0 l)
             (fold-right + 0 lr)
             (fold-left + 0 l)
             (fold-left + 0 lr))
  (mattcheck "commutative multiplication"
             (fold-right * 1 l)
             (fold-right * 1 lr)
             (fold-left * 1 l)
             (fold-left * 1 lr)))
#+END_SRC

#+RESULTS[5ad69833502a5f98440ab8c1428a37f721d936d8]:
#+begin_EXAMPLE
SUCCEED at commutative addition
SUCCEED at commutative multiplication
#+end_EXAMPLE

** Exercise 2.39: reverse via fold

*** Question

#+begin_quote
Complete the following
definitions of src_scheme{reverse} (Exercise 2.18) in terms of
src_scheme{fold-right} and src_scheme{fold-left} from Exercise 2.38:
#+end_quote

#+BEGIN_SRC scheme
(define (reverse sequence)
  (fold-right (lambda (x y) <??>) nil sequence))
(define (reverse sequence)
  (fold-left (lambda (x y) <??>) nil sequence))
#+END_SRC

*** Answer

First, I'd like to start using the SRFI folds instead. This is my little "compatibility module".

#+NAME: fold-compat
#+BEGIN_SRC scheme -n :eval no-export :results silent
;; SICP compat
(use-srfis '(1))
(define accumulate fold-right)
(define fold-left fold)
#+END_SRC

Now to the problem.

#+NAME: reverse-fold
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<fold-compat>>
(define (reverse-fr sequence)
  (fold-right (lambda (x y)
                (append  y (list x)))
              '() sequence))
(define (reverse-fl sequence)
  (fold-left (lambda (x y)
               (append (list x) y))
             '() sequence))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :results output
(load "mattcheck2.scm")
<<reverse-fold>>
(let ((l (iota 5))
      (lr (reverse (iota 5))))
  (mattcheck "reverse-fr"
             (reverse-fr l)
             lr)
  (mattcheck "reverse-fl"
             (reverse-fl l)
             lr))
#+END_SRC

#+RESULTS[9c46803977b5337a2f802d5a3b2974e694a6f184]:
#+begin_EXAMPLE
SUCCEED at reverse-fr
SUCCEED at reverse-fl
#+end_EXAMPLE

** Exercise 2.40: ~unique-pairs~

*** Text Definitions
#+NAME: enumerate-interval
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (enumerate-interval low high)
  (if (> low high)
      '()
      (cons low 
            (enumerate-interval 
             (+ low 1) 
             high))))
#+END_SRC

#+NAME: flatmap
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<fold-compat>>
(define (flatmap proc seq)
  (accumulate append '() (map proc seq)))
#+END_SRC
#+NAME: prime-sum-txt
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<flatmap>>
<<enumerate-interval>>
<<prime-smallest-divisor>>
(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))
(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum? (flatmap
                           (lambda (i)
                             (map (lambda (j) (list i j))
                                  (enumerate-interval 1 (- i 1))))
                           (enumerate-interval 1 n)))))
#+END_SRC

*** Question

#+begin_quote
Define a procedure src_scheme{unique-pairs} that, given an integer \(n\),
generates the sequence of pairs \((i, j)\) with \(1 \le j < i \le n\). Use
src_scheme{unique-pairs} to simplify the definition of
src_scheme{prime-sum-pairs} given above.
#+end_quote

*** Answer

#+NAME: unique-pairs
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<fold-compat>>
<<enumerate-interval>>
<<flatmap>>
(define (unique-pairs n)
  (flatmap
   (lambda (i)
     (map (lambda (j) (list i j))
          (enumerate-interval 1 (- i 1))))
   (enumerate-interval 1 n)))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :results output
(load "mattcheck2.scm")
<<unique-pairs>>
(let ((target 5)
      (answer (list (list 2 1)(list 3 1)(list 3 2)(list 4 1)
                    (list 4 2)(list 4 3)(list 5 1)(list 5 2)
                    (list 5 3)(list 5 4))))
  (mattcheck "unique-pairs"
             (unique-pairs target)
             answer))
<<echo>>
<<prime-sum-txt>>
(define (prime-sum-pairs-mine n)
  (map make-pair-sum
       (filter prime-sum?
               (unique-pairs n))))
(let ((answer (list (list 2 1 3) (list 3 2 5)
                    (list 4 1 5) (list 4 3 7)
                    (list 5 2 7)) ))
  (mattcheck "prime-sum-pairs with unique-pairs"
             (prime-sum-pairs-mine 5)
             answer))
#+END_SRC

#+RESULTS[988b22bf9eb3b02ea8f747d85a86683cd6fb86a2]:
#+begin_EXAMPLE
SUCCEED at unique-pairs
SUCCEED at prime-sum-pairs with unique-pairs
#+end_EXAMPLE

** Exercise 2.41: Ordered triples of positive integers

*** Question

#+begin_quote
Write a procedure to find all ordered triples of distinct positive integers
\(i\), \(j\), and \(k\) less than or equal to a given integer \(n\) that sum to
a given integer \(s\).
#+end_quote

*** Answer

#+NAME: unique-triplets
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<fold-compat>>
<<enumerate-interval>>
<<flatmap>>
(define (unique-triplets n)
  (flatmap (λ(i)
             (flatmap (λ(j)
                        (map (λ(k) (list i j k))
                             (enumerate-interval 1 (- j 1))))
                      (enumerate-interval 1 (- i 1))))
           (enumerate-interval 1 n)))
#+END_SRC

#+NAME: triplets-sum
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (triplets-sum n s)
  (filter (λ(triplet)
            (= s (fold + 0 triplet)))
          (unique-triplets n)))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :results output
(load "mattcheck2.scm")
<<unique-triplets>>
<<triplets-sum>>
(let ((answer-a
       (list (list 3 2 1) (list 4 2 1)
             (list 4 3 1) (list 4 3 2)
             (list 5 2 1) (list 5 3 1)
             (list 5 3 2) (list 5 4 1)
             (list 5 4 2) (list 5 4 3)))
      (answer-b
       (list (list 5 3 2) (list 5 4 1)
             (list 6 3 1) (list 7 2 1))))
  (mattcheck "unique-triplets"
             (unique-triplets 5)
             answer-a)
  (mattcheck "triplets-sum"
             (triplets-sum 7 10)
             answer-b))
#+END_SRC

#+RESULTS[9df032ed4872a86df8c5b51fbdf014c1aaf32a66]:
#+begin_EXAMPLE
SUCCEED at unique-triplets
SUCCEED at triplets-sum
#+end_EXAMPLE

** Exercise 2.42: Eight Queens

*** Question

#+begin_quote
The ``eight-queens puzzle'' asks how to place eight queens on a chessboard so
that no queen is in check from any other.
#+end_quote

#+NAME: queens-txt
#+begin_src scheme -n :eval no-export :results silent
<<flatmap>>
<<enumerate-interval>>
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position
                    new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
#+end_src

#+begin_quote
Complete the program by writing the following:
- representation for sets of board positions, including:
  - src_scheme{adjoin-position}, which adjoins a new row-column position to a
    set of positions
  - src_scheme{empty-board}, which represents an empty set of positions.
- src_scheme{safe?}, which determines for a set of positions, whether the queen
  in the \(k^{\mathrm{th\)}} column is safe with respect to the others. (Note
  that we need only check whether the new queen is safe---the other queens are
  already guaranteed safe with respect to each other.)
#+end_quote

*** Answer

#+NAME: queens-mine
#+begin_src scheme -n :eval no-export :results silent
(define empty-board '())
(define (adjoin-position new-row column rest-of-queens)
  (cons (list new-row column) rest-of-queens))
(define (newer-position board)
  (car board))
(define (older-positions board)
  (cdr board))
(define (get-row position)
  (car position))
(define (get-column position)
  (cadr position))
(define (safe? k board)
  (define (same-row? a b)
    (= (get-row a) (get-row b)))
  (define (diagonal? a b)
    (let ((row-diff (abs (- (get-row a) (get-row b))))
          (col-diff (abs (- (get-column a) (get-column b)))))
      (= row-diff col-diff)))
  (let* ((new (newer-position board))
         (compare (older-positions board)))
    (and-map (λ(pos)
               (not (or (same-row? new pos)
                   (diagonal? new pos))))
             compare)))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :results output
<<queens-txt>>
<<queens-mine>>
(load "mattcheck2.scm")
(let ((q4 '(((3 4) (1 3) (4 2) (2 1))
            ((2 4) (4 3) (1 2) (3 1))))
       (q11l 2680))
  (mattcheck "queens"
             (list (queens 4)
                   (length (queens 11)))
             (list q4 q11l)))
#+END_SRC

#+RESULTS[2dd4171d68897629f5da1e8105a84caae4816775]:
#+begin_EXAMPLE
SUCCEED at queens
#+end_EXAMPLE

** Exercise 2.43: Louis' ~queens~

*** Question

#+begin_quote
Louis Reasoner is having a terrible time doing Exercise 2.42. His
src_scheme{queens} procedure seems to work, but it runs extremely slowly. (Louis
never does manage to wait long enough for it to solve even the \(6\times6\)
case.) When Louis asks Eva Lu Ator for help, she points out that he has
interchanged the order of the nested mappings in the src_scheme{flatmap},
writing it as
#+end_quote

#+BEGIN_SRC scheme
(flatmap
 (lambda (new-row)
   (map (lambda (rest-of-queens)
          (adjoin-position new-row k rest-of-queens))
        (queen-cols (- k 1))))
 (enumerate-interval 1 board-size))
#+END_SRC

#+begin_quote
Explain why this interchange makes the program run slowly. Estimate how long it
will take Louis's program to solve the eight-queens puzzle, assuming that the
program in Exercise 2.42 solves the puzzle in time \(T\).
#+end_quote

*** Answer

The biggest contributor to the slowdown is likely the location of the
src_scheme{queen-cols} recursive call. This call being inside of the loop means
it is being called \(k\) more times, all returning the same answer. But my math reasoning skills limit me from going further .Let's check
with benchmarks.

#+NAME: queens-benched
#+begin_src scheme -n :eval no-export :results silent :tangle 2/Ex43.scheme
<<queens-txt>>
<<queens-mine>>
(load "../mattbench.scm")

(define (queens-louis board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (new-row)
            (map (lambda (rest-of-queens)
                   (adjoin-position new-row k rest-of-queens))
                 (queen-cols (- k 1))))
          (enumerate-interval 1 board-size)))))
  (queen-cols board-size))

(define (test size)
  (format #t "~&normal queens x~a: ~a" size
          (mattbench (λ()(queens size)) 10000))
  (format #t "~&swapped queens x~a: ~a" size
          (mattbench (λ()(queens-louis size)) 1000)))

(map (λ(n)
       (test n))
     (enumerate-interval 5 8))
#+END_SRC

#+RESULTS[d2fc9e1933fd0086e5c7eda60b5d215be3f45878]: queens-benched
#+begin_EXAMPLE
normal queens x5: 135424.6151
swapped queens x5: 5487381.643
normal queens x6: 538798.604
swapped queens x6: 85704466.218
normal queens x7: 2210394.5659
swapped queens x7: 1255288880.717
normal queens x8: 8067290.5992
swapped queens x8: 25384464494.259
#+end_EXAMPLE

#+NAME: queensdata
#+BEGIN_SRC scheme -n :eval no-export :results value table :exports none
(list (list "size k" "normal time" "louis time")
      (list 5 135424.6151 5487381.643)
      (list 6 538798.604 85704466.218)
      (list 7 2210394.5659 1255288880.717)
      (list 8 8067290.5992 25384464494.259))
#+END_SRC

#+RESULTS[38434fb32a1c58a40c63a971c290754ea66b0363]: queensdata
| size k |  normal time |      louis time |
|      5 |  135424.6151 |     5487381.643 |
|      6 |   538798.604 |    85704466.218 |
|      7 | 2210394.5659 |  1255288880.717 |
|      8 | 8067290.5992 | 25384464494.259 |

#+begin_src gnuplot :var data=queensdata :file 2/fig/2-43.png :exports results :rownames no :colnames no :hlines no :cache no :eval no-export :session nil
reset
set key autotitle columnheader
set logscale y
set xlabel 'time taken'
#set xtics (2, 4, 8, 16, 24, 32, 36, 49, 64)
set ylabel 'size k'
set title 'time taken for queens board size k'

plot data using 2:xticlabels(1) with linespoints, \
     data using 3:xticlabels(1) with linespoints
#+end_src

#+RESULTS:
:results:
[[file:2/fig/2-43.png]]
:end:

So that's 40 times worse at 5x5, 159 times worse at 6x6, 568 times worse at 7x7,
and 3146 times at 8x8.



** 2.2.4: Example: A Picture Language

Authors describe a possible implementation of a "picture language" that tiles,
patterns, and warps images according to a specification. This language consists
of:

- a *painter* which makes an image within a specified parallelogram shaped
  frame. This is the most primitive element.
- *Operations* which make new painters from other painters. For example:
  - /beside/ takes two painters, producing a new painter that puts one in the
    left half and one in the right half.
  - /flip-horiz/ takes one painter and produces another to draw its image
    right-to-left reversed. These are defined as Scheme procedures and therefore
    have all the properties of Scheme procedures.   

I'm going to have to get a little messy in order to make the picture language a
reality. First I need a support library called [[https://git.elephly.net/gitweb.cgi?p=software/guile-picture-language.git;a=blob;f=pict.scm;h=54f0ce09f4ac33c3ecc3340f038d4c9da5f4a443;hb=HEAD][guile-picture-language]]. I
installed Guix on my system and ran src_bash{guix shell guile-picture-language
guile}. Now the src_scheme{pict} module is availale to me.

#+BEGIN_SRC scheme -n :eval no-export :results value
(use-modules (pict))
(pict->file (triangle 50 70)
           "2/pict/test.svg")
#+END_SRC

#+RESULTS[82505b44829f47d4c32c3a57ede30655376e2a61]:
[[file:2/pict/test.png]]

So that works.

How about this?

#+BEGIN_SRC scheme -n :eval no-export :results value
(use-modules (pict))
(let* ((p (pict-from-file "2/pict/Potato.png"))
       (pr (rotate p 180)))
(pict->file
 (scale (ht-append (vl-append pr p) pr p (vc-append pr p))
        0.5)
 "2/pict/Rotato.svg")) ;; must be SVG
#+END_SRC

#+RESULTS[cec397842ea51d3c519277b4aadef5d922398749]:
file:2/pict/Rotato.png

And I just realized there's no flip/mirror function in this library. Racket's
picture language is more complete, but it won't integrate with org-mode how I
need. Maybe I can mock up a text-based version, similar to the binary mobile,
and simultaneously check my work with Racket.

#+BEGIN_SRC scheme -n :eval no-export :results value
;; tilting at windmills trying to make a text-only picture language
;; TODO, probably won't finish
(define pl-defaultsize 32)
(define (make-painter orientation height width)
  (cons orientation (cons a b)))
(define (p-orientation p)
  (car p))
(define (p-height p)
  (cadr p))
(define (p-width p)
  (cddr p))
(define (opposite orientation)
  (cond ((eq? orientation 'down) 'up)
        ((eq? orientation 'up ) 'down)
        ((eq? orientation 'left) 'right)
        ((eq? orientation 'right) 'left)))
(define (flip-p p)
  (make-painter (opposite (p-orientation p))))
(define (below a b)
  (make-painter 'down a b))
(define (beside a b)
  (make-painter 'right a b))
(define (flip-vert p)
  (if (pair? p)
      (make-painter ))
(define (paint pict)
  (define (rect p x y)
    (cond ((string? p)
           )))
  (rec p pl-defaultsize pl-defaultsize))
(define (beside a b)
  (hc-append a b))
(define (below a b)
  (vc-append a b))
#+END_SRC


** Exercise 2.44: ~up-split~

*** Text Definitions

#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (right-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (right-split painter 
                                  (- n 1))))
        (beside painter 
                (below smaller smaller)))))
#+END_SRC

*** Question

#+begin_quote
Define the procedure src_scheme{up-split} used by src_scheme{corner-split}. It
is similar to src_scheme{right-split}, except that it switches the roles of
src_scheme{below} and src_scheme{beside}.
#+end_quote

*** Answer

#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (up-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (up-split painter 
                               (- n 1))))
        (below painter 
               (beside smaller smaller)))))
#+END_SRC

** Exercise 2.45: Generalized splitting

*** Question

#+begin_quote
src_scheme{right-split} and src_scheme{up-split} can be expressed as instances
of a general splitting operation. Define a procedure src_scheme{split} with the
property that evaluating
#+end_quote

#+BEGIN_SRC scheme -n :eval no-export :results silent
(define right-split (split beside below))
(define up-split (split below beside))
#+END_SRC

#+begin_quote
produces procedures src_scheme{right-split} and src_scheme{up-split} with the
same behaviors as the ones already defined.
#+end_quote

*** Answer

#+NAME: splits-generalized
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (split f1 f2)
  (define (rec painter n)
    (if (= n 0)
        painter
        (let ((smaller (rec painter 
                            (- n 1))))
          (f1 painter 
              (f2 smaller smaller)))))
  rec)
(define right-split (split beside below))
;; This one goes down for some reason?
;(define up-split (split below beside))
(define (up-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (up-split painter 
                               (- n 1))))
        (below painter 
               (beside smaller smaller)))))
#+END_SRC

** Exercise 2.46: Defining vectors

*** Question

#+begin_quote
A two-dimensional vector \(\hbox{\bf v}\) running from the origin to a point can
be represented as a pair consisting of an \(x\)-coordinate and a
\(y\)-coordinate. Implement a data abstraction for vectors by giving a
constructor src_scheme{make-vect} and corresponding selectors
src_scheme{xcor-vect} and src_scheme{ycor-vect}. In terms of your selectors and
constructor, implement procedures src_scheme{add-vect}, src_scheme{sub-vect},
and src_scheme{scale-vect} that perform the operations vector addition, vector
subtraction, and multiplying a vector by a scalar:

\[
\begin{array}{r@{{}={}}l}
	(x_1, y_1) + (x_2, y_2) 	& (x_1 + x_2, y_1 + y_2), \\
	(x_1, y_1) - (x_2, y_2) 	& (x_1 - x_2, y_1 - y_2), \\
	s \cdot (x, y) 			& (sx, sy).
\end{array}
\]
#+end_quote

*** Answer

This is pretty close to the src_scheme{make-point} work done in Exercise 2.2, as well as my 2nd implementation of a rectangle in Exercise 2.3. Let's start there. Also, /aren't these points and not vectors since they don't have direction??/

#+NAME: force-float
#+BEGIN_SRC scheme -n :eval no-export :results silent
;; Guarentee x is a float
(define (float x)
  (if (inexact? x)
      x
      (exact->inexact x)))
#+end_src

#+NAME: make-vect
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<force-float>>
(define (make-vect x y)
  (cons (float x)
        (float y))) ;; make-point
(define (xcor-vect v)
  (car v)) ;; x-point
(define (ycor-vect v)
  (cdr v)) ;; y-point
(define (add-vect v w)
  (make-vect (+ (xcor-vect v)
                (xcor-vect w))
             (+ (ycor-vect v)
                (ycor-vect w))))
(define (sub-vect v w)
  (make-vect (- (xcor-vect v)
                (xcor-vect w))
             (- (ycor-vect v)
                (ycor-vect w))))
(define (scale-vect s v)
  (make-vect (* s (xcor-vect v))
             (* s (ycor-vect v))))
#+end_src

I originally got the definition for src_scheme{scale-vect} wrong by making it
src_scheme{(scale v s)}, then modified src_scheme{frame-coord-map} when that
broke. I realized my mistake once I went to write src_scheme{beside}.

** Exercise 2.47: Defining frames

*** Question

#+begin_quote
Here are two possible
constructors for frames:
#+end_quote

#+BEGIN_SRC scheme -n
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))
(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
#+END_SRC

#+begin_quote
For each constructor supply the appropriate selectors to produce an
implementation for frames.
#+end_quote

*** Answer

#+BEGIN_SRC scheme -n
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))
(define (origin-frame F)
  (car F))
(define (edge1-frame F)
  (cadr F))
(define (edge2-frame F)
  (caddr F))
#+END_SRC
#+NAME: make-frame
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
(define (origin-frame F)
  (car F))
(define (edge1-frame F)
  (cadr F))
(define (edge2-frame F)
  (cddr F))
#+END_SRC

** Exercise 2.48: Line segments

*** Question

#+begin_quote
A directed line segment in the plane can be represented as a pair of
vectors---the vector running from the origin to the start-point of the segment,
and the vector running from the origin to the end-point of the segment. Use your
vector representation from Exercise 2.46 to define a
representation for segments with a constructor src_scheme{make-segment} and
selectors src_scheme{start-segment} and src_scheme{end-segment}.
#+end_quote

*** Answer

Again reminding me of Exercise 2.2.

#+NAME: make-segment
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (make-segment start end)
  (cons start end))
(define (start-segment seg)
  (car seg))
(define (end-segment seg)
  (cdr seg))
#+END_SRC

** Exercise 2.49: Primitive painters

*** Text Definitions

#+NAME: segments-painter
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (frame-coord-map frame)
  (lambda (v)
    (add-vect
     (origin-frame frame)
     (add-vect 
      (scale-vect (xcor-vect v)
                  (edge1-frame frame))
      (scale-vect (ycor-vect v)
                  (edge2-frame frame))))))
(define (segments->painter segment-list)
  (lambda (frame)
    (for-each
     (lambda (segment)
       (draw-line
        ((frame-coord-map frame)
         (start-segment segment))
        ((frame-coord-map frame)
         (end-segment segment))))
     segment-list)))
#+END_SRC

*** Question

#+begin_quote
Use src_scheme{segments->painter}
to define the following primitive painters:

a. The painter that draws the outline of the designated frame.
b. The painter that draws an =X= by connecting opposite corners of the frame.
c. The painter that draws a diamond shape by connecting the midpoints of the
   sides of the frame.
d. The src_scheme{wave} painter.
#+end_quote

*** Answer

In the past I would need to constantly execute my code to "see" what I'm doing.
But I'm starting to think in larger chunks and need the feedback less.


#+NAME: painters
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<continuous-lines>>
(define outline
  (segments->painter (list
   (make-segment (make-vect 0 0)
                 (make-vect 0 1))
   (make-segment (make-vect 0 1)
                 (make-vect 1 1))
   (make-segment (make-vect 1 1)
                 (make-vect 1 0))
   (make-segment (make-vect 1 0)
                 (make-vect 0 0)))))
(define frame-X
  (segments->painter (list
   (make-segment (make-vect 0 0)
                 (make-vect 1 1))
   (make-segment (make-vect 0 1)
                 (make-vect 1 0)))))
(define diamond
  (segments->painter (list
   (make-segment (make-vect 0.5 0)
                 (make-vect 1 0.5))
   (make-segment (make-vect 1 0.5)
                 (make-vect 0.5 1))
   (make-segment (make-vect 0.5 1)
                 (make-vect 0 0.5))
   (make-segment (make-vect 0 0.5)
                 (make-vect 0.5 0)))))
#+END_SRC

I'll make the wave painter once I have some graph paper in front of me.

Ok, how can I verify this? I guess I could rewrite src_scheme{segments->painter}
for src_scheme{pict}. Since this isn't a drawing system with imperative
procedures, I should make it return a list of lines to be superimposed.
#+NAME: linepainter-pict
#+BEGIN_SRC scheme -n :eval no-export :results silent :tangle 2/pict/linepainter.scheme
(use-modules (pict))
<<make-frame>>
<<make-vect>>
<<make-segment>>
(define (frame-coord-map frame)
  ;; Returns a function for adjusting a frame by a vector
  (lambda (v)
    (add-vect
     (origin-frame frame)
     (add-vect 
      (scale-vect (xcor-vect v)
                  (edge1-frame frame))
      (scale-vect (ycor-vect v)
                  (edge2-frame frame))))))
(define (draw-line start end)
  ;; take two vectors, returns a line SVG object for pict
  (line (xcor-vect start)
        (ycor-vect start)
        (xcor-vect end)
        (ycor-vect end)))
(define (segments->painter segment-list)
  ;; takes a list of segments, returns a "painter" lambda, which applies a frame
  ;; to those segments and then maps over the result with draw-line to make a
  ;; list of SVG line objects which pict can combine.
  (lambda (frame)
    (map
     (lambda (segment)
       (draw-line
        ((frame-coord-map frame)
         (start-segment segment))
        ((frame-coord-map frame)
         (end-segment segment))))
     segment-list)))
;; NOTE: in the text, draw-line is a function which triggers an action in
;; some graphics driver, and returns nothing. Because of this, (map) was
;; originally (for-each). Thus the final result would have been thrown away.

<<painters>>

(define (paint-lines painter)
  ;; use pict to compile an SVG with the elements described by painter
  (let ((Frame (make-frame (make-vect 0 0)
                           (make-vect 500 0)
                           (make-vect 0 500))))
    (apply lt-superimpose
           (painter Frame))))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :results output
<<linepainter-pict>>
(pict->file (paint-lines diamond)
            "2/pict/testline.svg")
; #:maxw 100 #:maxh 100) <- FIXME: This procedure should take these arguments
; but I can't get it to work.
#+END_SRC

#+RESULTS[1166aed3387461ead23967b3741193798eacdc6f]:
[[file:2/pict/testline.png]]

Holy moly it actually works.

** Exercise 2.50: Transforming painters

*** Text Definitions

#+NAME: frame-transforms-txt
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (transform-painter 
         painter origin corner1 corner2)
  (lambda (frame)
    (let ((m (frame-coord-map frame)))
      (let ((new-origin (m origin)))
        (painter (make-frame new-origin
                             (sub-vect (m corner1) 
                                       new-origin)
                             (sub-vect (m corner2)
                                       new-origin)))))))

(define (flip-vert painter)
  (transform-painter 
   painter
   (make-vect 0.0 1.0)   ; new origin
   (make-vect 1.0 1.0)   ; new end of edge1
   (make-vect 0.0 0.0))) ; new end of edge2

(define (rotate90 painter)
  (transform-painter painter
                     (make-vect 1.0 0.0)
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 0.0)))

(define (squash-inwards painter)
  (transform-painter painter
                     (make-vect 0.0 0.0)
                     (make-vect 0.65 0.35)
                     (make-vect 0.35 0.65)))
(define (beside painter1 painter2)
  (let ((split-point (make-vect 0.5 0.0)))
    (let ((paint-left  (transform-painter 
                        painter1
                        (make-vect 0.0 0.0)
                        split-point
                        (make-vect 0.0 1.0)))
          (paint-right (transform-painter
                        painter2
                        split-point
                        (make-vect 1.0 0.0)
                        (make-vect 0.5 1.0))))
      (lambda (frame)
        (append
         (paint-left frame)
         (paint-right frame))))))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :results output :exports none
<<linepainter-pict>>
<<frame-transforms-txt>>
(define topleft-tri
  (segments->painter (list
                      (make-segment (make-vect 0 0)
                                    (make-vect 0 0.4))
                      (make-segment (make-vect 0 0.4)
                                    (make-vect 0.8 0))
                      (make-segment (make-vect 0.8 0)
                                    (make-vect 0 0)))))
(let ((picture topleft-tri))
(pict->file (paint-lines picture)
            "2/pict/tritest.svg"))
#+END_SRC

#+RESULTS[3b6460ef9bcc8e250580413268114952f9769c86]:
[[file:2/pict/tritest.png]]

#+BEGIN_SRC scheme -n :eval no-export :results output
<<linepainter-pict>>
<<frame-transforms-txt>>
(define topleft-tri
  (segments->painter (list
                      (make-segment (make-vect 0 0)
                                    (make-vect 0 0.4))
                      (make-segment (make-vect 0 0.4)
                                    (make-vect 0.4 0))
                      (make-segment (make-vect 0.4 0)
                                    (make-vect 0 0)))))
(let ((picture (beside (beside topleft-tri
                               topleft-tri)
                       (rotate90 topleft-tri))))
(pict->file (paint-lines picture)
            "2/pict/rotatetest.svg"))
#+END_SRC

#+RESULTS[83fca324a30d1ea587072343d0fb160304d8cf31]:
[[file:2/pict/rotatetest.png]]

*** Question

#+begin_quote
Define the transformation src_scheme{flip-horiz}, which flips painters
horizontally, and transformations that rotate painters counterclockwise by 180
degrees and 270 degrees.
#+end_quote

*** Answer

#+NAME: flip-rotate2
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (flip-horiz painter)
  (transform-painter 
   painter
   (make-vect 1.0 0.0)   ; new origin
   (make-vect 0.0 0.0)   ; new end of edge1
   (make-vect 1.0 1.0))) ; new end of edge2

(define (rotate180 painter)
  (transform-painter painter
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 1.0)
                     (make-vect 1.0 0.0)))
(define (rotate270 painter)
  (transform-painter painter
                     (make-vect 0.0 1.0)
                     (make-vect 0.0 0.0)
                     (make-vect 1.0 1.0)))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :results output
<<linepainter-pict>>
<<frame-transforms-txt>>
<<flip-rotate2>>
(define topleft-tri
  (segments->painter (list
                      (make-segment (make-vect 0 0)
                                    (make-vect 0 0.4))
                      (make-segment (make-vect 0 0.4)
                                    (make-vect 0.8 0))
                      (make-segment (make-vect 0.8 0)
                                    (make-vect 0 0)))))
(let ((picture (beside (beside
                        (flip-vert topleft-tri)
                        (rotate90 topleft-tri))
                       (beside
                        (rotate180 topleft-tri)
                        (rotate270 topleft-tri)))))
  (pict->file (paint-lines picture)
              "2/pict/rotate2.svg"))
#+END_SRC

#+RESULTS[942a1cdf3a5aed31c833cf37149bb4e09ea82074]:
[[file:2/pict/rotate2.png]]

** Exercise 2.51

*** Question

#+begin_quote
Define the src_scheme{below} operation
for painters.  src_scheme{below} takes two painters as arguments.  The resulting
painter, given a frame, draws with the first painter in the bottom of the frame
and with the second painter in the top.  Define src_scheme{below} in two different
ways---first by writing a procedure that is analogous to the src_scheme{beside}
procedure given above, and again in terms of src_scheme{beside} and suitable
rotation operations (from @ref{Exercise 2.50}).
#+end_quote

*** Answer

#+NAME: below
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (below painter1 painter2)
  (let ((split-point (make-vect 0.0 0.5)))
    (let ((paint-left  (transform-painter 
                        painter1
                        (make-vect 0.0 0.0)
                        (make-vect 1.0 0.0)
                        split-point))
          (paint-right (transform-painter
                        painter2
                        split-point
                        (make-vect 1.0 0.5)
                        (make-vect 0.0 1.0))))
      (lambda (frame)
        (append
         (paint-left frame)
         (paint-right frame))))))
(define (below-rotate painter1 painter2)
  (rotate270 (beside
              (rotate90 painter2)
              (rotate90 painter1))))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :results output
<<linepainter-pict>>
<<frame-transforms-txt>>
<<flip-rotate2>>
<<below>>
(define topleft-tri
  (segments->painter (list
                      (make-segment (make-vect 0 0)
                                    (make-vect 0 0.4))
                      (make-segment (make-vect 0 0.4)
                                    (make-vect 0.8 0))
                      (make-segment (make-vect 0.8 0)
                                    (make-vect 0 0)))))
(let ((p1 (below (beside
                        topleft-tri
                        (rotate90 topleft-tri))
                       (beside
                        (rotate180 topleft-tri)
                        (rotate270 topleft-tri))))
      (p2 (below-rotate (beside
                        topleft-tri
                        (rotate90 topleft-tri))
                       (beside
                        (rotate180 topleft-tri)
                        (rotate270 topleft-tri)))))
  (pict->file (paint-lines (beside p1 p2))
              "2/pict/rotate3.svg"))
#+END_SRC

#+RESULTS[419f2a4c29ab56d2d3463e20b1f63864eb193dcf]:
[[file:2/pict/rotate3.png]]

An aside: I'm beginning to see what makes Lisp-style programming different from
C style. In C, the pictures would be described with separate data structures
specified up front, but in Lisp you can use the code to create the data
structure. Off the top of my head, the biggest players here would be first-level
functions, and how statements evaluate to specific values rather than being
imperative commands that cause something to happen elsewhere.

** 2.2.4 continued

- stratified design :: is the notion that complex systems should be structured
  as a sequence of levels with a sequence of languages. See how electronic
  components are described in EE terms, the binary gates they form are described
  in digital logic terms, the programs they run described in programming
  language terms, the networks of programs described in network architecture
  terms, etc.

This stratified design can be seen in our picture language. We use lines and
points to specify painters, use painters to make arrangements with beside/below,
arrange these arrangements into higher-level arrangements like
src_scheme{up-split}.

** Exercise 2.52

*** Question A

Make changes to the square limit of src_scheme{wave} shown in Figure 2.9 by
working at each of the levels described above. In particular:

- Add some segments to the primitive src_scheme{wave} painter of Exercise 2.49 (to add a smile, for example).

*** Answer A

I need to do what I've been slacking off on: actually making the src_scheme{wave} painter.
First, I want a helper function to make inputting shapes easier.


#+NAME: unwrap-if-needed
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (unwrap-if-needed args)
  ;; commonly needed in vararg functions
  (if (and (= 1 (length args))
           (list? (car args)))
      (car args) ; assume we were passed a list, unwrap it
      args))
#+END_SRC
#+NAME: continuous-lines
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<unwrap-if-needed>>
(define (continuous-lines . vectors)
  ;; Given a list of vectors, return a series of line segments
  ;; that continuously follow the vectors until there are no more,
  ;; at which point connect the last vector to the first.
  (define (iter vecs lines)
    (if (> 2 (length vecs))
        lines
        (let* ((first (car vecs))
               (rest (cdr vecs))
               (second (car rest))
               (new-line (make-segment first second)))
          (iter rest (cons new-line lines)))))
  (let ((input (unwrap-if-needed vectors)))
    (iter (append input (list (car input))) ;; Connect to start
          '())))
(define (numbers-to-vectors . numbers)
  (define (iter input output)
    (if (> 2 (length input))
        output
        (let* ((first (car input))
              (d (cdr input))
              (second (car d))
              (dd (cdr d)))
          (iter dd
                (cons (make-vect first second)
                      output)))))
  (reverse (iter numbers '())))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :results output
<<linepainter-pict>>
<<frame-transforms-txt>>
<<flip-rotate2>>
<<below>>
<<continuous-lines>>
(define topleft-tri
  (segments->painter (list
                      (make-segment (make-vect 0 0)
                                    (make-vect 0 0.4))
                      (make-segment (make-vect 0 0.4)
                                    (make-vect 0.8 0))
                      (make-segment (make-vect 0.8 0)
                                    (make-vect 0 0)))))
(define topleft-tri2
  (segments->painter (continuous-lines
                      (make-vect 0 0)
                      (make-vect 0 0.4)
                      (make-vect 0.8 0))))
(define topleft-tri3
  (segments->painter (continuous-lines
                      (numbers-to-vectors
                       0 0
                       0 0.4
                       0.8 0))))
(let ((p1 (below (beside topleft-tri topleft-tri2)
                 (beside topleft-tri topleft-tri3))))
  (pict->file (paint-lines p1)
              "2/pict/cl-test.svg"))
#+END_SRC

#+RESULTS[a2ef690a540771b7f579b7987827d14b86b9d47a]:
[[file:2/pict/cl-test.png]]

Now, let's write the wave painter.

#+NAME: wave-painter
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<continuous-lines>>
;; Should be raising their left hand and
;; lowering their right. (I screwed up the axes)
(define wave
  (segments->painter
   (continuous-lines
    (numbers-to-vectors
    0.55 0
    0.5 0.15 ;; center-left side of head
    0.55 0.3
    0.45 0.275
    0.25 0.35
    0 0.25
    0 0.3
    0.25 0.45
    0.45 0.35
    0.5 0.65
    0.4 1
    0.45 1
    0.6 0.7
    0.75 1
    0.8 1
    0.7 0.65
    0.75 0.35
    1 0.675
    1 0.6
    0.75 0.275
    0.65 0.3
    0.7 0.15 ;; center-right side of head
    0.65 0))))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :results output
<<linepainter-pict>>
<<frame-transforms-txt>>
<<flip-rotate2>>
<<below>>
<<continuous-lines>>
<<wave-painter>>
(let ((p1 (beside wave (flip-vert wave))))
  (pict->file (paint-lines p1)
              "2/pict/wave-test.svg"))
#+END_SRC

The question needs me to overlay something new. So I need some way to add more
segments to a painter after it's already been written.

#+RESULTS[7339620f004b1a5970840eb4d2ccfd0f7fcb976d]:
[[file:2/pict/wave-test.png]]

#+NAME: append-painters
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<unwrap-if-needed>>
(define (append-painters-rec . args)
  (lambda (frame)
    (define (rec painters)
      (if (null? painters)
          '()
          (append ((car painters) frame)
                  (rec (cdr painters)))))
    (rec (unwrap-if-needed args))))
(define (append-painters . args)
  (lambda (frame)
    (define (iter segments to-paint)
      (if (null? to-paint)
          segments
          (iter (append ((car to-paint) frame)
                      segments)
                      (cdr to-paint))))
    (iter '()
          (unwrap-if-needed args))))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :results output
<<linepainter-pict>>
<<frame-transforms-txt>>
<<flip-rotate2>>
<<below>>
<<continuous-lines>>
<<painters>>
<<wave-painter>>
<<append-painters>>
(let ((p1 (append-painters
           (beside wave (flip-vert wave))
           frame-X
           outline)))
  (pict->file (paint-lines p1)
              "2/pict/append-test.svg"))
#+END_SRC

#+RESULTS[c2ee764954c965185361915c7c56d64df1fbcf6b]:
[[file:2/pict/append-test.png]]

Now let's (try to) add a smile.

#+NAME: wave-smile
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<wave-painter>>
<<append-painters>>
(define wave-smile
  (append-painters
   wave
   (segments->painter
    (continuous-lines
     (numbers-to-vectors
      0.55 0.2
      0.6 0.225
      0.65 0.2)))))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :results output
<<linepainter-pict>>
<<frame-transforms-txt>>
<<flip-rotate2>>
<<below>>
<<continuous-lines>>
<<wave-smile>>
(pict->file (paint-lines wave-smile)
            "2/pict/wave-smile-test.svg")
#+END_SRC

#+RESULTS[4ce5d12349ed189f5e2be1faaf7793a4670f68b3]:
[[file:2/pict/wave-smile-test.png]]

*** Question B

Change the pattern constructed by src_scheme{corner-split} (for example, by
using only one copy of the src_scheme{up-split} and src_scheme{right-split}
images instead of two).

#+NAME: corner-split
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter 
                                (- n 1))))
        (let ((top-left (beside up up))
              (bottom-right (below right 
                                   right))
              (corner (corner-split painter 
                                    (- n 1))))
          (beside (below painter top-left)
                  (below bottom-right 
                         corner))))))

(define (corner-split-mine painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter 
                                (- n 1))))
        (let ((top-left up)
              (bottom-right right)
              (corner (corner-split-mine painter 
                                    (- n 1))))
          (beside (below painter top-left)
                  (below bottom-right 
                         corner))))))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :results output
<<linepainter-pict>>
<<frame-transforms-txt>>
<<flip-rotate2>>
<<below>>
<<continuous-lines>>
<<painters>>
<<wave-smile>>
<<append-painters>>
<<splits-generalized>>
<<corner-split>>
(let ((p1 (beside (flip-horiz (corner-split wave-smile 5))
                  (corner-split-mine wave-smile 5))))
;(let ((p1 (up-split frame-X 5)))
  (pict->file (paint-lines p1)
              "2/pict/corner-splits.svg"))
#+END_SRC

#+RESULTS[a1a1d7df20056fcf0986da88ad48dbda23a1a791]:
[[file:2/pict/corner-splits.png]]

So my modified version doesn't split at the ~corner-split~ level, as predicted.
However ~up-split~ and ~right-split~ do, so the effect is only delayed by one
level. But more importantly:

/Why does it go down instead of up? I don't get it./

~corner-split~ and ~up-split~ are even the same code as every answer online.
Could my ~paint-lines~ procedure be what's causing issues?

*** Question C

#+begin_quote
Modify the version of src_scheme{square-limit} that uses src_scheme{square-of-four} so as
to assemble the corners in a different pattern.  (For example, you might make
the big Mr. Rogers look outward from each corner of the square.)
#+end_quote

*** Textbook Definitions

#+NAME: square-of-four-txt
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (square-of-four tl tr bl br)
  (lambda (painter)
    (let ((top (beside (tl painter) 
                       (tr painter)))
          (bottom (beside (bl painter) 
                          (br painter))))
      (below bottom top))))
(define (square-limit painter n)
  (let ((combine4 
         (square-of-four flip-horiz 
                         identity
                         rotate180 
                         flip-vert)))
    (combine4 (corner-split painter n))))
#+END_SRC

*** Answer C

#+NAME: square-limit-mine
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (square-limit-mine painter n)
  (let ((combine4 
         (square-of-four identity
                         flip-horiz
                         flip-vert 
                         rotate180)))
    (combine4 (corner-split painter n))))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :results output
<<linepainter-pict>>
<<frame-transforms-txt>>
<<flip-rotate2>>
<<below>>
<<continuous-lines>>
<<wave-smile>>
<<splits-generalized>>
<<corner-split>>
<<square-of-four-txt>>
<<square-limit-mine>>
(pict->file (paint-lines (beside (square-limit wave-smile 5)
                                 (square-limit-mine wave-smile 5)))
            "2/pict/square-limits.svg")
#+END_SRC

#+RESULTS[111fcd56e310536b0fc3d2f409babc1ea1d841ef]:
[[file:2/pict/square-limits.png]]

Ok, I'm confused. Shouldn't the shape of ~square-limit~ be the same regardless
of the operators passed to it? It looks like the operators effect each chunk
separately.

#+BEGIN_SRC scheme -n :eval no-export :results output
<<linepainter-pict>>
<<frame-transforms-txt>>
<<flip-rotate2>>
<<below>>
<<continuous-lines>>
<<wave-smile>>
<<splits-generalized>>
<<corner-split>>
<<square-of-four-txt>>
(define (square-limit-mine painter n)
  (let ((combine4 
         (square-of-four identity
                         identity
                         identity
                         identity)))
    (combine4 (corner-split painter n))))
(pict->file (paint-lines (square-limit-mine wave-smile 5))
            "2/pict/square-limit-identity.svg")
#+END_SRC

#+RESULTS[0e130aa614fce200f3b764b2780d3360302f430f]:
[[file:2/pict/square-limit-identity.png]]

I expected the operators would change the /image orientation/, not the
/structure/. Maybe this is because my ~draw-lines~ makes recursively nested
stacks of painter objects, rather than imperative calls to drawing procedures?
Looking on the internet I see [[http://pipecode.blogspot.com/2013/04/sicp-exercise-252.html][someone else having the same results.]]

** 2.3.1: Quotation

Syntactic vs semantic use in Lisp:
#+BEGIN_SRC scheme
(define dog 123)
(+ dog dog) ;; semantic usage
(quote dog) ;; syntactic usage
#+END_SRC

This was introduced by famous LISP scientists, Abbott and Costello.

** Exercise 2.53

*** Question

#+begin_quote
What would the interpreter print
in response to evaluating each of the following expressions?
#+end_quote

#+BEGIN_SRC scheme -n
(list 'a 'b 'c)
(list (list 'george))
(cdr '((x1 x2) (y1 y2)))
(cadr '((x1 x2) (y1 y2)))
(pair? (car '(a short list)))
(memq 'red '((red shoes) (blue socks)))
(memq 'red '(red shoes blue socks))
#+END_SRC

*** Answer

#+BEGIN_SRC scheme -n
(list 'a 'b 'c) ;; (a b c)
(list (list 'george)) ;; ((george))
(cdr '((x1 x2) (y1 y2))) ;; ((y1 y2))
(cadr '((x1 x2) (y1 y2))) ;; (y1 y2)
(pair? (car '(a short list))) ;; false
(memq 'red '((red shoes) (blue socks))) ;; false
(memq 'red '(red shoes blue socks)) ;; (red shoes blue socks)
#+END_SRC

** Exercise 2.54

#+begin_quote
Two lists are said to be src_scheme{equal?} if they contain equal elements
arranged in the same order. For example,
#+end_quote

#+BEGIN_SRC scheme
(equal? '(this is a list) '(this is a list))
#+END_SRC

#+begin_quote
is true, but
#+end_quote

#+BEGIN_SRC scheme
(equal? '(this is a list) '(this (is a) list))
#+END_SRC

#+begin_quote
is false. To be more precise, we can define src_scheme{equal?} recursively in
terms of the basic src_scheme{eq?} equality of symbols by saying that
src_scheme{a} and src_scheme{b} are src_scheme{equal?} if they are both symbols
and the symbols are src_scheme{eq?}, or if they are both lists such that
src_scheme{(car a)} is src_scheme{equal?} to src_scheme{(car b)} and
src_scheme{(cdr a)} is src_scheme{equal?} to src_scheme{(cdr b)}. Using this
idea, implement src_scheme{equal?} as a procedure.
#+end_quote

*** Answer

#+NAME: my-equal?
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (equal? a b)
  (cond ((and (symbol? a)
              (symbol? b))
         (eq? a b))
        ((and (list? a)
              (list? b))
         (and (equal? (car a) (car b))
              (equal? (cdr a) (cdr b))))
        (else #f)))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :results output
(load "mattcheck2.scm")
(let ((a '(this is a list))
      (aa '(this is a list))
      (b '(this (quote is a) list)))
  (mattcheck "equal? true"
             (equal? a a))
  (mattcheck "equal? trick question"
             (equal? a a))
  (mattcheck "equal? false"
             (equal? a b)
             #f))
#+END_SRC

#+RESULTS[d1cdfcb742c0d48a6430788621584446115ff02c]:
#+begin_EXAMPLE
SUCCEED at equal? true
SUCCEED at equal? trick question
SUCCEED at equal? false
#+end_EXAMPLE

** Exercise 2.55

*** Question

Eva Lu Ator types to the interpreter the expression

#+BEGIN_SRC scheme
(car ''abracadabra)
#+END_SRC

To her surprise, the interpreter prints back src_scheme{quote}. Explain.

*** Answer

You're quoting quote, silly! Who's on first? 🙂

