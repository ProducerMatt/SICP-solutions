;; [[file:Answers.org::try-these][try-these]]
;; Surely this could be less nightmarish
(define (try-these f . testvals)
  (let ((l (if (and (= 1 (length testvals))
                    (list? (car testvals)))
               (car testvals)
               testvals)))
    (map (λ (i) (cons i
                      (cons (if (list? i)
                                (apply f i)
                                (f i))
                            #nil)))
         l)))
;; try-these ends here

;; [[file:Answers.org::transpose-list][transpose-list]]
(define (transpose-list l)
  (map list l))
;; transpose-list ends here

;; [[file:Answers.org::print-as-rows][print-as-rows]]
(define (p-nl a)
  (display a)
  (newline))
(define (print-spaced args)
  (let ((a (car args))
        (d (cdr args)))
    (if (null? d)
        (p-nl a)
        (begin (display a)
               (display " ")
               (print-spaced d)))))
(define (print-as-rows . args)
  (let ((a (car args))
        (d (cdr args)))
    (if (list? a)
        (if (= 1 (length args))
            (apply print-as-rows a)
            (print-spaced a))
        (p-nl a))
    (if (null? d)
        '()
        (apply print-as-rows d))))
;; print-as-rows ends here

;; [[file:Answers.org::print-table][print-table]]
(define* (print-table table #:key (colnames #f))
  (define* (print-row ll #:key (fmt " ~s |"))
    (format #t "~&|")
    (map (λ(x) (format #t fmt x)) ll)
    (format #t "~%"))
  (define (iter t)
    (print-row (car t))
    (if colnames
        (print-row (car t) #:fmt "---|"))
    (map print-row (cdr t)))
  (cond ((and (= 1 (length table))
              (list? (car table))) (iter (car table)))
        ((<= 1 (length table)) (iter table))
        (else error "Invalid Input??")))
;; print-table ends here

;; [[file:Answers.org::print-table-test][print-table-test]]
;; [[[[file:~/SICP-group/1/Answers.org::print-table][print-table]]][print-table]]
(define* (print-table table #:key (colnames #f))
  (define* (print-row ll #:key (fmt " ~s |"))
    (format #t "~&|")
    (map (λ(x) (format #t fmt x)) ll)
    (format #t "~%"))
  (define (iter t)
    (print-row (car t))
    (if colnames
        (print-row (car t) #:fmt "---|"))
    (map print-row (cdr t)))
  (cond ((and (= 1 (length table))
              (list? (car table))) (iter (car table)))
        ((<= 1 (length table)) (iter table))
        (else error "Invalid Input??")))
;; print-table ends here
(let* ((l (iota 3))
      (table (list
              (list 'column-1 'column-2 'column-3 'column-4)
              (cons 'row-a l)
              (cons 'row-b l)
              (cons 'row-c l))))
  (print-table table #:colnames #t ))
;; print-table-test ends here

;; [[file:Answers.org::square][square]]
(define (square x)
  (* x x))
;; square ends here

;; [[file:Answers.org::EX1-3][EX1-3]]
;; [[[[file:~/SICP-group/1/Answers.org::square][square]]][square]]
(define (square x)
  (* x x))
;; square ends here
(define (sum-square x y)
  (+ (square x) (square y)))
(define (square-2of3 a b c)
  (cond ((and (>= a b) (>= b c)) (sum-square a b))
        ((and (>= a b) (> c b)) (sum-square a c))
        (else (sum-square b c))))
;; EX1-3 ends here

;; [[file:Answers.org::abs][abs]]
(define (abs x)
  (if (< x 0)
	  (- x)
	  x))
;; abs ends here

;; [[file:Answers.org::average][average]]
(define (average x y)
  (/ (+ x y) 2))
;; average ends here

;; [[file:Answers.org::txt-sqrt][txt-sqrt]]
;; [[[[file:~/SICP-group/1/Answers.org::average][average]]][average]]
(define (average x y)
  (/ (+ x y) 2))
;; average ends here
(define (improve guess x)
  (average guess (/ x guess)))

;; [[[[file:~/SICP-group/1/Answers.org::square][square]]][square]]
(define (square x)
  (* x x))
;; square ends here
;; [[[[file:~/SICP-group/1/Answers.org::abs][abs]]][abs]]
(define (abs x)
  (if (< x 0)
	  (- x)
	  x))
;; abs ends here
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))

(define (sqrt x)
  (sqrt-iter 1.0 x))
;; txt-sqrt ends here

;; [[file:Answers.org::mean-square][mean-square]]
(define (mean-square x y)
  (average (square x) (square y)))
;; mean-square ends here

;; [[file:Answers.org::sqrt][sqrt]]
;; [[[[file:~/SICP-group/1/Answers.org::average][average]]][average]]
(define (average x y)
  (/ (+ x y) 2))
;; average ends here
(define (improve guess x)
  (average guess (/ x guess)))
(define (good-enough? guess x)
   (= (improve guess x) guess))
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
(define (sqrt x)
  (sqrt-iter 1.0 x))
;; sqrt ends here

;; [[file:Answers.org::cbrt][cbrt]]
;; [[[[file:~/SICP-group/1/Answers.org::square][square]]][square]]
(define (square x)
  (* x x))
;; square ends here
(define (cb-good-enough? nextguess guess lastguess x)
  (or (= nextguess guess)
      (= nextguess lastguess)))
(define (cb-improve guess x)
  (/
   (+
    (/ x (square guess))
    (* guess 2))
   3))
(define (cbrt-iter guess lastguess x)
  (define nextguess (cb-improve guess x))
  (if (cb-good-enough? nextguess guess lastguess x)
      nextguess
      (cbrt-iter nextguess guess x)))
(define (cbrt x)
  (cbrt-iter 1.1 9999 x))
;; cbrt ends here

;; [[file:Answers.org::ackermann][ackermann]]
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
;; ackermann ends here

;; [[file:Answers.org::EX1-10-defs][EX1-10-defs]]
;; [[[[file:~/SICP-group/1/Answers.org::ackermann][ackermann]]][ackermann]]
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
;; ackermann ends here
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
;; EX1-10-defs ends here

;; [[file:Answers.org::pascal-rec][pascal-rec]]
(define (pascal x y)
  (if (or (= x 0)
          (= y 0))
      1
      (+ (pascal (- x 1) y)
         (pascal x (- y 1)))))
;; pascal-rec ends here

;; [[file:Answers.org::fib-iter][fib-iter]]
(define (fib-iter n)
  (define (iter i a b)
    (if (= i n)
        b
    (iter (+ i 1)
          b
          (+ a b))))
  (if (<= n 2)
      1
      (iter 2 1 1)))
;; fib-iter ends here

;; [[file:Answers.org::fib-phi][fib-phi]]
;; [[[[file:~/SICP-group/1/Answers.org::sqrt][sqrt]]][sqrt]]
;; [[[[file:~/SICP-group/1/Answers.org::average][average]]][average]]
(define (average x y)
  (/ (+ x y) 2))
;; average ends here
(define (improve guess x)
  (average guess (/ x guess)))
(define (good-enough? guess x)
   (= (improve guess x) guess))
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
(define (sqrt x)
  (sqrt-iter 1.0 x))
;; sqrt ends here
(define sqrt5
  (sqrt 5))
(define phi
  (/ (+ 1 sqrt5) 2))
(define upsilon
  (/ (- 1 sqrt5) 2))
(define (fib-phi n)
  (/ (- (expt phi n)
        (expt upsilon n))
     sqrt5))
;; fib-phi ends here

;; [[file:Answers.org::count-change][count-change]]
(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0)
             (= kinds-of-coins 0))
         0)
        (else
         (+ (cc amount (- kinds-of-coins 1))
            (cc (- amount (first-denomination
                           kinds-of-coins))
                kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
;; count-change ends here

;; [[file:Answers.org::count-change-graphviz][count-change-graphviz]]
;; cursed global
(define bubblecounter 0)
;; Returns # of ways change can be made
;; "Helper" for (cc)
(define (count-change amount)
  (display "digraph {\n") ;; start graph
  (cc amount 5 0)
  (display "}\n") ;; end graph
  (set! bubblecounter 0))

;; GraphViz output
;; Derivative: https://stackoverflow.com/a/14806144
(define (cc amount kinds-of-coins oldbubble)
  (let ((recur (lambda (new-amount new-kinds)
                 (begin
                   (display "\"") ;; Source bubble
                   (display `(,oldbubble ,amount ,kinds-of-coins))
                   (display "\"")
                   (display " -> ") ;; arrow pointing from parent to child
                   (display "\"") ;; child bubble
                   (display `(,bubblecounter ,new-amount ,new-kinds))
                   (display "\"")
                   (display "\n")
                   (cc new-amount new-kinds bubblecounter)))))
    (set! bubblecounter (+ bubblecounter 1))
    (cond ((= amount 0) 1)
          ((or (< amount 0) (= kinds-of-coins 0)) 0)
          (else (+
                 (recur amount (- kinds-of-coins 1))
                 (recur (- amount
                           (first-denomination kinds-of-coins))
                        kinds-of-coins))))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
;; count-change-graphviz ends here

;; [[file:Answers.org::cc-calls][cc-calls]]
(define (count-calls amount)
  (cc-calls amount 5))

(define (cc-calls amount kinds-of-coins)
  (cond ((= amount 0) '(1 . 1))
        ((or (< amount 0)
             (= kinds-of-coins 0))
         '(0 . 1))
        (else
         (let ((a (cc-calls amount (- kinds-of-coins 1)))
               (b (cc-calls (- amount (first-denomination
                                 kinds-of-coins))
                      kinds-of-coins)))
           (cons (+ (car a)
                    (car b))
                 (+ 1
                    (cdr a)
                    (cdr b)))))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
;; cc-calls ends here

;; [[file:Answers.org::1-15-deps][1-15-deps]]
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))
;; 1-15-deps ends here

;; [[file:Answers.org::1-15-p-measure][1-15-p-measure]]
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
  (if (not (> (abs angle) 0.1))
      (cons angle 0)
      (let ((x (sine (/ angle 3.0))))
        (cons (p (car x)) (+ 1 (cdr x))))))
;; 1-15-p-measure ends here

;; [[file:Answers.org::txt-expt][txt-expt]]
(define (expt-rec b n)
  (if (= n 0) 
      1 
      (* b (expt-rec b (- n 1)))))

(define (expt-iter b n) 
  (define (iter counter product)
    (if (= counter 0)
        product
        (iter (- counter 1)
              (* b product))))
  (iter n 1))

(define (fast-expt b n)
  (cond ((= n 0) 
         1)
        ((even? n) 
         (square (fast-expt b (/ n 2))))
        (else 
         (* b (fast-expt b (- n 1))))))
;; txt-expt ends here

;; [[file:Answers.org::fast-expt-iter-fail1][fast-expt-iter-fail1]]
;; [[[[file:~/SICP-group/1/Answers.org::square][square]]][square]]
(define (square x)
  (* x x))
;; square ends here
(define (fast-expt-iter b n)
  (define (iter b n a)
    (format #t "~&|~s~/~/|~s~/~/|~s|~%" b n a)
    (cond ((= n 1) (begin (format #t "~&|~s~/~/|~s~/~/|~s|~%" (* b a) 1 1)
                          (* b a)))
          ((even? n) (iter (square b)
                         (/ n 2)
                         a))
          (else (iter b (- n 1) (+ a 1)))))
  (format #t "|~a~/|~a~/|~a|~%" "base" "power" "variable")
  (format #t "~&|--|--|--|~%")
  (iter b n 1))
;; fast-expt-iter-fail1 ends here

;; [[file:Answers.org::fast-expt-iter][fast-expt-iter]]
;; [[[[file:~/SICP-group/1/Answers.org::square][square]]][square]]
(define (square x)
  (* x x))
;; square ends here
(define (fast-expt-iter b n)
  (define (iter b n a)
    (cond ((= n 1) (* b a))
          ((even? n) (iter (square b)
                         (/ n 2)
                         a))
          (else (iter b (- n 1) (* b a)))))
  (iter b n 1))
;; fast-expt-iter ends here

;; [[file:Answers.org::fast-mult-rec][fast-mult-rec]]
(define (double x)
  (+ x x))
(define (halve x)
  (/ x 2))
(define (fast-mult-rec a b)
  (cond ((= b 0) 0)
        ((even? b)
         (double (fast-mult-rec a (halve b)))) ; This was kind of a stretch to think of.G
         ;(fast-mult (double a) (halve b))) <== My first instinct is iterative
        (else (+ a (fast-mult-rec a (- b 1))))))
;; fast-mult-rec ends here

;; [[file:Answers.org::fast-mult-iter][fast-mult-iter]]
(define (double x)
  (+ x x))
(define (halve x)
  (/ x 2))
(define (fast-mult a b)
  (define (iter a b c)
    (cond ((= b 0) 0)
          ((= b 1) (+ a c))
          ((even? b)
           (iter (double a) (halve b) c))
          (else (iter a (- b 1) (+ a c)))))
  (iter a b 0))
;; fast-mult-iter ends here

;; [[file:Answers.org::T-func][T-func]]
(define (T p q)
  (λ (a b)
    (cons (+ (* b q) (* a q) (* a p))
          (+ (* b p) (* a q)))))

(define T-fib
  (T 0 1))

;; Repeatedly apply T functions:
(define (Tr f n)
  (Tr-iter f n 0 1))
(define (Tr-iter f n a b)
  (if (= n 0)
      a
      (let ((l (f a b)))
        (Tr-iter f (- n 1) (car l) (cdr l)))))
;; T-func ends here

;; [[file:Answers.org::fib-iter-T][fib-iter-T]]
(define (fib-rec n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib-rec (- n 1))
                 (fib-rec (- n 2))))))
(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (+ (* p p)
                      (* q q))      ; compute p'
                   (+ (* p q)
                      (* q q)
                      (* q p))      ; compute q'
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
;; fib-iter-T ends here

;; [[file:Answers.org::*Text][Text:1]]
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
;; Text:1 ends here
