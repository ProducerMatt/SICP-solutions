# ORG-BABEL DEFAULTS
#+PROPERTY: header-args :tangle no :noeval :exports both :cache yes :results output wrap :noweb no-export :comments noweb :session default
#
# For the actual answers their dependencies use a header like this:
# #+BEGIN_SRC scheme -n :eval no-export :tangle yes :exports both
# For their dependencies:
# #+BEGIN_SRC scheme :eval no-export :tangle yes :results silent

#+auto_tangle: t

#+PANDOC_OPTIONS: standalone:t
# FIXME: this doesn't appear to do anything. Be sure to run pandoc with -s

#+LATEX_CMD: xelatex
#+LATEX_HEADER: \setmonofont[Mapping=tex-text,Scale=MatchLowercase]{FiraMono-Regular}
#+LATEX_HEADER: \listfiles
# listfiles causes latex to make a list of all files used during processing

#+title: SICP Chapter 1
#+AUTHOR: ProducerMatt

* HOW THIS DOCUMENT IS MADE
**TODO**
#+NAME: testing
#+BEGIN_SRC scheme -n :exports both :eval no-export :results value
(define (foo a b)
  (+ a (* 2 b)))

(foo 5 3)
#+END_SRC

#+RESULTS[57407d275aacd484646294a75251646c910ae5fc]: testing
:results:
11
:end:

^ Dynamically evaluated when you press "enter" on the ~BEGIN_SRC~ block!

*** Also consider:
- ~:results output~ for what the code prints
- ~:exports code~ or ~:exports results~ to just get one or the other

\(a + (\pi \times b)\) <~ inline Latex btw :)

*** Current command for conversion
#+BEGIN_SRC sh :noeval
pandoc --from org --to latex 1.org -o 1.tex -s; xelatex 1.tex
#+END_SRC

** Helpers for org-mode tables
*** ~try-these~
Takes function ~f~ and list ~testvals~ and applies ~f~ to each item ~i~. For
each ~i~ returns a list with ~i~ and the result. Useful dor making tables with a
column for input and a column for output.
#+NAME: try-these
#+BEGIN_SRC scheme -n :eval no-export :tangle yes :results silent
;; Surely this could be less nightmarish
(define (try-these f . testvals)
  (let ((l (if (and (= 1 (length testvals))
                    (list? (car testvals)))
               (car testvals)
               testvals)))
    (map (λ (i) (cons i
                      (cons (if (list? i)
                                (apply f i)
                                (f i))
                            #nil)))
         l)))
#+end_src
*** ~transpose-list~
"Rotate" a list, for example from src_scheme{'(1 2 3)} to
src_scheme{'('(1) '(2) '(3))}
#+NAME: transpose-list
#+BEGIN_SRC scheme -n :eval no-export :tangle yes :results silent
(define (transpose-list l)
  (map (λ (i) (list i)) l))
#+end_src
*** ~print-as-rows~
For manually printing items in rows to stdout. Not currently used.
#+NAME: print-as-rows
#+BEGIN_SRC scheme -n :eval no-export :tangle yes :results silent
(define (p-nl a)
  (display a)
  (newline))
(define (print-spaced args)
  (let ((a (car args))
        (d (cdr args)))
    (if (null? d)
        (p-nl a)
        (begin (display a)
               (display " ")
               (print-spaced d)))))
(define (print-as-rows . args)
  (let ((a (car args))
        (d (cdr args)))
    (if (list? a)
        (if (= 1 (length args))
            (apply print-as-rows a)
            (print-spaced a))
        (p-nl a))
    (if (null? d)
        '()
        (apply print-as-rows d))))
#+end_src
* Exercise 1.1
** Q
Below is a sequence of expressions. What is the result printed by the
interpreter in response to each expression? Assume that the sequence is to be
evaluated in the order in which it is presented.
** A
#+BEGIN_SRC scheme -n :results none
10 ;; 10
(+ 5 3 4) ;; 12
(- 9 1) ;; 8
(/ 6 2) ;; 3
(+ (* 2 4) (- 4 6)) ;; 6
(define a 3) ;; a=3
(define b (+ a 1)) ;; b=4
(+ a b (* a b)) ;; 19
(= a b) ;; false
(if (and (> b a) (< b (* a b)))
    b
    a) ;; 4
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25)) ;; 16
(+ 2 (if (> b a) b a)) ;; 6
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1)) ;; 16
#+END_SRC

* Exercise 1.2
** Q
Translate the following expression into prefix form:
\[
  \frac{5 + 2 + (2 - 3 - (6 + \frac{4}{5})))}
            {3(6 - 2)(2 - 7)}
\]
** A
#+NAME: EX1-2
#+BEGIN_SRC scheme -n :eval no-export :exports both :results value
(/ (+ 5 2 (- 2 3 (+ 6 (/ 4 5))))
   (* 3 (- 6 2) (- 2 7)))
#+END_SRC

#+RESULTS[7039c32447725d91001cae297dc9040b72a855ce]: EX1-2
:results:
1/75
:end:


* Exercise 1.3
** Text
#+NAME: square
#+BEGIN_SRC scheme -n :eval no-export :results silent :tangle yes
(define (square x)
  (* x x))
#+END_SRC
** Q
Define a procedure that takes three numbers as arguments and returns the sum of
the squares of the two larger numbers.
** A
#+NAME: EX1-3
#+BEGIN_SRC scheme -n :eval no-export :tangle yes :exports both :results value table
<<square>>
(define (sum-square x y)
  (+ (square x) (square y)))
(define (square-2of3 a b c)
  (cond ((and (>= a b) (>= b c)) (sum-square a b))
        ((and (>= a b) (> c b)) (sum-square a c))
        ((and (> b a) (>= c a)) (sum-square b c))
        (else "This shouldn't happen")))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<EX1-3>>
<<try-these>>
 (try-these square-2of3 '(7 5 3)
                        '(7 3 5)
                        '(3 5 7))
#+END_SRC

#+RESULTS[0f816cfe3925898754ab7943a28f676135795e6c]:
:results:
| (7 5 3) | 74 |
| (7 3 5) | 74 |
| (3 5 7) | 74 |
:end:

* Exercise 1.4
** Q
Observe that our model of evaluation allows for combinations whose operators are
compound expressions. Use this observation to describe the behavior of the
following procedure:

#+NAME: a-plus-abs-b
#+BEGIN_SRC scheme -n
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
#+END_SRC

** A
This code accepts the variables ~a~ and ~b~, and if ~b~ is positive, it adds ~a~
and ~b~. However, if ~b~ is zero or negative, it subtracts them. This decision
is made by using the ~+~ and ~-~ procedures as the results of an if expression,
and then evaluating according to the results of that expression. This is in
contrast to a language like Python, which would do something like this:

#+BEGIN_SRC python :noeval :tangle no
if b > 0: a + b
else: a - b
#+END_SRC

* Exercise 1.5
** Q
Ben Bitdiddle has invented a test to determine whether the interpreter he is
faced with is using applicative-order evaluation or normal-order evaluation. He
defines the following two procedures:

#+BEGIN_SRC scheme -n :noeval :tangle no
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
#+END_SRC
Then he evaluates the expression

#+BEGIN_SRC scheme -n :noeval :tangle no
(test 0 (p))
#+END_SRC

What behavior will Ben observe with an interpreter that uses applicative-order
evaluation? What behavior will he observe with an interpreter that uses
normal-order evaluation? Explain your answer. (Assume that the evaluation rule
for the special form if is the same whether the interpreter is using normal or
applicative order: The predicate expression is evaluated first, and the result
determines whether to evaluate the consequent or the alternative expression.)

** A
In either type of language, src_scheme{(define (p) (p))} is an infinite
loop. However, a normal-order language will encounter the special form, return
~0~, and never evaluate ~(p)~. An applicative-order language evaluates the
arguments to src_scheme{(test 0 (p))}, thus triggering the infinite
loop.

* Exercise 1.6
** Text code
#+NAME: abs
#+BEGIN_SRC scheme -n :eval no-export :tangle yes :results silent
(define (abs x)
  (if (< x 0)
	  (- x)
	  x))
#+END_SRC
#+NAME: average
#+BEGIN_SRC scheme -n :eval no-export :tangle yes :results silent
(define (average x y)
  (/ (+ x y) 2))
#+END_SRC
#+NAME: txt-sqrt
#+BEGIN_SRC scheme -n :eval no-export :tangle yes :results silent
<<average>>
(define (improve guess x)
  (average guess (/ x guess)))

<<square>>
<<abs>>
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))

(define (sqrt x)
  (sqrt-iter 1.0 x))
#+END_SRC

** Q
Exercise 1.6: Alyssa P. Hacker doesn’t see why if needs to be provided as a
special form. “Why can’t I just define it as an ordinary procedure in terms of
cond?” she asks. Alyssa’s friend Eva Lu Ator claims this can indeed be done, and
she defines a new version of if:

#+BEGIN_SRC scheme -n :noeval :tangle no
(define (new-if predicate
                then-clause
                else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
#+END_SRC
Eva demonstrates the program for Alyssa:

#+BEGIN_SRC scheme -n :noeval :tangle no
(new-if (= 2 3) 0 5)
;; => 5

(new-if (= 1 1) 0 5)
;; => 0
#+END_SRC

Delighted, Alyssa uses new-if to rewrite the square-root program:

#+BEGIN_SRC scheme -n :noeval :tangle no
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))
#+END_SRC

What happens when Alyssa attempts to use this to compute square roots? Explain.

** A
Using Alyssa's ~new-if~ leads to an infinite loop because the recursive call to
~sqrt-iter~ is evaluated before the actual call to ~new-if~. This is because
~if~ and ~cond~ are special forms that change the way evaluation is handled;
whichever branch is chosen leaves the other branches unevaluated.

* Exercise 1.7
** Text
#+NAME: mean-square
#+BEGIN_SRC scheme -n :eval no-export :tangle yes :results silent
(define (mean-square x y)
  (average (square x) (square y)))
#+END_SRC
** Q
The good-enough? test used in computing square roots will not be very effective
for finding the square roots of very small numbers. Also, in real computers,
arithmetic operations are almost always performed with limited precision. This
makes our test inadequate for very large numbers. Explain these statements, with
examples showing how the test fails for small and large numbers. An alternative
strategy for implementing good-enough? is to watch how guess changes from one
iteration to the next and to stop when the change is a very small fraction of
the guess. Design a square-root procedure that uses this kind of end test. Does
this work better for small and large numbers?
** A
The current method has decreasing accuracy with smaller numbers. Notice the
steady divergence from correct answers here (should be decreasing powers of
0.1):
#+NAME: EX1-7-t1
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<txt-sqrt>>
<<try-these>>
(try-these sqrt 0.01 0.0001 0.000001 0.00000001 0.0000000001)
#+END_SRC

#+RESULTS[b2aaaf48d742a7df9331cff3b730a799ad550cfe]: EX1-7-t1
:results:
|   0.01 |  0.10032578510960605 |
| 0.0001 |  0.03230844833048122 |
|  1e-06 | 0.031260655525445276 |
|  1e-08 |  0.03125010656242753 |
|  1e-10 |  0.03125000106562499 |
:end:

And for larger numbers, an infinite loop will eventually be reached. \(10^{12}\)
can resolve, but \(10^{13}\) cannot.

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value
<<txt-sqrt>>
(sqrt 1000000000000)
#+END_SRC

#+RESULTS[452bf3da7286d9fc1e3d621aeb715eafef650536]:
:results:
1000000.0
:end:

My original answer was this, which compares the previous iteration until the new
and old are within an arbitrary \(dx\).

#+NAME: inferior-good-enough
#+BEGIN_SRC scheme -n :tangle yes
<<txt-sqrt>>
(define (inferior-good-enough? guess lastguess)
  (<=
   (abs (-
         (/ lastguess guess)
         1))
   0.0000000000001)) ; dx
(define (new-sqrt-iter guess x lastguess) ;; Memory of previous value
  (if (inferior-good-enough? guess lastguess)
      guess
      (new-sqrt-iter (improve guess x) x guess)))
(define (new-sqrt x)
  (new-sqrt-iter 1.0 x 0))
#+end_src

This solution can correctly find small and large numbers:
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value
<<inferior-good-enough>>
(new-sqrt 10000000000000)
#+END_SRC

#+RESULTS[68a129e63924b52600a4964626d31b776d79fed2]:
:results:
3162277.6601683795
:end:

#+NAME: EX1-7-t2
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table drawer
<<try-these>>
<<inferior-good-enough>>
(try-these new-sqrt '(0.01 0.0001 0.000001 0.00000001 0.0000000001))
#+end_src

#+RESULTS[c27aa8604cebcef53580dbfc41f8585b748aacda]: EX1-7-t2
:results:
|   0.01 |                   0.1 |
| 0.0001 |                  0.01 |
|  1e-06 |                 0.001 |
|  1e-08 | 9.999999999999999e-05 |
|  1e-10 | 9.999999999999999e-06 |
:end:


However, I found this solution online that isn't just simpler but automatically
reaches the precision limit of the system:

#+NAME: new-good-enough
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<txt-sqrt>>
(define (best-good-enough? guess x)
   (= (improve guess x) guess))
#+END_SRC

So, my final definition of ~sqrt~:
#+NAME: sqrt
#+BEGIN_SRC scheme -n :eval no-export :tangle yes :exports both :results value table
<<average>>
(define (improve guess x)
  (average guess (/ x guess)))
(define (good-enough? guess x)
   (= (improve guess x) guess))
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
(define (sqrt x)
  (sqrt-iter 1.0 x))
#+end_src
#+NAME: EX1-7-t3
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<try-these>>
<<sqrt>>
(try-these sqrt '(0.01 0.0001 0.000001 0.00000001 0.0000000001))
#+end_src

#+RESULTS[7cb8301b492f578ac407eef3e3378a8d1552a5a3]: EX1-7-t3
:results:
|   0.01 |                   0.1 |
| 0.0001 |                  0.01 |
|  1e-06 |                 0.001 |
|  1e-08 | 9.999999999999999e-05 |
|  1e-10 | 9.999999999999999e-06 |
:end:

* Exercise 1.8
** Q
Newton’s method for cube roots is based on the fact that if y is an
approximation to the cube root of x, then a better approximation is given by the
value:
\begin{equation}
\frac{\frac{x}{y^2} + 2y}{3}
\end{equation}
Use this formula to implement a cube-root procedure analogous to the square-root
procedure. (In 1.3.4 we will see how to implement Newton’s method in general as
an abstraction of these square-root and cube-root procedures.)
** A1
My first attempt works, but needs an arbitrary limit to stop infinite loops:
#+NAME: EX1-8-A1
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<square>>
(define (cb-good-enough? guess x)
  (= (cb-improve guess x) guess))
(define (cb-improve guess x)
  (/
   (+
    (/ x (square guess))
    (* guess 2))
   3))
(define (cbrt-iter guess x counter)
  (if (or (cb-good-enough? guess x) (> counter 100))
      guess
      (begin
        (cbrt-iter (cb-improve guess x) x (+ 1 counter)))))
(define (cbrt x)
  (cbrt-iter 1.0 x 0))

(try-these cbrt 7 32 56 100)
#+end_src

#+RESULTS[1eb5546cd3e124a63b0cd988f571097371a60813]: EX1-8-A1
:results:
|   7 | 1.912931182772389 |
|  32 | 3.174802103936399 |
|  56 | 3.825862365544778 |
| 100 | 4.641588833612779 |
:end:

However, this will hang on an infinite loop when trying to run src_scheme{(cbrt 100)}.
I speculate it's a floating point precision issue with the "improve"
algorithm. So to avoid it I'll just keep track of the last guess and stop
improving when there's no more change occurring. Also while researching I
discovered that (again due to floating point) src_scheme{(cbrt -2)} loops
forever unless you initialize your guess with a slightly different value, so
let's do 1.1 instead.
** A2
#+NAME: cbrt
#+BEGIN_SRC scheme -n :eval no-export :tangle yes :exports code :results silent
<<square>>
(define (cb-good-enough? nextguess guess lastguess x)
  (or (= nextguess guess)
      (= nextguess lastguess)))
(define (cb-improve guess x)
  (/
   (+
    (/ x (square guess))
    (* guess 2))
   3))
(define (cbrt-iter guess lastguess x)
  (define nextguess (cb-improve guess x))
  (if (cb-good-enough? nextguess guess lastguess x)
      nextguess
      (cbrt-iter nextguess guess x)))
(define (cbrt x)
  (cbrt-iter 1.1 9999 x))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<cbrt>>
<<try-these>>
(try-these cbrt 7 32 56 100 -2)
#+END_SRC

#+RESULTS[965031d6fc942ec767b94f18bc03219f3a3f93d6]:
:results:
|   7 |   1.912931182772389 |
|  32 |   3.174802103936399 |
|  56 |   3.825862365544778 |
| 100 |   4.641588833612779 |
|  -2 | -1.2599210498948732 |
:end:

* Exercise 1.9
** Q
Each of the following two procedures defines a method for adding two positive
integers in terms of the procedures inc, which increments its argument by 1, and
dec, which decrements its argument by 1.

#+BEGIN_SRC scheme -n :noeval :tangle no
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
#+END_SRC

Using the substitution model, illustrate the process generated by each procedure
in evaluating src_scheme{(+ 4 5)}. Are these processes iterative or recursive?
** A
The first procedure is recursive, while the second is iterative though
tail-recursion.
*** recursive procedure
#+BEGIN_SRC scheme -n :noeval :tangle no
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
#+END_SRC

*** iterative procedure
#+BEGIN_SRC scheme -n :noeval :tangle no
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
#+END_SRC

* Exercise 1.10
** Q
The following procedure computes a mathematical function called Ackermann’s
function.
#+NAME: ackermann
#+BEGIN_SRC scheme -n :eval no-export :tangle yes :exports code :results silent
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
#+END_SRC

What are the values of the following expressions?

#+BEGIN_SRC scheme -n :noeval :tangle no
(A 1 10)
(A 2 4)
(A 3 3)
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :exports results :tangle no :results value table
<<try-these>>
<<ackermann>>
(try-these A '(1 10) '(2 4) '(3 3))
#+END_SRC

#+RESULTS[48e58b6029bccdcb0ec0cba4c437572b3b5c2437]:
:results:
| (1 10) |  1024 |
| (2 4)  | 65536 |
| (3 3)  | 65536 |
:end:

#+NAME: EX1-10-defs
#+BEGIN_SRC scheme -n :eval no-export :tangle yes :exports code :results silent
<<ackermann>>
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
#+END_SRC

Give concise mathematical definitions for the functions computed by the
procedures ~f~, ~g~, and ~h~ for positive integer values of \(n\). For example,
src_scheme{(k n)} computes \(5n^2\).

** A
*** ~f~

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<try-these>>
<<EX1-10-defs>>
(try-these f 1 2 3 10 15 20)
#+END_SRC

#+RESULTS[d24f130b3c260d786e4cb6a89fa32c320b8c9216]:
:results:
|  1 |  2 |
|  2 |  4 |
|  3 |  6 |
| 10 | 20 |
| 15 | 30 |
| 20 | 40 |
:end:

\[
f(n)=2n
\]
*** ~g~

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<try-these>>
<<EX1-10-defs>>
(try-these g 1 2 3 4 5 6 7 8)
#+END_SRC

#+RESULTS[2de64054dc56968afee805dc8757b991e4f74d88]:
:results:
| 1 |   2 |
| 2 |   4 |
| 3 |   8 |
| 4 |  16 |
| 5 |  32 |
| 6 |  64 |
| 7 | 128 |
| 8 | 256 |
:end:

\[
g(n)=2^n
\]

*** ~h~

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<try-these>>
<<EX1-10-defs>>
(try-these h 1 2 3 4)
#+END_SRC

#+RESULTS[b80263a28bd5076f3bfa3f4bae09ec511773e7af]:
:results:
| 1 |     2 |
| 2 |     4 |
| 3 |    16 |
| 4 | 65536 |
:end:

It took a while to figure this one out, just because I didn't know the term.
This is repeated exponentiation. This operation is to exponentiation, what
exponentiation is to multiplication. It's called either /tetration/ or /hyper-4/
and has no formal notation, but two common ways would be these:

\[
h(n)=2 \uparrow\uparrow n
\]
\[
h(n)={}^{n}2
\]

* Exercise 1.11
** Q
A function \(f\) is defined by the rule that:
\[
f(n)=n \text{ if } n<3
\]
\[
\text{ and }
\]
\[
f(n)=f(n-1)+2f(n-2)+3f(n-3) \text{ if } n \geq 3
\]

Write a procedure that computes \(f\) by means of a recursive process. Write a
procedure that computes \(f\) by means of an iterative process.
** A
*** Recursive
#+NAME: EX1-11-fr
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports code :results silent
(define (fr n)
  (if (< n 3)
      n
      (+      (fr (- n 1))
         (* 2 (fr (- n 2)))
         (* 3 (fr (- n 3))))))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<try-these>>
<<EX1-11-fr>>
(try-these fr 1 3 5 10)
#+END_SRC

#+RESULTS[d54b80d2fe7a526473762819190f33a520a19fe4]:
:results:
|  1 |    1 |
|  3 |    4 |
|  5 |   25 |
| 10 | 1892 |
:end:

*** Iterative
**** Attempt 1
#+NAME: EX1-11-fi
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports code :results silent
;; This seems like it could be better
(define (fi n)
  (define (formula l)
    (let ((a (car l))
           (b (cadr l))
           (c (caddr l)))
      (+ a
         (* 2 b)
         (* 3 c))))
  (define (iter l i)
    (if (= i n)
        (car l)
        (iter (cons (formula l) l)
              (+ 1 i))))
  (if (< n 3)
      n
      (iter '(2 1 0) 2)))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<try-these>>
<<EX1-11-fi>>
(try-these fi 1 3 5 10)
#+END_SRC

#+RESULTS[77f33e30f912c03277beeb8092d92c55abfcc936]:
:results:
|  1 |    1 |
|  3 |    4 |
|  5 |   25 |
| 10 | 1892 |
:end:

It works but it seems wasteful.

**** Attempt 2
#+NAME: EX1-11-fi2
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports code :results silent
(define (fi2 n)
  (define (formula a b c)
      (+ a
         (* 2 b)
         (* 3 c)))
  (define (iter a b c i)
    (if (= i n)
        a
        (iter (formula a b c)
              a
              b
              (+ 1 i))))
  (if (< n 3)
      n
      (iter 2 1 0 2)))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<try-these>>
<<EX1-11-fi2>>
(try-these fi2 1 3 5 10)
#+END_SRC

#+RESULTS[baa8cd23dfff7b5fa47ae133b0a8b58ef2cb9a61]:
:results:
|  1 |    1 |
|  3 |    4 |
|  5 |   25 |
| 10 | 1892 |
:end:

I like that better.

* Exercise 1.12
** Q
The following pattern of numbers is called Pascal’s triangle.

/Pretend there's a Pascal's triangle here./

The numbers at the edge of the triangle are all 1, and each number inside the
triangle is the sum of the two numbers above it. Write a procedure that
computes elements of Pascal’s triangle by means of a recursive process.
** A
I guess I'll rotate the triangle 45 degrees to make it the top-left corner of an
infinite spreadsheet.

#+NAME: pascal-rec
#+BEGIN_SRC scheme -n :eval no-export :tangle yes :exports code :results silent
(define (pascal x y)
  (if (or (= x 0)
          (= y 0))
      1
      (+ (pascal (- x 1) y)
         (pascal x (- y 1)))))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<try-these>>
<<pascal-rec>>
(let ((l (iota 8)))
  (map (λ (row)
         (map (λ (xy)
                (apply pascal xy))
              row))
       (map (λ (x)
              (map (λ (y)
                     (list x y))
                   l))
            l)))
#+END_SRC

#+RESULTS[151500842c6cdef9252eaf15c1323fc7bcba0527]:
:results:
| 1 | 1 |  1 |   1 |   1 |   1 |    1 |    1 |
| 1 | 2 |  3 |   4 |   5 |   6 |    7 |    8 |
| 1 | 3 |  6 |  10 |  15 |  21 |   28 |   36 |
| 1 | 4 | 10 |  20 |  35 |  56 |   84 |  120 |
| 1 | 5 | 15 |  35 |  70 | 126 |  210 |  330 |
| 1 | 6 | 21 |  56 | 126 | 252 |  462 |  792 |
| 1 | 7 | 28 |  84 | 210 | 462 |  924 | 1716 |
| 1 | 8 | 36 | 120 | 330 | 792 | 1716 | 3432 |
:end:

The test code was much harder to write than the actual solution.

* Exercise 1.13
** Q
Prove that \(\text{Fib}(n)\) is the closest integer to
\(\frac{ϕ^n}{\sqrt{5}}\) where Phi is \(\frac{1 + \sqrt{5}}{2}\). Hint: let
\(Υ = \frac{1 - \sqrt{5}}{2}\). Use induction and the definition of the
Fibonacci numbers to prove that

\[
 \text{Fib}(n) = \frac{ϕ^n - Υ^n}{\sqrt{5}}
\]

** A
I don't know how to write a proof yet, but I can make functions to
demonstrate it.

*** Fibonacci number generator
#+NAME: fib-iter
#+BEGIN_SRC scheme -n :eval no-export :tangle yes :exports code :results silent
(define (fib-iter n)
  (define (iter i a b)
    (if (= i n)
        b
    (iter (+ i 1)
          b
          (+ a b))))
  (if (<= n 2)
      1
      (iter 2 1 1)))
#+END_SRC
*** Various algorithms relating to the question
#+NAME: fib-phi
#+BEGIN_SRC scheme -n :eval no-export :tangle yes :exports code :results silent
<<sqrt>>
(define sqrt5
  (sqrt 5))
(define phi
  (/ (+ 1 sqrt5) 2))
(define upsilon
  (/ (- 1 sqrt5) 2))
(define (fib-phi n)
  (/ (- (expt phi n)
        (expt upsilon n))
     sqrt5))
#+END_SRC
#+NAME: 1-13-tab
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
(use-srfis '(1))
<<fib-iter>>
<<fib-phi>>
<<try-these>>

(let* ((vals (drop (iota 21) 10))
       (fibs (map fib-iter vals))
       (approx (map fib-phi vals)))
  (zip vals fibs approx))
#+END_SRC

#+RESULTS[732483d41040c13f1e9a125ebe5a0ecdca1f5d18]: 1-13-tab
:results:
| 10 |   55 |  54.99999999999999 |
| 11 |   89 |               89.0 |
| 12 |  144 | 143.99999999999997 |
| 13 |  233 | 232.99999999999994 |
| 14 |  377 | 377.00000000000006 |
| 15 |  610 |              610.0 |
| 16 |  987 |  986.9999999999998 |
| 17 | 1597 | 1596.9999999999998 |
| 18 | 2584 |             2584.0 |
| 19 | 4181 |             4181.0 |
| 20 | 6765 |  6764.999999999999 |
:end:

You can see they follow extremely closely. Graphing the differences:
#+NAME: 1-13-tab2
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports none :results value silent
(use-srfis '(1))
<<fib-iter>>
<<fib-phi>>
<<try-these>>

(let* ((vals (drop (iota 500) 2))
       (diffs (map (λ (i)
                     (- (fib-iter i) (fib-phi i)))
                   vals)))
  (zip vals diffs))
#+END_SRC



#+begin_src gnuplot :var data=1-13-tab2 :file 1-13.png :exports results :eval no-export
reset # helps with various issues in execution
set xlabel 'values of n'
set logscale y

plot data using 1:2 with lines title 'Fib(n) minus Fib-phi(n)'
#+end_src

#+RESULTS[8c0a67c9f76a9da9c115187192a6c35899c939cb]:
:results:
[[file:1-13.png]]
:end:

* Exercise 1.14
#+NAME: count-change
#+BEGIN_SRC scheme -n :eval no-export :tangle yes :exports code :results silent
(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0)
             (= kinds-of-coins 0))
         0)
        (else
         (+ (cc amount (- kinds-of-coins 1))
            (cc (- amount (first-denomination
                           kinds-of-coins))
                kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
#+end_src
** Q
