#+OPTIONS: toc stat prop

#+STARTUP: overview
#+auto_tangle: t

# ORG-BABEL DEFAULTS
#+PROPERTY: header-args :tangle no :noeval :exports both :cache yes :results output wrap :noweb no-export :comments noweb :colnames no :rownames no
#+PROPERTY: header-args:scheme :session scheme
#+PROPERTY: header-args:gnuplot :prelude "reset" :session nil

# For the actual answers their dependencies use a header like this:
# #+BEGIN_SRC scheme -n :eval no-export :tangle yes :exports both
# For their dependencies:
# #+BEGIN_SRC scheme :eval no-export :tangle yes :results silent

#+PANDOC_OPTIONS: standalone:t
# FIXME: this doesn't appear to do anything. Be sure to run pandoc with -s
#+latex_class: article

# NOTE: "draft" MARKS OVERFLOWING LINES WITH AN UGLY BLACK SQUARE. CHANGE TO "FINAL" WHEN FINISHED``
#+latex_class_options: [final,fleqn,titlepage]
#+description:
#+keywords:
#+subtitle:
#+latex_engraved_theme:

#+LATEX_CMD: xelatex -shell-escape -interaction nonstopmode
#+LATEX_COMPILER: xelatex
#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \setmonofont[Mapping=tex-text,Ligatures=TeX,Scale=MatchLowercase]{FiraMono-Regular}
#+LATEX_HEADER: \usepackage[cache=true]{minted}
#+LATEX_HEADER: \usemintedstyle{colorful}
#+LATEX_HEADER: \listfiles
# listfiles causes latex to make a list of all files used during processing
# #+LATEX_HEADER: \definecolor{my-bg}{rgb}{0.96,0.96,0.96}
# #+LATEX_HEADER: \setminted{bgcolor=grey}
# #+LATEX_HEADER: \setmonofont[Ligatures=TeX]{inconsolata} % needs lualatex

#+title: SICP Chapter 1 Answers
#+AUTHOR: ProducerMatt
#+date: \today

* HOW THIS DOCUMENT IS MADE
:PROPERTIES:
:UNNUMBERED:
:end:
**TODO**
#+NAME: testing
#+BEGIN_SRC scheme -n :exports both :eval no-export :results value
(define (foo a b)
  (+ a (* 2 b)))

(foo 5 3)
#+END_SRC

#+RESULTS[57407d275aacd484646294a75251646c910ae5fc]: testing
:results:
11
:end:

^ Dynamically evaluated when you press "enter" on the ~BEGIN_SRC~ block!

*** Also consider:
- ~:results output~ for what the code prints
- ~:exports code~ or ~:exports results~ to just get one or the other

\(a + (\pi \times b)\) <~ inline Latex btw :)

*** Current command for conversion
#+BEGIN_SRC sh :noeval
pandoc --from org --to latex 1.org -o 1.tex -s; xelatex 1.tex
#+END_SRC

** Helpers for org-mode tables
*** ~try-these~
Takes function ~f~ and list ~testvals~ and applies ~f~ to each item ~i~. For
each ~i~ returns a list with ~i~ and the result. Useful dor making tables with a
column for input and a column for output.
#+NAME: try-these
#+BEGIN_SRC scheme -n :eval no-export :results silent
;; Surely this could be less nightmarish
(define (try-these f . testvals)
  (let ((l (if (and (= 1 (length testvals))
                    (list? (car testvals)))
               (car testvals)
               testvals)))
    (map (λ (i) (cons i
                      (cons (if (list? i)
                                (apply f i)
                                (f i))
                            #nil)))
         l)))
#+end_src
*** ~transpose-list~
"Rotate" a list, for example from src_scheme{'(1 2 3)} to
src_scheme{'('(1) '(2) '(3))}
#+NAME: transpose-list
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (transpose-list l)
  (map list l))
#+end_src
*** ~print-as-rows~
For manually printing items in rows to stdout. Can be helpful for gnuplot.
#+NAME: print-as-rows
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (p-nl a)
  (display a)
  (newline))
(define (print-spaced args)
  (let ((a (car args))
        (d (cdr args)))
    (if (null? d)
        (p-nl a)
        (begin (display a)
               (display " ")
               (print-spaced d)))))
(define (print-as-rows . args)
  (let ((a (car args))
        (d (cdr args)))
    (if (list? a)
        (if (= 1 (length args))
            (apply print-as-rows a)
            (print-spaced a))
        (p-nl a))
    (if (null? d)
        '()
        (apply print-as-rows d))))
#+end_src
*** ~print-table~
Print ~args~ as a table separated by pipes. Optionally print spacer for
colnames.
#+NAME: print-table
#+BEGIN_SRC scheme -n :eval no-export :results output :exports code
(use-modules (ice-9 format))
(define* (print-row ll #:key (mode #f))
  (let ((fmtstr
         (cond ((or (eq? mode #f)
                    (equal? mode "display")
                    (equal? mode "~a"))
                " ~a |")    ;; print objects for human viewing
               ((or (eq? mode #t)
                    (equal? mode "write")
                    (equal? mode "~s"))
                " ~s |") ;; print objects for correctly (read)ing back
               ((string? mode)
                mode)))) ;; pass custom format string
      (format #t "~&|")
      (map (λ(x) (format #t fmtstr x)) ll)
      (format #t "~%")))
(define* (print-table table #:key (colnames #f) (mode #f))
    (define (iter t)
      (print-row (car t) #:mode mode)
      (if colnames
          (print-row (car t) #:mode "---|"))
      (map (λ(x) (print-row x #:mode mode)) (cdr t)))
    (cond ((and (= 1 (length table))
                (list? (car table))) (iter (car table)))
          ((<= 1 (length table)) (iter table))
          (else error "Invalid Input??")))
#+end_src

#+RESULTS[19c84289ba2a3641df209da53bc4715f762f5ca7]: print-table
:results:
:end:

#+NAME: print-table-test
#+BEGIN_SRC scheme -n :eval no-export :tangle no :results table output :exports no :rownames yes :colnames yes
<<print-table>>
(let* ((l (iota 3))
      (table (list
              (list 'column-1 'column-2 'column-3 'column-4)
              (cons 'row-a l)
              (cons 'row-b l)
              (cons 'row-c l))))
  (print-table table #:colnames #t ))
#+end_src

#+RESULTS[6c949ef04c9d52908df9234c749648b0b1a3b9e9]: print-table-test
:results:
| column-1 | column-2 | column-3 | column-4 |
|----------+----------+----------+----------|
| row-a    |        0 |        1 |        2 |
| row-b    |        0 |        1 |        2 |
| row-c    |        0 |        1 |        2 |
:end:

*** ~print-table~ (spaces only)
TODO: Merge these together.
#+NAME: print-table-spaced
#+BEGIN_SRC scheme -n :eval no-export :tangle no :results output :exports code
(use-modules (ice-9 format))
(define* (print-row ll #:key (mode #f))
  (let ((fmtstr
         (cond ((or (eq? mode #f)
                    (equal? mode "display")
                    (equal? mode "~a"))
                " ~a")    ;; print objects for human viewing
               ((or (eq? mode #t)
                    (equal? mode "write")
                    (equal? mode "~s"))
                " ~s") ;; print objects for correctly (read)ing back
               ((string? mode)
                mode)))) ;; pass custom format string
    
      (format #t "~&") ;; ensure start of new line
      (map (λ(x) (format #t fmtstr x)) ll)
      (format #t "~%")))

(define* (print-table table #:key (colnames #f) (mode #f))
    (define (iter t)
      (print-row (car t) #:mode mode)
      (map (λ(x) (print-row x #:mode mode)) (cdr t)))
    (cond ((and (= 1 (length table))
                (list? (car table))) (iter (car table)))
          ((<= 1 (length table)) (iter table))
          (else error "Invalid Input??")))
#+end_src

#+NAME: print-table-spaced-test
#+BEGIN_SRC scheme -n :eval no-export :tangle no :results table output :exports no :rownames yes :colnames yes
<<print-table-spaced>>
(let* ((l (iota 3))
      (table (list
              (list 'column-1 'column-2 'column-3 'column-4)
              (cons 'row-a l)
              (cons 'row-b l)
              (cons 'row-c l))))
  (print-table table))
#+end_src

#+RESULTS[497a369e75d67018fb5cb6e0beecd5fbddb3468f]: print-table-spaced-test
:results:
 column-1 column-2 column-3 column-4
 row-a 0 1 2
 row-b 0 1 2
 row-c 0 1 2
:end:

* Exercise 1.1
** Question
Below is a sequence of expressions. What is the result printed by the
interpreter in response to each expression? Assume that the sequence is to be
evaluated in the order in which it is presented.
** Answer
#+BEGIN_SRC scheme -n :results none
10 ;; 10
(+ 5 3 4) ;; 12
(- 9 1) ;; 8
(/ 6 2) ;; 3
(+ (* 2 4) (- 4 6)) ;; 6
(define a 3) ;; a=3
(define b (+ a 1)) ;; b=4
(+ a b (* a b)) ;; 19
(= a b) ;; false
(if (and (> b a) (< b (* a b)))
    b
    a) ;; 4
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25)) ;; 16
(+ 2 (if (> b a) b a)) ;; 6
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1)) ;; 16
#+END_SRC

* Exercise 1.2
** Question
Translate the following expression into prefix form:
\[
  \frac{5 + 2 + (2 - 3 - (6 + \frac{4}{5})))}
            {3(6 - 2)(2 - 7)}
\]
** Answer
#+NAME: EX1-2
#+BEGIN_SRC scheme -n :eval no-export :exports both :results value
(/ (+ 5 2 (- 2 3 (+ 6 (/ 4 5))))
   (* 3 (- 6 2) (- 2 7)))
#+END_SRC

#+RESULTS[7039c32447725d91001cae297dc9040b72a855ce]: EX1-2
:results:
1/75
:end:

* Exercise 1.3
** Text
#+NAME: square
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (square x)
  (* x x))
#+END_SRC
** Question
Define a procedure that takes three numbers as arguments and returns the sum of
the squares of the two larger numbers.
** Answer
#+NAME: EX1-3
#+BEGIN_SRC scheme -n :eval no-export :exports both :results value table
<<square>>
(define (sum-square x y)
  (+ (square x) (square y)))
(define (square-2of3 a b c)
  (cond ((and (>= a b) (>= b c)) (sum-square a b))
        ((and (>= a b) (> c b)) (sum-square a c))
        (else (sum-square b c))))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<EX1-3>>
<<try-these>>
 (try-these square-2of3 '(7 5 3)
                        '(7 3 5)
                        '(3 5 7))
#+END_SRC

#+RESULTS[0f816cfe3925898754ab7943a28f676135795e6c]:
:results:
| (7 5 3) | 74 |
| (7 3 5) | 74 |
| (3 5 7) | 74 |
:end:

* Exercise 1.4
** Question
Observe that our model of evaluation allows for combinations whose operators are
compound expressions. Use this observation to describe the behavior of the
following procedure:

#+NAME: a-plus-abs-b
#+BEGIN_SRC scheme -n
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
#+END_SRC

** Answer
This code accepts the variables ~a~ and ~b~, and if ~b~ is positive, it adds ~a~
and ~b~. However, if ~b~ is zero or negative, it subtracts them. This decision
is made by using the ~+~ and ~-~ procedures as the results of an if expression,
and then evaluating according to the results of that expression. This is in
contrast to a language like Python, which would do something like this:

#+BEGIN_SRC python :noeval :tangle no
if b > 0: a + b
else: a - b
#+END_SRC

* Exercise 1.5
** Question
Ben Bitdiddle has invented a test to determine whether the interpreter he is
faced with is using applicative-order evaluation or normal-order evaluation. He
defines the following two procedures:

#+BEGIN_SRC scheme -n :noeval :tangle no
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
#+END_SRC
Then he evaluates the expression

#+BEGIN_SRC scheme -n :noeval :tangle no
(test 0 (p))
#+END_SRC

What behavior will Ben observe with an interpreter that uses applicative-order
evaluation? What behavior will he observe with an interpreter that uses
normal-order evaluation? Explain your answer. (Assume that the evaluation rule
for the special form if is the same whether the interpreter is using normal or
applicative order: The predicate expression is evaluated first, and the result
determines whether to evaluate the consequent or the alternative expression.)

** Answer
In either type of language, src_scheme{(define (p) (p))} is an infinite
loop. However, a normal-order language will encounter the special form, return
~0~, and never evaluate ~(p)~. An applicative-order language evaluates the
arguments to src_scheme{(test 0 (p))}, thus triggering the infinite
loop.

* Exercise 1.6
** Text code
#+NAME: abs
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (abs x)
  (if (< x 0)
	  (- x)
	  x))
#+END_SRC
#+NAME: average
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (average x y)
  (/ (+ x y) 2))
#+END_SRC
#+NAME: txt-sqrt
#+BEGIN_SRC scheme -n :eval no-export :tangle no :results silent
<<average>>
(define (improve guess x)
  (average guess (/ x guess)))

<<square>>
<<abs>>
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))

(define (sqrt x)
  (sqrt-iter 1.0 x))
#+END_SRC

** Question
Exercise 1.6: Alyssa P. Hacker doesn’t see why if needs to be provided as a
special form. “Why can’t I just define it as an ordinary procedure in terms of
cond?” she asks. Alyssa’s friend Eva Lu Ator claims this can indeed be done, and
she defines a new version of if:

#+BEGIN_SRC scheme -n :noeval :tangle no
(define (new-if predicate
                then-clause
                else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
#+END_SRC
Eva demonstrates the program for Alyssa:

#+BEGIN_SRC scheme -n :noeval :tangle no
(new-if (= 2 3) 0 5)
;; => 5

(new-if (= 1 1) 0 5)
;; => 0
#+END_SRC

Delighted, Alyssa uses new-if to rewrite the square-root program:

#+BEGIN_SRC scheme -n :noeval :tangle no
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))
#+END_SRC

What happens when Alyssa attempts to use this to compute square roots? Explain.

** Answer
Using Alyssa's ~new-if~ leads to an infinite loop because the recursive call to
~sqrt-iter~ is evaluated before the actual call to ~new-if~. This is because
~if~ and ~cond~ are special forms that change the way evaluation is handled;
whichever branch is chosen leaves the other branches unevaluated.

* Exercise 1.7
** Text
#+NAME: mean-square
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (mean-square x y)
  (average (square x) (square y)))
#+END_SRC
** Question
The good-enough? test used in computing square roots will not be very effective
for finding the square roots of very small numbers. Also, in real computers,
arithmetic operations are almost always performed with limited precision. This
makes our test inadequate for very large numbers. Explain these statements, with
examples showing how the test fails for small and large numbers. An alternative
strategy for implementing good-enough? is to watch how guess changes from one
iteration to the next and to stop when the change is a very small fraction of
the guess. Design a square-root procedure that uses this kind of end test. Does
this work better for small and large numbers?
** Diary
*** Solving
My original answer was this, which compares the previous iteration until the new
and old are within an arbitrary \(dx\).

#+NAME: inferior-good-enough
#+BEGIN_SRC scheme -n :tangle no
<<txt-sqrt>>
(define (inferior-good-enough? guess lastguess)
  (<=
   (abs (-
         (/ lastguess guess)
         1))
   0.0000000000001)) ; dx
(define (new-sqrt-iter guess x lastguess) ;; Memory of previous value
  (if (inferior-good-enough? guess lastguess)
      guess
      (new-sqrt-iter (improve guess x) x guess)))
(define (new-sqrt x)
  (new-sqrt-iter 1.0 x 0))
#+end_src

This solution can correctly find small and large numbers:
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value
<<inferior-good-enough>>
(new-sqrt 10000000000000)
#+END_SRC

#+RESULTS[68a129e63924b52600a4964626d31b776d79fed2]:
:results:
3162277.6601683795
:end:

#+NAME: EX1-7-t2
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table drawer
<<try-these>>
<<inferior-good-enough>>
(try-these new-sqrt '(0.01 0.0001 0.000001 0.00000001 0.0000000001))
#+end_src

#+RESULTS[c27aa8604cebcef53580dbfc41f8585b748aacda]: EX1-7-t2
:results:
|   0.01 |                   0.1 |
| 0.0001 |                  0.01 |
|  1e-06 |                 0.001 |
|  1e-08 | 9.999999999999999e-05 |
|  1e-10 | 9.999999999999999e-06 |
:end:


However, I found this solution online that isn't just simpler but automatically
reaches the precision limit of the system:

#+NAME: new-good-enough
#+BEGIN_SRC scheme -n :eval no-export :results silent
<<txt-sqrt>>
(define (best-good-enough? guess x)
   (= (improve guess x) guess))
#+END_SRC

*** Imroving (sqrt) by avoiding extra (improve) call
**** Non-optimized
#+BEGIN_SRC scheme -n :eval no-export :tangle sqrt-bench.scheme :exports both :results output
(use-modules (ice-9 format))
(load "../mattbench.scm")
(define (average x y)
  (/ (+ x y) 2))
(define (improve guess x)
  (average guess (/ x guess)))
(define (good-enough? guess x)
   (= (improve guess x) guess)) ;; improve call 1
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x))) ;; call 2
(define (sqrt x)
  (sqrt-iter 1.0 x))
(newline)
(display (mattbench (λ() (sqrt 69420)) 400000000))
(newline)
;; 4731.30 <- Benchmark results
#+end_src

**** Optimized
#+BEGIN_SRC scheme -n :noeval :tangle sqrt-bench2.scheme :exports both :results output
(use-modules (ice-9 format))
(load "../mattbench.scm")
(define (average x y)
  (/ (+ x y) 2))
(define (improve guess x)
  (average guess (/ x guess)))
(define (good-enough? guess nextguess x)
  (= nextguess guess))
(define (sqrt-iter guess x)
  (let ((nextguess (improve guess x)))
    (if (good-enough? guess nextguess x)
        guess
        (sqrt-iter nextguess x))))
(define (sqrt x)
  (sqrt-iter 1.0 x))
(newline)
(display (mattbench (λ() (sqrt 69420)) 400000000))
(newline)
#+end_src
**** Benchmark results

| Unoptimized | 4731.30 |
| Optimized   | 2518.44 |

** Answer
The current method has decreasing accuracy with smaller numbers. Notice the
steady divergence from correct answers here (should be decreasing powers of
0.1):
#+NAME: EX1-7-t1
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<txt-sqrt>>
<<try-these>>
(try-these sqrt 0.01 0.0001 0.000001 0.00000001 0.0000000001)
#+END_SRC

#+RESULTS[b2aaaf48d742a7df9331cff3b730a799ad550cfe]: EX1-7-t1
:results:
|   0.01 |  0.10032578510960605 |
| 0.0001 |  0.03230844833048122 |
|  1e-06 | 0.031260655525445276 |
|  1e-08 |  0.03125010656242753 |
|  1e-10 |  0.03125000106562499 |
:end:

And for larger numbers, an infinite loop will eventually be reached. \(10^{12}\)
can resolve, but \(10^{13}\) cannot.

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value
<<txt-sqrt>>
(sqrt 1000000000000)
#+END_SRC

#+RESULTS[452bf3da7286d9fc1e3d621aeb715eafef650536]:
:results:
1000000.0
:end:

So, my definition of ~sqrt~:
#+NAME: sqrt
#+BEGIN_SRC scheme -n :eval no-export :exports both :results value table
<<average>>
(define (improve guess x)
  (average guess (/ x guess)))
(define (good-enough? guess x)
   (= (improve guess x) guess))
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
(define (sqrt x)
  (sqrt-iter 1.0 x))
#+end_src
#+NAME: EX1-7-t3
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<try-these>>
<<sqrt>>
(try-these sqrt '(0.01 0.0001 0.000001 0.00000001 0.0000000001))
#+end_src

#+RESULTS[7cb8301b492f578ac407eef3e3378a8d1552a5a3]: EX1-7-t3
:results:
|   0.01 |                   0.1 |
| 0.0001 |                  0.01 |
|  1e-06 |                 0.001 |
|  1e-08 | 9.999999999999999e-05 |
|  1e-10 | 9.999999999999999e-06 |
:end:

* Exercise 1.8
** Question
Newton’s method for cube roots is based on the fact that if y is an
approximation to the cube root of x, then a better approximation is given by the
value:
\begin{equation}
\frac{\frac{x}{y^2} + 2y}{3}
\end{equation}
Use this formula to implement a cube-root procedure analogous to the square-root
procedure. (In 1.3.4 we will see how to implement Newton’s method in general as
an abstraction of these square-root and cube-root procedures.)
** Diary
My first attempt works, but needs an arbitrary limit to stop infinite loops:
#+NAME: EX1-8-A1
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<square>>
<<try-these>>
(define (cb-good-enough? guess x)
  (= (cb-improve guess x) guess))
(define (cb-improve guess x)
  (/
   (+
    (/ x (square guess))
    (* guess 2))
   3))
(define (cbrt-iter guess x counter)
  (if (or (cb-good-enough? guess x) (> counter 100))
      guess
      (begin
        (cbrt-iter (cb-improve guess x) x (+ 1 counter)))))
(define (cbrt x)
  (cbrt-iter 1.0 x 0))

(try-these cbrt 7 32 56 100)
#+end_src

#+RESULTS[1eb5546cd3e124a63b0cd988f571097371a60813]: EX1-8-A1
:results:
|   7 | 1.912931182772389 |
|  32 | 3.174802103936399 |
|  56 | 3.825862365544778 |
| 100 | 4.641588833612779 |
:end:

However, this will hang on an infinite loop when trying to run src_scheme{(cbrt 100)}.
I speculate it's a floating point precision issue with the "improve"
algorithm. So to avoid it I'll just keep track of the last guess and stop
improving when there's no more change occurring. Also while researching I
discovered that (again due to floating point) src_scheme{(cbrt -2)} loops
forever unless you initialize your guess with a slightly different value, so
let's do 1.1 instead.
** Answer
#+NAME: cbrt
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
<<square>>
(define (cb-good-enough? nextguess guess lastguess x)
  (or (= nextguess guess)
      (= nextguess lastguess)))
(define (cb-improve guess x)
  (/
   (+
    (/ x (square guess))
    (* guess 2))
   3))
(define (cbrt-iter guess lastguess x)
  (define nextguess (cb-improve guess x))
  (if (cb-good-enough? nextguess guess lastguess x)
      nextguess
      (cbrt-iter nextguess guess x)))
(define (cbrt x)
  (cbrt-iter 1.1 9999 x))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<cbrt>>
<<try-these>>
(try-these cbrt 7 32 56 100 -2)
#+END_SRC

#+RESULTS[965031d6fc942ec767b94f18bc03219f3a3f93d6]:
:results:
|   7 |   1.912931182772389 |
|  32 |   3.174802103936399 |
|  56 |   3.825862365544778 |
| 100 |   4.641588833612779 |
|  -2 | -1.2599210498948732 |
:end:

* Exercise 1.9
** Question
Each of the following two procedures defines a method for adding two positive
integers in terms of the procedures inc, which increments its argument by 1, and
dec, which decrements its argument by 1.

#+BEGIN_SRC scheme -n :noeval :tangle no
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
#+END_SRC

Using the substitution model, illustrate the process generated by each procedure
in evaluating src_scheme{(+ 4 5)}. Are these processes iterative or recursive?
** Answer
The first procedure is recursive, while the second is iterative though
tail-recursion.
*** recursive procedure
#+BEGIN_SRC scheme -n :noeval :tangle no
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
#+END_SRC

*** iterative procedure
#+BEGIN_SRC scheme -n :noeval :tangle no
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
#+END_SRC

* Exercise 1.10
** Question
The following procedure computes a mathematical function called Ackermann’s
function.
#+NAME: ackermann
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
#+END_SRC

What are the values of the following expressions?

#+BEGIN_SRC scheme -n :noeval :tangle no
(A 1 10)
(A 2 4)
(A 3 3)
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :exports results :tangle no :results value table
<<try-these>>
<<ackermann>>
(try-these A '(1 10) '(2 4) '(3 3))
#+END_SRC

#+RESULTS[48e58b6029bccdcb0ec0cba4c437572b3b5c2437]:
:results:
| (1 10) |  1024 |
| (2 4)  | 65536 |
| (3 3)  | 65536 |
:end:

#+NAME: EX1-10-defs
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
<<ackermann>>
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
#+END_SRC

Give concise mathematical definitions for the functions computed by the
procedures ~f~, ~g~, and ~h~ for positive integer values of \(n\). For example,
src_scheme{(k n)} computes \(5n^2\).

** Answer
*** ~f~

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<try-these>>
<<EX1-10-defs>>
(try-these f 1 2 3 10 15 20)
#+END_SRC

#+RESULTS[d24f130b3c260d786e4cb6a89fa32c320b8c9216]:
:results:
|  1 |  2 |
|  2 |  4 |
|  3 |  6 |
| 10 | 20 |
| 15 | 30 |
| 20 | 40 |
:end:

\[
f(n)=2n
\]
*** ~g~

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<try-these>>
<<EX1-10-defs>>
(try-these g 1 2 3 4 5 6 7 8)
#+END_SRC

#+RESULTS[2de64054dc56968afee805dc8757b991e4f74d88]:
:results:
| 1 |   2 |
| 2 |   4 |
| 3 |   8 |
| 4 |  16 |
| 5 |  32 |
| 6 |  64 |
| 7 | 128 |
| 8 | 256 |
:end:

\[
g(n)=2^n
\]

*** ~h~

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<try-these>>
<<EX1-10-defs>>
(try-these h 1 2 3 4)
#+END_SRC

#+RESULTS[b80263a28bd5076f3bfa3f4bae09ec511773e7af]:
:results:
| 1 |     2 |
| 2 |     4 |
| 3 |    16 |
| 4 | 65536 |
:end:

It took a while to figure this one out, just because I didn't know the term.
This is repeated exponentiation. This operation is to exponentiation, what
exponentiation is to multiplication. It's called either /tetration/ or /hyper-4/
and has no formal notation, but two common ways would be these:

\[
h(n)=2 \uparrow\uparrow n
\]
\[
h(n)={}^{n}2
\]

* Exercise 1.11
** Question
A function \(f\) is defined by the rule that:
\[
f(n)=n \text{ if } n<3
\]
\[
\text{ and }
\]
\[
f(n)=f(n-1)+2f(n-2)+3f(n-3) \text{ if } n \geq 3
\]

Write a procedure that computes \(f\) by means of a recursive process. Write a
procedure that computes \(f\) by means of an iterative process.
** Answer
*** Recursive
#+NAME: EX1-11-fr
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports code :results silent
(define (fr n)
  (if (< n 3)
      n
      (+      (fr (- n 1))
         (* 2 (fr (- n 2)))
         (* 3 (fr (- n 3))))))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<try-these>>
<<EX1-11-fr>>
(try-these fr 1 3 5 10)
#+END_SRC

#+RESULTS[d54b80d2fe7a526473762819190f33a520a19fe4]:
:results:
|  1 |    1 |
|  3 |    4 |
|  5 |   25 |
| 10 | 1892 |
:end:

*** Iterative
**** Attempt 1
#+NAME: EX1-11-fi
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports code :results silent
;; This seems like it could be better
(define (fi n)
  (define (formula l)
    (let ((a (car l))
           (b (cadr l))
           (c (caddr l)))
      (+ a
         (* 2 b)
         (* 3 c))))
  (define (iter l i)
    (if (= i n)
        (car l)
        (iter (cons (formula l) l)
              (+ 1 i))))
  (if (< n 3)
      n
      (iter '(2 1 0) 2)))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<try-these>>
<<EX1-11-fi>>
(try-these fi 1 3 5 10)
#+END_SRC

#+RESULTS[77f33e30f912c03277beeb8092d92c55abfcc936]:
:results:
|  1 |    1 |
|  3 |    4 |
|  5 |   25 |
| 10 | 1892 |
:end:

It works but it seems wasteful.

**** Attempt 2
#+NAME: EX1-11-fi2
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports code :results silent
(define (fi2 n)
  (define (formula a b c)
      (+ a
         (* 2 b)
         (* 3 c)))
  (define (iter a b c i)
    (if (= i n)
        a
        (iter (formula a b c)
              a
              b
              (+ 1 i))))
  (if (< n 3)
      n
      (iter 2 1 0 2)))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<try-these>>
<<EX1-11-fi2>>
(try-these fi2 1 3 5 10)
#+END_SRC

#+RESULTS[baa8cd23dfff7b5fa47ae133b0a8b58ef2cb9a61]:
:results:
|  1 |    1 |
|  3 |    4 |
|  5 |   25 |
| 10 | 1892 |
:end:

I like that better.

* Exercise 1.12
** Question
The following pattern of numbers is called Pascal’s triangle.

/Pretend there's a Pascal's triangle here./

The numbers at the edge of the triangle are all 1, and each number inside the
triangle is the sum of the two numbers above it. Write a procedure that
computes elements of Pascal’s triangle by means of a recursive process.
** Answer
I guess I'll rotate the triangle 45 degrees to make it the top-left corner of an
infinite spreadsheet.

#+NAME: pascal-rec
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (pascal x y)
  (if (or (= x 0)
          (= y 0))
      1
      (+ (pascal (- x 1) y)
         (pascal x (- y 1)))))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<try-these>>
<<pascal-rec>>
(let ((l (iota 8)))
  (map (λ (row)
         (map (λ (xy)
                (apply pascal xy))
              row))
       (map (λ (x)
              (map (λ (y)
                     (list x y))
                   l))
            l)))
#+END_SRC

#+RESULTS[151500842c6cdef9252eaf15c1323fc7bcba0527]:
:results:
| 1 | 1 |  1 |   1 |   1 |   1 |    1 |    1 |
| 1 | 2 |  3 |   4 |   5 |   6 |    7 |    8 |
| 1 | 3 |  6 |  10 |  15 |  21 |   28 |   36 |
| 1 | 4 | 10 |  20 |  35 |  56 |   84 |  120 |
| 1 | 5 | 15 |  35 |  70 | 126 |  210 |  330 |
| 1 | 6 | 21 |  56 | 126 | 252 |  462 |  792 |
| 1 | 7 | 28 |  84 | 210 | 462 |  924 | 1716 |
| 1 | 8 | 36 | 120 | 330 | 792 | 1716 | 3432 |
:end:

The test code was much harder to write than the actual solution.

* Exercise 1.13
** Question
Prove that \(\text{Fib}(n)\) is the closest integer to
\(\frac{ϕ^n}{\sqrt{5}}\) where Phi is \(\frac{1 + \sqrt{5}}{2}\). Hint: let
\(Υ = \frac{1 - \sqrt{5}}{2}\). Use induction and the definition of the
Fibonacci numbers to prove that

\[
 \text{Fib}(n) = \frac{ϕ^n - Υ^n}{\sqrt{5}}
\]

** Answer
I don't know how to write a proof yet, but I can make functions to
demonstrate it.

*** Fibonacci number generator
#+NAME: fib-iter
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (fib-iter n)
  (define (iter i a b)
    (if (= i n)
        b
    (iter (+ i 1)
          b
          (+ a b))))
  (if (<= n 2)
      1
      (iter 2 1 1)))
#+END_SRC
*** Various algorithms relating to the question
#+NAME: fib-phi
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
<<sqrt>>
(define sqrt5
  (sqrt 5))
(define phi
  (/ (+ 1 sqrt5) 2))
(define upsilon
  (/ (- 1 sqrt5) 2))
(define (fib-phi n)
  (/ (- (expt phi n)
        (expt upsilon n))
     sqrt5))
#+END_SRC
#+NAME: 1-13-tab
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
(use-srfis '(1))
<<fib-iter>>
<<fib-phi>>
<<try-these>>

(let* ((vals (drop (iota 21) 10))
       (fibs (map fib-iter vals))
       (approx (map fib-phi vals)))
  (zip vals fibs approx))
#+END_SRC

#+RESULTS[732483d41040c13f1e9a125ebe5a0ecdca1f5d18]: 1-13-tab
:results:
| 10 |   55 |  54.99999999999999 |
| 11 |   89 |               89.0 |
| 12 |  144 | 143.99999999999997 |
| 13 |  233 | 232.99999999999994 |
| 14 |  377 | 377.00000000000006 |
| 15 |  610 |              610.0 |
| 16 |  987 |  986.9999999999998 |
| 17 | 1597 | 1596.9999999999998 |
| 18 | 2584 |             2584.0 |
| 19 | 4181 |             4181.0 |
| 20 | 6765 |  6764.999999999999 |
:end:

You can see they follow closely. Graphing the differences, it's just
an exponential curve at very low values, presumably following the
exponential increase of the Fibonacci sequence itself.
#+NAME: 1-13-tab2
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports none :results value silent
(use-srfis '(1))
<<fib-iter>>
<<fib-phi>>
<<try-these>>

(let* ((vals (drop (iota 500) 2))
       (diffs (map (λ (i)
                     (- (fib-iter i) (fib-phi i)))
                   vals)))
  (zip vals diffs))
#+END_SRC



#+begin_src gnuplot :var data=1-13-tab2 :file 1/fig/1-13.png :exports results :eval no-export
reset # helps with various issues in execution
set xlabel 'values of n'
set logscale y

plot data using 1:2 with lines title 'Fib(n) minus Fib-phi(n)'
#+end_src

#+RESULTS[8c0a67c9f76a9da9c115187192a6c35899c939cb]:
:results:
[[file:fig/1-13.png]]
:end:

* Exercise 1.14
Below is the default version of the count-change function. I'll be aggressively
modifying it in order to get a graph out of it.
#+NAME: count-change
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0)
             (= kinds-of-coins 0))
         0)
        (else
         (+ (cc amount (- kinds-of-coins 1))
            (cc (- amount (first-denomination
                           kinds-of-coins))
                kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
#+end_src
** Question A
Draw the tree illustrating the process generated by the count-change procedure
of 1.2.2 in making change for 11 cents.
** Answer
I want to generate this graph algorithmically.
#+NAME: count-change-graphviz
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
;; cursed global
(define bubblecounter 0)
;; Returns # of ways change can be made
;; "Helper" for (cc)
(define (count-change amount)
  (display "digraph {\n") ;; start graph
  (cc amount 5 0)
  (display "}\n") ;; end graph
  (set! bubblecounter 0))

;; GraphViz output
;; Derivative: https://stackoverflow.com/a/14806144
(define (cc amount kinds-of-coins oldbubble)
  (let ((recur (lambda (new-amount new-kinds)
                 (begin
                   (display "\"") ;; Source bubble
                   (display `(,oldbubble ,amount ,kinds-of-coins))
                   (display "\"")
                   (display " -> ") ;; arrow pointing from parent to child
                   (display "\"") ;; child bubble
                   (display `(,bubblecounter ,new-amount ,new-kinds))
                   (display "\"")
                   (display "\n")
                   (cc new-amount new-kinds bubblecounter)))))
    (set! bubblecounter (+ bubblecounter 1))
    (cond ((= amount 0) 1)
          ((or (< amount 0) (= kinds-of-coins 0)) 0)
          (else (+
                 (recur amount (- kinds-of-coins 1))
                 (recur (- amount
                           (first-denomination kinds-of-coins))
                        kinds-of-coins))))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
#+end_src

I'm not going to include the full printout of the ~(count-change 11)~, here's an example of what this looks like via ~1~.
#+NAME: count-change-test
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results output code
<<count-change-graphviz>>
(count-change 1)
#+end_src

#+RESULTS[626488f89e622bb93d8813545c83ec8fe4c1254c]: count-change-test
#+begin_src dot
digraph {
"(0 1 5)" -> "(1 1 4)"
"(1 1 4)" -> "(2 1 3)"
"(2 1 3)" -> "(3 1 2)"
"(3 1 2)" -> "(4 1 1)"
"(4 1 1)" -> "(5 1 0)"
"(4 1 1)" -> "(6 0 1)"
"(3 1 2)" -> "(7 -4 2)"
"(2 1 3)" -> "(8 -9 3)"
"(1 1 4)" -> "(9 -24 4)"
"(0 1 5)" -> "(10 -49 5)"
}
#+end_src

#+BEGIN_SRC dot :file 1/fig/cc-test.png :exports results :var data=count-change-test :eval no-export
$data
#+end_src

#+RESULTS[2f9cd2c1031a74ba1f68d4d2a7602c619a798efd]:
:results:
[[file:fig/cc-test.png]]
:end:

So, the graph of ~(count-change 11)~ is:
#+NAME: count-change-11
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports none :results silent output
<<count-change-graphviz>>
(count-change 11)
#+end_src

#+BEGIN_SRC dot :file 1/fig/cc-11.png :exports results :var data=count-change-11 :eval no-export
$data
#+end_src

#+RESULTS[914f8aa869c783656d6a64eb7535f44d22158d20]:
:results:
[[file:fig/cc-11.png]]
:end:

** Question B
What are the orders of growth of the space and number of steps used by this
process as the amount to be changed increases?

** Answer B
Let's look at this via the number of function calls needed for value ~n~. Instead
of returning an integer, I'll return a pair where ~car~ is the number of ways to
count change, and ~cdr~ is the number of function calls that have occurred down
that branch of the tree.

#+NAME: cc-calls
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (count-calls amount)
  (cc-calls amount 5))

(define (cc-calls amount kinds-of-coins)
  (cond ((= amount 0) '(1 . 1))
        ((or (< amount 0)
             (= kinds-of-coins 0))
         '(0 . 1))
        (else
         (let ((a (cc-calls amount (- kinds-of-coins 1)))
               (b (cc-calls (- amount (first-denomination
                                 kinds-of-coins))
                      kinds-of-coins)))
           (cons (+ (car a)
                    (car b))
                 (+ 1
                    (cdr a)
                    (cdr b)))))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
#+end_src


#+NAME: cc-calls-check
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports none :results value table
;; Test to verify that this function is working as expected.
(use-srfis '(1))
<<count-change>>
<<cc-calls>>
(let* ((vals (drop (iota 11) 1))
       (textbook (map count-change vals))
       (mine (map count-calls vals)))
  (zip vals textbook mine))
#+end_src

#+RESULTS[b7476dc844e2456ebb48c7e96462fe180d60101b]: cc-calls-check
:results:
|  1 | 1 | (1 . 11) |
|  2 | 1 | (1 . 13) |
|  3 | 1 | (1 . 15) |
|  4 | 1 | (1 . 17) |
|  5 | 2 | (2 . 19) |
|  6 | 2 | (2 . 25) |
|  7 | 2 | (2 . 29) |
|  8 | 2 | (2 . 33) |
|  9 | 2 | (2 . 37) |
| 10 | 4 | (4 . 41) |
:end:

#+NAME: cc-calls-100
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports code :results silent value table
(use-srfis '(1))
<<cc-calls>>
(let* ((vals (drop (iota 101) 1))
       (mine (map count-calls vals)))
  (zip vals (map car mine) (map cdr mine)))
#+end_src

#+begin_src gnuplot :var data=cc-calls-100 :file 1/fig/cc-100.png :exports results :eval no-export
reset # helps with various issues in execution
set key top left
set logscale y
set xlabel 'values of n'

plot data using 1:2 with lp title 'Ways to make change for n', \
     data using 1:3 with lp title 'function calls'
#+end_src

#+RESULTS[134cbc95d12b4367d5be943722725cd0baca1d87]:
:results:
[[file:fig/cc-100.png]]
:end:

I believe the space to be \(\Theta(n+d)\) as the function calls count down the
denominations before counting down the change. However I notice most answers
describe \(\Theta(n)\) instead, maybe I'm being overly pedantic and getting the
wrong answer.

My issues came finding the time. The book describes the meaning and properties
of \(\Theta\) notation in [[http://sarabander.github.io/sicp/html/1_002e2.xhtml#g_t1_002e2_002e3][Section 1.2.3]]. However, my lack of formal math
education made realizing the significance of this passage difficult. For one, I
didn't understand that \(k_{1}f(n) \leq R(n) \leq k_{2}f(n)\) means "you can
find the \(\Theta\) by proving that a graph of the algorithm's resource usage is
bounded by two identical functions multiplied by constants." So, the graph of
resource usage for an algorithm with \(\Theta(n^{2})\) will by bounded by lines
of \(n^{2} \times some constant\), the top boundary's constant being larger than
the small boundary. These are arbitrarily chosen constants, you're just proving
that the function behaves the way you think it does.

Overall, finding the \(\Theta\) and \(\Omega\) and \(O\) notations (they are all
different btw!) is about aggressively simplifying to make a very general
statement about the behavior of the algorithm.

I could tell that a "correct" way to find the \(\Theta\) would be to make a
formula which describes the algorithm's function calls for given input and
denominations. This is one of the biggest time sinks, although I had a lot of
fun and learned a lot. In the end, with some help from Jach in a Lisp Discord, I
had the following formula:

\[
\sum_{i=1}^{ceil(n / val(d))} T(n - val(d)*i, d)
\]

But I wasn't sure where to go from here. The graphs let me see some interesting
trends, though I didn't get any closer to an answer in the process.

By reading on other websites, I knew that you could find \(\Theta\) by obtaining
a formula for \(R(n)\) and removing constants to end up with a term of interest.
For example, if your algorithm's resource usage is \(\frac{n^{2} + 7n}{5}\),
this demonstrates \(\Theta(n^{2})\). So I know a formula *without* a \(\sum\)
would give me the answer I wanted. It didn't occur to me that it might be
possible to use calculus to remove the \(\sum\) from the equation. At this point
I knew I was stuck and decided to look up a guide.

After seeing a few solutions that I found somewhat confusing, I landed on [[https://codology.net/post/sicp-solution-exercise-1-14/][this
awesome article from Codology.net]]. They show how you can remove the summation,
and proposed this equation for count-change with 5 denominations:

\[
T(n,5)=\frac n{50}+1+\sum_{i=0}^{n/50}T(n-50i,1)
\]

Which, when expanded and simplified, demonstrates \(\Theta(n^{5})\) for 5
denominations.

Overall I'm relieved that I wasn't entirely off, given I haven't done math work
like this since college. It's inspired me to restart my remedial math courses, I
don't think I really grasped the nature of math as a tool of empowerment until
now.

* Exercise 1.15
** Question A
The sine of an angle (specified in radians) can be computed by making use of the
approximation \(\sin x ≈ x\) if \(x\) is sufficiently small, and the
trigonometric identity \(\sin x = 3\sin\frac{x}{3} − 4\sin^3\frac{x}{3}\)
to reduce the size of the argument of sin. (For purposes of this exercise an
angle is considered “sufficiently small” if its magnitude is not greater than
0.1 radians.) These ideas are incorporated in the following procedures:

#+NAME: 1-15-deps
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))
#+end_src

How many times is the procedure ~p~ applied when src_scheme{(sine 12.15)} is evaluated?

** Answer A

Let's find out!
#+NAME: 1-15-p-measure
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
  (if (not (> (abs angle) 0.1))
      (cons angle 0)
      (let ((x (sine (/ angle 3.0))))
        (cons (p (car x)) (+ 1 (cdr x))))))
#+end_src

#+NAME: 1-15-sine1215
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value
<<1-15-p-measure>>
(let ((xy (sine 12.15)))
  (list (car xy) (cdr xy)))
#+end_src

#+RESULTS[a951cb0c1f0af6041c8ea65b70c08abec9d7fd95]: 1-15-sine1215
:results:
| -0.39980345741334 | 5 |
:end:

~p~ is evaluated 5 times.

** Question B
What is the order of growth in space and number of steps (as a function of ~a~)
used by the process generated by the sine procedure when src_scheme{(sine a)} is
evaluated?

** Answer B
#+NAME: 1-15-tab1
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results silent value table
(use-srfis '(1))
<<1-15-p-measure>>
(let* ((vals (iota 300 0.1 0.1))
       (sines (map (λ (i)
                     (cdr (sine i)))
                   vals)))
  (zip vals sines))
#+end_src
#+end_src
#+NAME: 1-15-tab1-test
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports result :results value table
(use-srfis '(1))
<<1-15-p-measure>>
(let* ((vals (iota 10 0.1 0.1))
       (sines (map (λ (i)
                     (cdr (sine i)))
                   vals)))
  (zip vals sines))
#+end_src

Example output:
#+RESULTS[fb3135304f5470edbe145abf5ad93ef8829e4e8c]: 1-15-tab1-test
:results:
|                 0.1 | 0 |
|                 0.2 | 1 |
| 0.30000000000000004 | 2 |
|                 0.4 | 2 |
|                 0.5 | 2 |
|                 0.6 | 2 |
|  0.7000000000000001 | 2 |
|                 0.8 | 2 |
|                 0.9 | 2 |
|                 1.0 | 3 |
:end:
#+BEGIN_COMMENT
#+NAME: 1-15-smoothfill
#+begin_src gnuplot :var data=1-15-tab1 :file 1/fig/1-15-smoothfill.png :exports none :eval no-export
# This graph has a cool filled difference, but unfortunately I can't do
# steps with it, so it's disabled. :(
reset # helps with various issues in execution
set xlabel 'values of x'
set logscale x
set key top left
set style fill solid 1.00 border
set style function fillsteps below y

f(x) = log(x) + 2.3

plot data using 1:2:(f($1)) with filledcurves title 'function calls', \
     data using 1:(f($1)) with lines title 'log(x) + 2.3'
#+end_src

#+RESULTS[cda98404343075e48a2b594fa5d2b60803f911d3]: 1-15-smoothfill
:results:
[[file:fig/1-15-smoothfill.png]]
:end:
#+END_COMMENT

#+begin_src gnuplot :var data=1-15-tab1 :file 1/fig/1-15-step.png :exports both :eval no-export
reset # helps with various issues in execution
set xlabel 'values of x'
set logscale x
set key top left
set style fill solid 1.00 border
set style function fillsteps below

f(x) = log(x) + 2.3

plot data using 1:2 with fillsteps title 'function calls', \
     data using 1:(f($1)) with lines title 'log(x) + 2. 3'
#+end_src

#+RESULTS[460dc2cffdff776bf4e3a46cb26ac66180108b4a]:
:results:
[[file:fig/1-15-step.png]]
:end:

This graph shows that the number of times ~sine~ will be called is logarithmic.
- 0.1 to 0.2 are divided once
- 0.3 to 0.8 are divided twice
- 0.9 to 2.6 are divided three times
- 2.7 to 8 are divided four times
- 8.5 to 23.8 are divided five times

Given that the calls to ~p~ get stacked recursively, like this:
#+BEGIN_SRC scheme :noeval :exports code
(sine 12.15)
(p (sine 4.05))
(p (p (sine 1.35)))
(p (p (p (sine 0.45))))
(p (p (p (p (sine 0.15)))))
(p (p (p (p (p (sine 0.05))))))
(p (p (p (p (p 0.05)))))
(p (p (p (p 0.14950000000000002))))
(p (p (p 0.43513455050000005)))
(p (p 0.9758465331678772))
(p -0.7895631144708228)
-0.39980345741334
#+END_SRC

So I argue the space and time is \(\Theta(\log(n))\)


We can also prove this for the time by benchmarking the function:

#+NAME: 1-15-sine-bench
#+BEGIN_SRC scheme -n :noeval :tangle "Ex15/sine-bench.scheme" :exports code :results none
;; This execution takes too long for org-mode, so I'm doing it
;; externally and importing the results
(use-srfis '(1))
(use-modules (ice-9 format))
(load "../../mattbench.scm")
<<1-15-deps>>
(let* ((vals (iota 300 0.1 0.1))
       (times (map (λ (i)
                     (mattbench (λ () (sine i)) 1000000))
                   vals)))
  (with-output-to-file "sine-bench.dat" (λ ()
     (map (λ (x y)
           (format #t "~s~/~s~%" x y))
         vals times))))
#+END_SRC

#+begin_src gnuplot :file 1/fig/1-15-bench.png :exports both :eval no-export
reset # helps with various issues in execution
set xtics 0.5
set xlabel 'values of x'
set logscale x
set key top left
set style fill solid 1.00 border
#set style function fillsteps below

f(x) = (log(x) * a) + b
fit f(x) 'Ex15/sine-bench.dat' using 1:2 via a,b

plot 'Ex15/sine-bench.dat' using 1:2 with fillsteps title 'time to execute', \
     'Ex15/sine-bench.dat' using 1:(f($1)) with lines title sprintf('(log(x) * %.2f) + %.2f', a, b)
#+end_src

#+RESULTS[fb7f0aefd66103c1d2a3d67706e4323de589c4f9]:
:results:
[[file:fig/1-15-bench.png]]
:end:

* Exercise 1.16
** Text
#+NAME: txt-expt
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (expt-rec b n)
  (if (= n 0) 
      1 
      (* b (expt-rec b (- n 1)))))

(define (expt-iter b n) 
  (define (iter counter product)
    (if (= counter 0)
        product
        (iter (- counter 1)
              (* b product))))
  (iter n 1))

(define (fast-expt b n)
  (cond ((= n 0) 
         1)
        ((even? n) 
         (square (fast-expt b (/ n 2))))
        (else 
         (* b (fast-expt b (- n 1))))))
#+end_src
** Question
Design a procedure that evolves an iterative exponentiation process that uses
successive squaring and uses a logarithmic number of steps, as does fast-expt.
(Hint: Using the observation that \((b^{n/2})^2=(b^2)^{n/2}\), keep, along with
the exponent \(n\) and the base \(b\), an additional state variable \(a\) , and
define the state transformation in such a way that the product \({ab}^n\) is
unchanged from state to state. At the beginning of the process \(a\) is taken to
be 1, and the answer is given by the value of \(a\) at the end of the process.
In general, the technique of defining an /invariant quantity/ that remains
unchanged from state to state is a powerful way to think about the design of
iterative algorithms.)
** Diary
First I made this program which tries to use a false equivalence:
\[ab^2 = (a + 1)b^{n - 1}\]
#+NAME: fast-expt-iter-fail1
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
<<square>>
(define (fast-expt-iter b n)
  (define (iter b n a)
    (format #t "~&|~s~/~/|~s~/~/|~s|~%" b n a)
    (cond ((= n 1) (begin (format #t "~&|~s~/~/|~s~/~/|~s|~%" (* b a) 1 1)
                          (* b a)))
          ((even? n) (iter (square b)
                         (/ n 2)
                         a))
          (else (iter b (- n 1) (+ a 1)))))
  (format #t "|~a~/|~a~/|~a|~%" "base" "power" "variable")
  (format #t "~&|--|--|--|~%")
  (iter b n 1))
#+end_src

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results output table :colnames yes
<<fast-expt-iter-fail1>>
<<try-these>>
(fast-expt-iter 2 6)
#+end_src

Here's what the internal state looks like during \(2^6\) (correct answer is 64):
#+RESULTS[314048443b97e46f3f43465460b4f52dc1e4a12c]:
:results:
| base | power | variable |
|------+-------+----------|
|    2 |     6 |        1 |
|    4 |     3 |        1 |
|    4 |     2 |        2 |
|   16 |     1 |        2 |
|   32 |     1 |        1 |
:end:

** Answer
There are two key transforms to a faster algorithm. The first was already shown
in the text:

\[
    ab^n \to a(b^2)^{n/2}
\]

The second which I needed to deduce was this:

\[
    ab^n \to ((a \times b) \times b)^{n - 1}
\]

The solution essentially follows this logic:
- initialize \(a\) to 1
- If \( n \) is 1, return \(b * a\)
- else if \(n\) is even, halve \(n\), square \(b\), and iterate
- else \(n\) is odd, so subtract 1 from \(n\) and \(a \to a \times b\)

#+NAME: fast-expt-iter
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
<<square>>
(define (fast-expt-iter b n)
  (define (iter b n a)
    (cond ((= n 1) (* b a))
          ((even? n) (iter (square b)
                         (/ n 2)
                         a))
          (else (iter b (- n 1) (* b a)))))
  (iter b n 1))
#+end_src

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports yes :results value table
<<fast-expt-iter>>
<<try-these>>
(try-these (λ(x) (fast-expt-iter 3 x)) (cdr (iota 11)))
#+end_src

#+RESULTS[ae537d78c52d471bef9f5b0951596dc3d4340603]:
:results:
|  1 |     3 |
|  2 |     9 |
|  3 |    27 |
|  4 |    81 |
|  5 |   243 |
|  6 |   729 |
|  7 |  2187 |
|  8 |  6561 |
|  9 | 19683 |
| 10 | 59049 |
:end:

* Exercise 1.17
** Question
The exponentiation algorithms in this section are based on performing
exponentiation by means of repeated multiplication. In a similar way, one can
perform integer multiplication by means of repeated addition. The following
multiplication procedure (in which it is assumed that our language can only add,
not multiply) is analogous to the expt procedure:

#+BEGIN_SRC scheme -n
(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))
#+end_src

This algorithm takes a number of steps that is linear in \( b \). Now suppose we
include, together with addition, operations double, which doubles an integer,
and halve, which divides an (even) integer by 2. Using these, design a
multiplication procedure analogous to fast-expt that uses a logarithmic number
of steps.

** Answer
#+NAME: fast-mult-rec
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (double x)
  (+ x x))
(define (halve x)
  (/ x 2))
(define (fast-mult-rec a b)
  (cond ((= b 0) 0)
        ((even? b)
         (double (fast-mult-rec a (halve b)))) ; This was kind of a stretch to think of.G
         ;(fast-mult (double a) (halve b))) <== My first instinct is iterative
        (else (+ a (fast-mult-rec a (- b 1))))))
#+end_src

Proof it works:

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports yes :results value table
<<fast-mult-rec>>
<<try-these>>
(try-these (λ(x) (fast-mult-rec 3 x)) (cdr (iota 11)))
#+end_src

#+RESULTS[3ce2cd1f0e04c83aac17e721c2e17a937fc0cb25]:
:results:
|  1 |  3 |
|  2 |  6 |
|  3 |  9 |
|  4 | 12 |
|  5 | 15 |
|  6 | 18 |
|  7 | 21 |
|  8 | 24 |
|  9 | 27 |
| 10 | 30 |
:end:

* Exercise 1.18
** Question
Using the results of [[*Exercise 1.16][Exercise 1.16]] and [[*Exercise 1.17][Exercise 1.17]], devise a procedure that
generates an iterative process for multiplying two integers in terms of adding,
doubling, and halving and uses a logarithmic number of steps.
** Diary
*** Comparison benchmarks:

#+BEGIN_SRC scheme -n :tangle Ex1-18bench.scheme :exports code :results silent
(load "../mattbench.scm")
<<fast-mult-iter>>
<<fast-mult-rec>>
<<print-table>>
(print-table (list (list "fast-mult-rec" "fast-mult-iter")
                   (list (mattbench (λ() (fast-mult-rec 32 32)) 10000000)
                         (mattbench (λ() (fast-mult 32 32)) 10000000)))
             #:colnames #t)
#+END_SRC

| "fast-mult-rec" | "fast-mult-iter" |
|-----------------+------------------|
|          196.89 |           166.35 |

So the iterative version takes 0.84 times less to do \(32 \times 32\).
*** Hall of shame
Some of my /very/ incorrect ideas:
\[ab = (a+1)(b-1)\]
\[ab = \big(a+\Big(\frac{a}{2}\Big)(b-1)\big)\]
\[ab+c = \big(a(b-1)+(b+c)\big)\]
** Answer
#+NAME: fast-mult-iter
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (double x)
  (+ x x))
(define (halve x)
  (/ x 2))
(define (fast-mult a b)
  (define (iter a b c)
    (cond ((= b 0) 0)
          ((= b 1) (+ a c))
          ((even? b)
           (iter (double a) (halve b) c))
          (else (iter a (- b 1) (+ a c)))))
  (iter a b 0))
#+end_src
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports yes :results value table
<<fast-mult-iter>>
<<try-these>>
(try-these (λ(x) (fast-mult 3 x)) (cdr (iota 11)))
#+end_src

#+RESULTS[900f6cc983a51f9e0902587546cbd7d746845b50]:
:results:
|  1 |  3 |
|  2 |  6 |
|  3 |  9 |
|  4 | 12 |
|  5 | 15 |
|  6 | 18 |
|  7 | 21 |
|  8 | 24 |
|  9 | 27 |
| 10 | 30 |
:end:

* Exercise 1.19
** Question
There is a clever algorithm for computing the Fibonacci numbers in a logarithmic
number of steps. Recall the transformation of the state variables a and b in the
~fib-iter~ process of section 1-2-2:

\[a <- a + b\text{ and }b <- a\]

Call this transformation T, and observe that applying T over and over again n
times, starting with 1 and 0, produces the pair _Fib_(n + 1) and _Fib_(n). In
other words, the Fibonacci numbers are produced by applying \( T^n \), the nth
power of the transformation T, starting with the pair (1,0). Now consider T to
be the special case of p = 0 and q = 1 in a family of transformations \(
T_{(pq)} \), where \( T_{(pq)} \) transforms the pair (a,b) according to \( a <-
bq + aq + ap \) and \( b <- bp + aq \). Show that if we apply such a
transformation \( T_{(pq)} \) twice, the effect is the same as using a single
transformation \( T_{(p'q')} \) of the same form, and compute p' and q' in terms
of p and q. This gives us an explicit way to square these transformations, and
thus we can compute \( T^n \) using successive squaring, as in the `fast-expt'
procedure. Put this all together to complete the following procedure, which runs
in a logarithmic number of steps:
#+BEGIN_SRC scheme -n :noeval :tangle no :exports code :results silent
(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   <??>      ; compute p'
                   <??>      ; compute q'
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
#+END_SRC

** Diary
More succinctly put:

\[
    \text{Fib}_n \begin{cases}
        a \leftarrow a + b\\
        b \leftarrow a
    \end{cases}
\]
\[
    \text{Fib-iter}_{abpq} \begin{cases}
        a \leftarrow bq + aq + ap\\
        b \leftarrow bp + aq
    \end{cases}
\]

src_scheme{(T)} returns a transformation function based on the two numbers in
the attached list. so src_scheme{(T 0 1)} returns a fib function.

#+NAME: T-func
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (T p q)
  (λ (a b)
    (cons (+ (* b q) (* a q) (* a p))
          (+ (* b p) (* a q)))))

(define T-fib
  (T 0 1))

;; Repeatedly apply T functions:
(define (Tr f n)
  (Tr-iter f n 0 1))
(define (Tr-iter f n a b)
  (if (= n 0)
      a
      (let ((l (f a b)))
        (Tr-iter f (- n 1) (car l) (cdr l)))))
#+END_SRC

\[
    \text{T}_{pq}: a,b\mapsto \begin{cases}
        a \leftarrow bq + aq + ap\\
        b \leftarrow bp + aq
    \end{cases}
\]

#+NAME: T-test
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<T-func>>
<<try-these>>
(try-these (λ (x) (Tr (T 0 1) x)) (cdr (iota 11)))
#+END_SRC

#+RESULTS[b253f74cff9961bd33f160a88f16f5986ecc2d07]: T-test
:results:
|  1 |  1 |
|  2 |  1 |
|  3 |  2 |
|  4 |  3 |
|  5 |  5 |
|  6 |  8 |
|  7 | 13 |
|  8 | 21 |
|  9 | 34 |
| 10 | 55 |
:end:

** Answer
#+NAME: fib-iter-T
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (fib-rec n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib-rec (- n 1))
                 (fib-rec (- n 2))))))
(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (+ (* p p)
                      (* q q))      ; compute p'
                   (+ (* p q)
                      (* q q)
                      (* q p))      ; compute q'
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
#+END_SRC

#+NAME: fib-iter-test
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports results :results output table :colnames yes
(use-srfis '(1))
<<fib-iter-T>>
<<print-table>>
(let* ((l (cdr (iota 11)))
       (fr (map fib-rec l))
       (fi (map fib l)))
  (print-table (cons (list "n" "fib-rec" "fib-iter")
                     (zip l fr fi))
               #:colnames #t))
#+END_SRC

#+RESULTS[30d4713e3cba0984d5cc3e0b400adc130f553a29]: fib-iter-test
:results:
| "n" | "fib-rec" | "fib-iter" |
|-----+-----------+------------|
|   1 |         1 |          1 |
|   2 |         1 |          1 |
|   3 |         2 |          2 |
|   4 |         3 |          3 |
|   5 |         5 |          5 |
|   6 |         8 |          8 |
|   7 |        13 |         13 |
|   8 |        21 |         21 |
|   9 |        34 |         34 |
:end:

* Exercise 1.20
** Text
#+NAME: gcd
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
#+END_SRC
** Question
The process that a procedure generates is of course dependent on the rules used
by the interpreter. As an example, consider the iterative ~gcd~ procedure given
above. Suppose we were to interpret this procedure using normal-order
evaluation, as discussed in 1.1.5. (The normal-order-evaluation rule for ~if~ is
described in Exercise 1.5.) Using the substitution method (for normal order),
illustrate the process generated in evaluating src_scheme{(gcd 206 40)} and indicate the
remainder operations that are actually performed. How many remainder operations
are actually performed in the normal-order evaluation of src_scheme{(gcd 206 40)}? In the
applicative-order evaluation?

** Answer
I struggled to understand this, but the key here is that normal-order evaluation
causes the unevaluated expressions to be duplicated, meaning they get evaluated
multiple times.

*** Applicative order
#+begin_src scheme
call (gcd 206 40)
(if)
(gcd 40 (remainder 206 40))
eval remainder before call
call (gcd 40 6)
(if)
(gcd 6 (remainder 40 6))
eval remainder before call
call (gcd 6 4)
(if)
(gcd 2 (remainder 4 2))
eval remainder before call
call (gcd 2 0)
(if)
;; => 2
#+end_src

#+begin_src scheme
;; call gcd
(gcd 206 40)

;; eval conditional
(if (= 40 0)
    206
    (gcd 40 (remainder 206 40)))

;; recurse
(gcd 40 (remainder 206 40))

; encounter conditional
(if (= (remainder 206 40) 0)
    40
    (gcd (remainder 206 40)
         (remainder 40 (remainder 206 40))))

; evaluate 1 remainder
(if (= 6 0)
    40
    (gcd (remainder 206 40)
         (remainder 40 (remainder 206 40))))

; recurse
(gcd (remainder 206 40)
     (remainder 40 (remainder 206 40)))

; encounter conditional
(if (= (remainder 40 (remainder 206 40)) 0)
    (remainder 206 40)
    (gcd (remainder 40 (remainder 206 40))
         (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))

; eval 2 remainder
(if (= 4 0)
    (remainder 206 40)
    (gcd (remainder 40 (remainder 206 40))
         (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))

; recurse
(gcd (remainder 40 (remainder 206 40))
     (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))

; encounter conditional
(if (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0)
    (remainder 40 (remainder 206 40))
    (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
         (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))

; eval 4 remainders
(if (= 2 0)
    (remainder 40 (remainder 206 40))
    (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
         (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))

; recurse
(gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
     (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))

; encounter conditional
(if (= (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 0)
    (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
    (gcd (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) (remainder a  (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))

; eval 7 remainders
(if (= 0 0)
    (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
    (gcd (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) (remainder a  (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))

; eval 4 remainders
(remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
; => 2
#+end_src

So, in normal-order eval, remainder is called 18 times, while in applicative order
it's called 5 times.

* Exercise 1.21
** Text
#+NAME: find-divisor-txt
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
<<square>>
(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) 
         n)
        ((divides? test-divisor n) 
         test-divisor)
        (else (find-divisor 
               n 
               (+ test-divisor 1)))))

(define (divides? a b)
  (= (remainder b a) 0))
#+END_SRC

** Question
Use the smallest-divisor procedure to find the smallest divisor of each of the
following numbers: 199, 1999, 19999.

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table
<<find-divisor-txt>>
(map smallest-divisor '(199 1999 19999))
#+END_SRC

#+RESULTS[b3eac1941abc1f7ef3cd63a42e5167ad47fcdaf9]:
:results:
| 199 | 1999 | 7 |
:end:

* Exercise 1.22
** Question
Most Lisp implementations include a primitive called runtime that returns an
integer that specifies the amount of time the system has been running (measured,
for example, in microseconds). The following timed-prime-test procedure, when
called with an integer n, prints n and checks to see if n is prime. If n is
prime, the procedure prints three asterisks followed by the amount of time used
in performing the test.
#+NAME: prime-smallest-divisor
#+BEGIN_SRC scheme -n :eval no-export :exports code :results output
<<find-divisor-txt>>
(define (prime? n)
  (= n (smallest-divisor n)))
#+END_SRC
#+NAME: timed-prime-test-txt
#+BEGIN_SRC scheme -n :eval no-export :exports code :results output
<<prime-smallest-divisor>>
(define (timed-prime-test n)
  (newline)
  (display n) ;; Guile compatible \downarrow
  (start-prime-test n (get-internal-run-time)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (begin
        (report-prime (- (get-internal-run-time) 
                       start-time))
        n)
      #f))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))
#+END_SRC

Using this procedure, write a procedure search-for-primes that checks the
primality of consecutive odd integers in a specified range. Use your procedure
to find the three smallest primes larger than 1000; larger than 10,000; larger
than 100,000; larger than 1,000,000. Note the time needed to test each prime.
Since the testing algorithm has order of growth of \(\Theta(\sqrt{n})\), you
should expect that testing for primes around 10,000 should take about
\(\sqrt{10}\) times as long as testing for primes around 1000. Do your timing
data bear this out? How well do the data for 100,000 and 1,000,000 support the
\(\Theta(\sqrt{n})\) prediction? Is your result compatible with the notion that
programs on your machine run in time proportional to the number of steps
required for the computation?

** Answer
*** Part 1
So this question is a little funky, because modern machines are so fast that the
single-run times can seriously vary.

#+NAME: search-primes-basic
#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results output
<<timed-prime-test-txt>>
(define (search-for-primes minimum goal)
  (define m (if (even? minimum)
                (+ minimum 1)
                (minimum)))
  (search-for-primes-iter m '() goal))
(define (search-for-primes-iter n lst goal)
  (if (= goal 0)
      lst
      (let ((x (timed-prime-test n)))
        (if (not (equal? x #f))
            (search-for-primes-iter (+ n 2) (cons x lst) (- goal 1))
            (search-for-primes-iter (+ n 2) lst goal)))))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results output code
<<search-primes-basic>>
(let ((lt1000-1 (search-for-primes 1000 3)))
  (list "Primes > 1000" lt1000-1))
#+END_SRC

#+RESULTS[789a768bd75038c772a9f1e759006de07b1106de]:
#+begin_src scheme
1001
1003
1005
1007
1009 *** 1651
1011
1013 *** 1425
1015
1017
1019 *** 1375
#+end_src

There's proof it works. And here are the answers to the question:

#+BEGIN_SRC scheme -n :eval no-export :tangle no :exports both :results value table :rownames yes
<<search-primes-basic>>
(let ((lt1000-1 (search-for-primes 1000 3))
      (lt10000-1 (search-for-primes 10000 3))
      (lt100000-1 (search-for-primes 100000 3))
      (lt100000000-1 (search-for-primes 1000000 3)))
  (list
   (list "Primes > 1000" (reverse lt1000-1))
   (list "Primes > 10000" (reverse lt10000-1))
   (list "Primes > 100000" (reverse lt100000-1))
   (list "Primes > 100000000" (reverse lt100000000-1))
   ))
#+END_SRC

#+RESULTS[1591ff4ac17eefbd2a343012149c10f419199b20]:
:results:
| Primes > 1000      | (1009 1013 1019)          |
| Primes > 10000     | (10007 10009 10037)       |
| Primes > 100000    | (100003 100019 100043)    |
| Primes > 100000000 | (1000003 1000033 1000037) |
:end:

*** Part 2
Repeatedly re-running, it I see it occasionally jump to twice the time. I'm not
happy with this, so I'm going to refactor to use the ~mattbench2~ utility from
the root of the project folder.

#+NAME: mattbench2
#+begin_src scheme :exports code :eval no-export :results output
(define (mattbench2 f n)
  ;; Executes "f" for n times, and returns how long it took.
  ;; f is a lambda that takes no arguments, a.k.a. a "thunk"
  
  ;; Returns a list with car(last execution results) and cadr(time taken divided by iterations n)

  (define (time-getter) (get-internal-run-time))
  (define start-time (time-getter))
  (define (how-long) (- (time-getter) start-time))

  (define (iter i)
    (f)
    (if (<= i 0)
        (f) ;; return the results of the last function call
        (iter (- i 1))))

  (list (iter n) ;; result of last call of f
        (/ (how-long) (* n 1.0))));; Divide by iterations so changed n has no effect
#+end_src

I'm going to get some more precise times. First, I need a prime searching variant that doesn't bother benchmarking. This will call ~prime?~, which will be bound later since we'll be trying different methods.
#+NAME: search-for-primes-untimed
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (search-for-primes minimum goal)
  (define m (if (even? minimum)
                (+ minimum 1)
                (minimum)))
  (search-for-primes-iter m '() goal))
(define (search-for-primes-iter n lst goal)
  (if (= goal 0)
      lst
      (let ((x (prime? n)))
        (if (not (equal? x #f))
            (search-for-primes-iter (+ n 2) (cons n lst) (- goal 1))
            (search-for-primes-iter (+ n 2) lst goal)))))
#+END_SRC

I can benchmark these functions like so:
#+NAME: smallest-divisor-benchmark
#+BEGIN_SRC scheme -n :noeval :tangle primebench/smd.scheme :exports both :results output table :colnames yes :rownames :yes
<<mattbench2>>
<<prime-smallest-divisor>>
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 1000000)
(define (testit f)
  (list (cadr (mattbench2 (λ() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
#+END_SRC

Here are the results (run externally from Org-Mode):

#+NAME: 1-22-smd
| 5425.223086 | 20772.332491 | 53577.240193 | 121986.712395 |

#+NAME: 1-22-smd-massage
#+BEGIN_SRC scheme :eval no-export :results value table :var data=1-22-smd :exports none :rownames no :colnames no
;(map (lambda(x y) (list x y))
<<transpose-list>>
(use-srfis '(1))
(zip
     '(1000 10000 100000 1000000)
     (car data))
#+END_SRC

#+RESULTS[d7791f01b4f72498262d52b8327962e122163a15]: 1-22-smd-massage
:results:
|    1000 |   5425.223086 |
|   10000 |  20772.332491 |
|  100000 |  53577.240193 |
| 1000000 | 121986.712395 |
:end:

#+begin_src gnuplot :var data=1-22-smd-massage :file 1/fig/1-22-1.png :exports results :eval no-export :rownames no :colnames no
reset
set logscale x
set xlabel 'minimum number'
set xtics rotate by -45
set title 'time to run prime search (x scaled log)'

f(x) = sqrt((x * a) + b)
fit f(x) data using 1:2 via a,b

plot data using 1:2 with linespoints title 'time to find primes', \
     data using 1:(f($1)) with linespoints title \
     sprintf('sqrt(x * %.2f + %.2f)', a, b)
#+end_src

#+RESULTS[27d02bff03e8cb41df0bcd04f4c853b65910088d]:
:results:
[[file:fig/1-22-1.png]]
:end:

The plot for the square root function doesn't quite fit the real one and I'm not
sure where the fault lies. I don't struggle to understand things like "this
algorithm is slower than this other one," but when asked to find or prove the
\(\Theta\) notation I'm pretty clueless;

* Exercise 1.23
** Question
The ~smallest-divisor~ procedure shown at the start of this section does lots of
needless testing: After it checks to see if the number is divisible by 2 there
is no point in checking to see if it is divisible by any larger even numbers.
This suggests that the values used for test-divisor should not be 2, 3, 4, 5, 6,
…, but rather 2, 3, 5, 7, 9, …. To implement this change, define a procedure
~next~ that returns 3 if its input is equal to 2 and otherwise returns its input
plus 2. Modify the smallest-divisor procedure to use src_scheme{(next test-divisor)} instead
of src_scheme{(+ test-divisor 1)}. With ~timed-prime-test~ incorporating this modified version
of ~smallest-divisor~, run the test for each of the 12 primes found in Exercise
1.22. Since this modification halves the number of test steps, you should expect
it to run about twice as fast. Is this expectation confirmed? If not, what is
the observed ratio of the speeds of the two algorithms, and how do you explain
the fact that it is different from 2?
** A Comedy of Error (just the one)
#+NAME: find-divisor-faster
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
<<square>>
(define (smallest-divisor n)
  (find-divisor n 2))

(define (next n)
  (if (= n 2)
      3
      (+ n 1)))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) 
         n)
        ((divides? test-divisor n) 
         test-divisor)
        (else (find-divisor 
               n 
               (next test-divisor)))))

(define (divides? a b)
  (= (remainder b a) 0))
#+END_SRC
#+NAME: smallest-divisor-benchmark
#+BEGIN_SRC scheme -n :noeval :tangle primebench/smdf.scheme :exports code
<<mattbench2>>
<<find-divisor-faster>>
(define (prime? n)
  (= n (smallest-divisor n)))
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 1000000)
(define (testit f)
  (list (cadr (mattbench2 (λ() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
#+END_SRC

#+NAME: 1-22-smdf
| 6456.538118 | 25550.757304 | 66746.041644 | 148505.580638 |


#+NAME: 1-22-smdf-massage
#+BEGIN_SRC scheme :eval no-export :results value table :var smd=1-22-smd smdf=1-22-smdf :exports results :rownames no :colnames no
<<print-table-spaced>>
(use-srfis '(1))
(zip '("min" 1000 10000 100000 1000000)
     (cons "(+1)" (car smd))
     (cons "(next)" (car smdf)))
#+END_SRC

#+RESULTS[c27614e8028f15b657e68959798c723a002730b3]: 1-22-smdf-massage
:results:
|     min |         (+1) |       (next) |
|    1000 |   5507.42497 |   6366.99462 |
|   10000 |  20913.71497 |   24845.9193 |
|  100000 |  53778.74737 |  64756.73693 |
| 1000000 | 122135.60511 | 143869.63561 |
:end:

#+begin_src gnuplot :var data=1-22-smdf-massage :file 1/fig/1-22-2.png :exports results :eval no-export :rownames no :colnames no :cache no
reset
set logscale x
set xlabel 'minimum number'
set xtics rotate by -45
set ylabel 'time'
set title 'time to run prime search (x scaled log)'

plot data using 2:xticlabels(1) with linespoints title '(+ 1)', \
     data using 3:xticlabels(1) with linespoints title '(next)'
#+end_src

#+RESULTS[a092c209836cb659130fe0ad3bff2d3f23674f1b]:
:results:
[[file:fig/1-22-2.png]]
:end:

So it's /slower/ than before. Why?

Oh, that's why.
#+BEGIN_SRC scheme
(define (next n)
  (if (= n 2)
      3
      (+ n 1))) ;; <-- D'oh.
#+END_SRC

** Answer
Ok, let's try that again.

#+NAME: find-divisor-faster-real
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
<<square>>
(define (smallest-divisor n)
  (find-divisor n 2))

(define (next n)
  (if (= n 2)
      3
      (+ n 2)))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) 
         n)
        ((divides? test-divisor n) 
         test-divisor)
        (else (find-divisor 
               n 
               (next test-divisor)))))

(define (divides? a b)
  (= (remainder b a) 0))
#+END_SRC
#+NAME: smallest-divisor-benchmark-real
#+BEGIN_SRC scheme -n :noeval :tangle primebench/smdff.scheme :exports code
<<mattbench2>>
<<find-divisor-faster-real>>
(define (prime? n)
  (= n (smallest-divisor n)))
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 500000)
(define (testit f)
  (list (cadr (mattbench2 (λ() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
#+END_SRC

#+NAME: 1-22-smdff
| 3863.7424 | 13519.209814 | 33520.676384 | 73005.539932 |

#+NAME: 1-22-smdff-massage
#+BEGIN_SRC scheme :eval no-export :results value table :var smd=1-22-smd smdf=1-22-smdf smdff=1-22-smdff :exports results :rownames no :colnames no
<<print-table-spaced>>
(use-srfis '(1))
(zip '("min" "---" 1000 10000 100000 1000000)
     (append '("(+1)" "---") (car smd))
     (append '("(next-broken)" "---") (car smdf))
     (append '("(next-fixed)" "---") (car smdff)))
#+END_SRC

#+RESULTS[3a23c115d64c3bee2872b55f0746322d1d80471e]: 1-22-smdff-massage
:results:
|     min |          (+1) | (next-broken) | (next-fixed) |
|     --- |           --- |           --- |          --- |
|    1000 |   5425.223086 |   6456.538118 |    3863.7424 |
|   10000 |  20772.332491 |  25550.757304 | 13519.209814 |
|  100000 |  53577.240193 |  66746.041644 | 33520.676384 |
| 1000000 | 121986.712395 | 148505.580638 | 73005.539932 |
:end:

#+begin_src gnuplot :var data=1-22-smdff-massage :file 1/fig/1-22-3.png :exports results :noeval :rownames no :colnames no :hlines no :cache no
reset
set key autotitle columnheader
set logscale x
set xlabel 'minimum number'
set xtics rotate by -45
set ylabel 'time'
set title 'time to run prime search (x scaled log)'

plot data using 2:xticlabels(1) with linespoints, \
     data using 3:xticlabels(1) with linespoints, \
     data using 4:xticlabels(1) with linespoints
#+end_src

#+RESULTS:
:results:
[[file:fig/1-22-3.png]]
:end:

I had a lot of trouble getting this one to compile, I have to restart Emacs in
order to get it to render.

Anyways, there's the speedup that was expected. Let's compare the ratios.

Defining a new average that takes arbitrary numbers of arguments:
#+NAME: average-varargs
#+BEGIN_SRC scheme :eval no-export :results silent output :var smd=1-22-smd smdf=1-22-smdf smdff=1-22-smdff :exports code :rownames no :colnames no
(define (average . args)
  (let ((len (length args)))
    (/ (apply + args) len)))
#+END_SRC

Using it for percentage comparisons:
#+BEGIN_SRC scheme :eval no-export :results value table :var smd=1-22-smd smdf=1-22-smdf smdff=1-22-smdff :exports both :rownames no :colnames no
<<average-varargs>>
(list (cons "% speedup for broken (next)"
            (cons (format #f "~2$%"
                          (apply average
                                 (map (λ (x y) (* 100 (/ x y)))
                                      (car smd) (car smdf))))
                  #nil))
      (cons "% speedup for real (next)"
            (cons (format #f "~2$%"
                          (apply average
                                 (map (λ (x y) (* 100 (/ x y)))
                                      (car smd) (car smdff))))
                  #nil)))
#+END_SRC

#+RESULTS[6c5b471c24bb1e0fa43ce89ab354a29586b8dc54]:
:results:
| % speedup for broken (next) |  81.93% |
| % speedup for real (next)   | 155.25% |
:end:

Since this changed algorithm cuts out almost half of the steps, you might expect
something more like a 200% speedup. Let's try optimizing it further. Two observations:

1. The condition src_scheme{(divides? 2 n)} only needs to be run once at the
   start of the program.
2. Because it only needs to be run once, it doesn't need to be a separate
   function at all.

#+NAME: find-divisor-faster-real2
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
<<square>>
(define (smallest-divisor n)
  (if (divides? 2 n)                  ;; check for division by 2
      2
      (find-divisor n 3)))            ;; start find-divisor at 3

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) 
         n)
        ((divides? test-divisor n) 
         test-divisor)
        (else (find-divisor 
               n 
               (+ 2 test-divisor))))) ;; just increase by 2

(define (divides? a b)
  (= (remainder b a) 0))
#+END_SRC
#+NAME: smallest-divisor-benchmark-real2
#+BEGIN_SRC scheme -n :noeval :tangle primebench/smdff2.scheme :exports code
<<mattbench2>>
<<find-divisor-faster-real2>>
(define (prime? n)
  (= n (smallest-divisor n)))
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 500000)
(define (testit f)
  (list (cadr (mattbench2 (λ() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
#+END_SRC


#+NAME: 1-22-smdff2
| 3151.259574 | 11245.20428 | 27803.067944 | 61997.275154 |

#+NAME: 1-22-smdff2-massage
#+BEGIN_SRC scheme :eval no-export :results value table :var smd=1-22-smd smdf=1-22-smdf smdff=1-22-smdff smdff2=1-22-smdff2 :exports results :rownames no :colnames no
<<print-table-spaced>>
(use-srfis '(1))
(zip '("min" "---" 1000 10000 100000 1000000)
     (append '("(+1)" "---") (car smd))
     (append '("(next-broken)" "---") (car smdf))
     (append '("(next-fixed)" "---") (car smdff))
     (append '("integrated" "---") (car smdff2)))
#+END_SRC

#+RESULTS[39aed0154d20c6f0dee74c868a7613701ebb1dea]: 1-22-smdff2-massage
:results:
|     min |          (+1) | (next-broken) | (next-fixed) |   integrated |
|     --- |           --- |           --- |          --- |          --- |
|    1000 |   5425.223086 |   6456.538118 |    3863.7424 |  3151.259574 |
|   10000 |  20772.332491 |  25550.757304 | 13519.209814 |  11245.20428 |
|  100000 |  53577.240193 |  66746.041644 | 33520.676384 | 27803.067944 |
| 1000000 | 121986.712395 | 148505.580638 | 73005.539932 | 61997.275154 |
:end:

#+begin_src gnuplot :var data=1-22-smdff2-massage :file 1/fig/1-22-4.png :exports results :rownames no :colnames no :hlines no :cache no
reset
set key autotitle columnheader
set logscale x
set xlabel 'minimum number'
set xtics rotate by -45
set ylabel 'time'
set title 'time to run prime search (x scaled log)'

plot data using 2:xticlabels(1) with linespoints, \
     data using 3:xticlabels(1) with linespoints, \
     data using 4:xticlabels(1) with linespoints, \
     data using 5:xticlabels(1) with linespoints
#+end_src

#+RESULTS:
:results:
file:fig/1-22-4.png
:end:

#+BEGIN_SRC scheme :eval no-export :results value table :var smd=1-22-smd smdf=1-22-smdf smdff=1-22-smdff smdff2=1-22-smdff2 :exports results :rownames no :colnames no
<<average-varargs>>
(define (print-percentage name lista listb)
  (list (format #f "% speedup for ~a" name)
        (format #f "~2$%"
                (apply average
                       (map (λ (x y) (* 100 (/ x y)))
                            lista listb)))))
(list (print-percentage "broken (next)" (car smd) (car smdf))
      (print-percentage "real (next)" (car smd) (car smdff))
      (print-percentage "optimized" (car smd) (car smdff2)))
#+END_SRC

#+RESULTS[2a8c88e516dcf2998063353d1be32f3b9838c7de]:
:results:
| % speedup for broken (next) |  81.93% |
| % speedup for real (next)   | 155.25% |
| % speedup for optimized     | 186.59% |
:end:

* Exercise 1.24
** Text
#+NAME: expmod
#+BEGIN_SRC scheme :eval no-export :results output silent :exports code
<<square>>
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder 
          (square (expmod base (/ exp 2) m))
          m))
        (else
         (remainder 
          (* base (expmod base (- exp 1) m))
          m))))
#+END_SRC
#+NAME: fermat-test
#+BEGIN_SRC scheme :eval no-export :results output silent :exports code
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))
#+END_SRC
#+NAME: fast-prime
#+BEGIN_SRC scheme :eval no-export :results output silent :exports code
(define (fast-prime? n times)
  (cond ((= times 0) #t)
        ((fermat-test n) 
         (fast-prime? n (- times 1)))
        (else #f)))
#+END_SRC
** Question
Modify the ~timed-prime-test~ procedure of Exercise 1.22 to use ~fast-prime?~ (the
Fermat method), and test each of the 12 primes you found in that exercise. Since
the Fermat test has \(\Theta(\text{log}n)\) growth, how would you expect the
time to test primes near 1,000,000 to compare with the time needed to test
primes near 1000? Do your data bear this out? Can you explain any discrepancy
you find?

** Answer
#+NAME: fermat-bench
#+BEGIN_SRC scheme -n :noeval :tangle primebench/fermat.scheme :exports code
<<mattbench2>>
<<expmod>>
<<fermat-test>>
<<fast-prime>>
(define fermat-iterations 2)
(define (prime? n)
  (fast-prime? n fermat-iterations))
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 500000)
(define (testit f)
  (list (cadr (mattbench2 (λ() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
#+END_SRC

#+NAME: 1-24-fermat
| 11175.799722 | 23518.62116 | 32150.745642 | 32679.766448 |

#+NAME: 1-24-massage
#+BEGIN_SRC scheme :eval no-export :results value table :var smd=1-22-smd smdff2=1-22-smdff2 fermat=1-24-fermat :exports results :rownames no :colnames no
<<print-table-spaced>>
(use-srfis '(1))
(zip '("min" "---" 1000 10000 100000 1000000)
     (append '("(+1)" "---") (car smd))
     (append '("integrated" "---") (car smdff2))
     (append '("fermat (2 guesses)" "---") (car fermat)))
#+END_SRC

#+RESULTS[c9241299552f4a1e84ecbb973fb1d1f9cca04fca]: 1-24-massage
:results:
|     min |          (+1) |   integrated | fermat (2 guesses) |
|     --- |           --- |          --- |                --- |
|    1000 |   5425.223086 |  3151.259574 |       11175.799722 |
|   10000 |  20772.332491 |  11245.20428 |        23518.62116 |
|  100000 |  53577.240193 | 27803.067944 |       32150.745642 |
| 1000000 | 121986.712395 | 61997.275154 |       32679.766448 |
:end:

#+begin_src gnuplot :var data=1-24-massage :file 1/fig/1-24-1.png :exports results :rownames no :colnames no :hlines no :cache no
reset
set key autotitle columnheader
set logscale x
set xlabel 'minimum number'
set xtics rotate by -45
set ylabel 'time'
set title 'time to run prime search (x scaled log)'

plot data using 2:xticlabels(1) with linespoints, \
     data using 3:xticlabels(1) with linespoints, \
     data using 4:xticlabels(1) with linespoints, \
     data using 5:xticlabels(1) with linespoints
#+end_src

#+RESULTS:
:results:
file:fig/1-24-1.png
:end:

It definitely looks to be advancing much slower than the other methods. I'd like
to see more of the function.

#+NAME: smallest-divisor-benchmark-real3
#+BEGIN_SRC scheme -n :noeval :tangle primebench/more.scheme :exports code
<<mattbench2>>
<<find-divisor-faster-real>>
(define (prime? n)
  (= n (smallest-divisor n)))
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 100000)
(define (testit f)
  (list (cadr (mattbench2 (λ() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
#+END_SRC

#+NAME: fermat-bench2
#+BEGIN_SRC scheme -n :noeval :tangle primebench/more.scheme :exports code
<<mattbench2>>
<<expmod>>
<<fermat-test>>
<<fast-prime>>
(define fermat-iterations 100)
(define (prime? n)
  (fast-prime? n fermat-iterations))
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 100000)
(define (testit f)
  (list (cadr (mattbench2 (λ() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 10000000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 100000000000 3)) benchmark-iterations))
        (cadr (mattbench2 (λ() (f 1000000000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
#+END_SRC

#+NAME: smd-vs-fermat
| 3802.45146 | 13397.91871 | 32948.31241 | 73237.64777 | 299326.76182 | 678512.75719 | 2064911.33345 | 7065717.58395 | 20198370.27007 | 60956807.83034 |
| 237945.8945 | 319761.90842 | 391573.47557 | 448501.96232 | 614009.08547 | 661205.34772 | 700058.30723 | 2852221.29076 | 3717690.96246 | 3995948.05596 |


#+NAME: 1-24-massage2
#+BEGIN_SRC scheme :eval no-export :results value :var table=smd-vs-fermat :exports results :rownames no :colnames no
<<print-table-spaced>>
(use-srfis '(1))
(zip '("min" "---" 1000 10000 100000 1000000 10000000 100000000 1000000000 10000000000 100000000000 1000000000000)
     (append '("integrated" "---") (car table))
     (append '("fermat (100 guesses)" "---") (cadr table)))
#+END_SRC

#+RESULTS[7524e2c0a297987b6bf024a6164e93e6b71ca7f2]: 1-24-massage2
:results:
|           min |     integrated | fermat (100 guesses) |
|           --- |            --- |                  --- |
|          1000 |     3802.45146 |          237945.8945 |
|         10000 |    13397.91871 |         319761.90842 |
|        100000 |    32948.31241 |         391573.47557 |
|       1000000 |    73237.64777 |         448501.96232 |
|      10000000 |   299326.76182 |         614009.08547 |
|     100000000 |   678512.75719 |         661205.34772 |
|    1000000000 |  2064911.33345 |         700058.30723 |
|   10000000000 |  7065717.58395 |        2852221.29076 |
|  100000000000 | 20198370.27007 |        3717690.96246 |
| 1000000000000 | 60956807.83034 |        3995948.05596 |
:end:

#+begin_src gnuplot :var data=1-24-massage2 :file 1/fig/1-24-2.png :exports results :rownames no :colnames no :hlines no :cache no :eval no-export
reset
set key autotitle columnheader
set logscale xy
set xlabel 'minimum number'
set xtics rotate by -45
set ylabel 'time'
set title 'time to run prime search (x\&y scaled log)'

plot data using 2:xticlabels(1) with linespoints, \
     data using 3:xticlabels(1) with linespoints
#+end_src

#+RESULTS:
:results:
file:fig/1-24-2.png
:end:

For the life of me I have no idea what that bump is. Maybe it needs more
aggressive bignum processing there?

* Exercise 1.25
** Question
Alyssa P. Hacker complains that we went to a lot of extra work in writing
~expmod~. After all, she says, since we already know how to compute
exponentials, we could have simply written

#+BEGIN_SRC scheme -n :tangle no
(define (expmod base exp m)
  (remainder (fast-expt base exp) m))
#+END_SRC

Is she correct? Would this procedure serve as well for our fast prime tester?
Explain.

** Answer
In Alyssa's version of ~expmod~, the result of the ~fast-expt~ operation is
/extremely/ large. For example, in the process of checking for divisors of
1,001, the number 455 will be tried. src_scheme{(expt 455 1001)} produces an
integer 2,661 digits long. This is just one of the thousands of exponentiations
that ~smallest-divisor~ will perform. It's best to avoid this, so we use to our
advantage the fact that we only need to know the remainder of the
exponentiations. ~expmod~ breaks down the exponentiation into smaller steps and
performs ~remainder~ after every step, significantly reducing the memory
requirements.

As an example, let's trace (some of) the execution of src_scheme{(expmod 455 1001 1001)}:

#+BEGIN_SRC scheme
(expmod 455 1001 1001)
>  (even? 1001)
>  #f
>  (expmod 455 1000 1001)
>  >  (even? 1000)
>  >  #t
>  >  (expmod 455 500 1001)
>  >  >  (even? 500)
>  >  >  #t
;; ...
>  >  >  x11 (expmod 455 2 1001)
>  >  >  x11 >  (even? 2)
>  >  >  x11 >  #t
>  >  >  x11 >  (expmod 455 1 1001)
>  >  >  x11 >  >  (even? 1)
>  >  >  x11 >  >  #f
>  >  >  x11 >  >  (expmod 455 0 1001)
>  >  >  x11 >  >  1
>  >  >  x11 >  455
>  >  >  x11 >  (square 455)
>  >  >  x11 >  207025
>  >  >  x11 819
;; ...
>  >  >  (square 364)
>  >  >  132496
>  >  364
>  >  (square 364)
>  >  132496
>  364
455
#+END_SRC

You can see that the numbers remain quite manageable throughout this process. So
taking these extra steps actually leads to an algorithm that performs better.

* Exercise 1.26
** Question
Louis Reasoner is having great difficulty doing Exercise 1.24. His ~fast-prime?~ test seems to run more slowly than his ~prime?~ test. Louis calls his friend Eva Lu Ator over to help. When they examine Louis’s code, they find that he has rewritten the ~expmod~ procedure to use an explicit multiplication, rather than calling ~square~:

#+begin_src scheme -n
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder 
          (* (expmod base (/ exp 2) m) ;; <== hmm.
             (expmod base (/ exp 2) m))
          m))
        (else
         (remainder 
          (* base 
             (expmod base (- exp 1) m))
          m))))
#+end_src

“I don’t see what difference that could make,” says Louis. “I do.” says Eva. “By
writing the procedure like that, you have transformed the \(\Theta(\log n)\)
process into a \(\Theta(n)\) process.” Explain.

** Answer
Making the same function call twice isn't the same as using a variable twice --
Louis' version doubles the work, having two processes solving the exact same
problem. Since the number of processes used increases exponentially, this turns
\(\log n\) into \(n\).

* Exercise 1.27
** Question
Demonstrate that the Carmichael numbers listed in Footnote 1.47 really do fool
the Fermat test. That is, write a procedure that takes an integer \(n\) and
tests whether \(a^n\) is congruent to \(a\) modulo \(n\) for every \(a < n\),
and try your procedure on the given Carmichael numbers.
#+NAME: carmichael
| 561 | 1105 | 1729 | 2465 | 2821 | 6601 |
** Answer
#+NAME: car-test
#+begin_src scheme -n :results silent :exports code :eval no-export
<<expmod>>
(define (car-test n)
  (define (check a)
    (= (remainder (expt a n) n)
       (remainder (modulo a n) n)))
  (every check
           (cddr (iota n))))
#+end_src

#+NAME: car-test-check
#+BEGIN_SRC scheme noeval :exports code :eval no-export
<<car-test>>
(list (car-test 12) ; <== false (not prime)
      (car-test 1009);<== true  (real prime)
      (car-test 561));<== true  (not prime,
                     ;      Carmichael number)
#+END_SRC

* Exercise 1.28
** Question
One variant of the Fermat test that cannot be fooled is called the Miller-Rabin
test (Miller 1976; Rabin 1980). This starts from an alternate form of Fermat’s
Little Theorem, which states that if \( n \) is a prime number and \( a \) is
any positive integer less than \( n \), then \( a \) raised to the \( (n−1) \)
-st power is congruent to 1 modulo \( n \). To test the primality of a number \(
n \) by the Miller-Rabin test, we pick a random number \( a<n \) and raise \( a
\) to the \( (n−1) \) -st power modulo \( n \) using the ~expmod~ procedure.
However, whenever we perform the squaring step in ~expmod~, we check to see if
we have discovered a “nontrivial square root of 1 modulo \( n \),” that is, a
number not equal to 1 or \( n−1 \) whose square is equal to 1 modulo \( n \). It
is possible to prove that if such a nontrivial square root of 1 exists, then \(
n \) is not prime. It is also possible to prove that if \( n \) is an odd number
that is not prime, then, for at least half the numbers \( a<n \), computing \(
an−1 \) in this way will reveal a nontrivial square root of 1 modulo \( n \).
(This is why the Miller-Rabin test cannot be fooled.) Modify the ~expmod~
procedure to signal if it discovers a nontrivial square root of 1, and use this
to implement the Miller-Rabin test with a procedure analogous to fermat-test.
Check your procedure by testing various known primes and non-primes. Hint: One
convenient way to make ~expmod~ signal is to have it return 0.
** Analysis
For the sake of verifying this, I want to get a bigger list of primes and
Carmichael numbers to verify against. I'll save them using Guile's built in
read/write functions that save Lisp lists to text:
#+NAME: findsomeprimes
#+BEGIN_SRC scheme :eval no-export :results output :exports code :tangle Ex28/findsomeprimes.scheme
<<find-divisor-faster-real>>
(define (prime? n)
  (= n (smallest-divisor n)))
(call-with-output-file "Data/primes-1k_to_1mil.txt" (λ(port)
  (write (filter prime? (iota (- 1000000 1000) 1000))
         port)))
#+END_SRC

#+RESULTS[0f3510a537b7f8589cc3db849395109db85e1bad]: findsomeprimes
:results:
:end:

#+NAME: fermat-prime?
#+BEGIN_SRC scheme :eval no-export :results output silent :exports code
;; fermat prime test but checks *every* value from 2 to n-1
(define (fermat-prime? n)
  (define (iter a)
    (if (= a n)
        #f
        (if (= (expmod a n n) a)
            #t
            (iter (+ 1 a)))))
  (iter 2))
#+END_SRC

#+NAME: findcars
#+BEGIN_SRC scheme :eval no-export :results output silent :exports code :tangle Ex28/findcars.scheme
(use-srfis '(1))
<<expmod>>
<<fermat-prime?>>
<<find-divisor-faster-real>>
(define (prime? n)
  (= n (smallest-divisor n)))
(call-with-output-file "Data/carmichael-verification.txt" (λ(port)
     (write (filter
             (λ(x) (and (fermat-prime? x)
                        (not (prime? x))))
             (iota (- 1000000 1000) 1000))
            port)))
#+END_SRC

#+RESULTS[f22e6e43bbdef62eb6751b13eea84f5371bf8e89]: findcars
:results:
:end:

This will be useful in various future functions:
#+NAME: get-lists-of-primes
#+BEGIN_SRC scheme :eval no-export :results output silent :exports code :cache no
(define list-of-primes (call-with-input-file "Data/primes-1k_to_1mil.txt" read))
(define list-of-carmichaels (call-with-input-file "Data/carmichael.txt" read))
#+END_SRC

#+BEGIN_SRC scheme :eval no-export :results output :exports both :cache no
(use-srfis '(1))
<<expmod>>
<<fermat-prime?>>
<<find-divisor-faster-real>>
(define (prime? n)
  (= n (smallest-divisor n)))
<<get-lists-of-primes>>
(define prime-is-working
  (and (and-map prime? list-of-primes)
       (not (and-map prime? list-of-carmichaels))))
(format #t "(prime?) is working: ~a~%"
        (if prime-is-working
            "Yes"
            "No"))
(define fermat-is-vulnerable
  (and (and-map fermat-prime? list-of-primes)
       (and-map fermat-prime? list-of-carmichaels)))
(format #t "(fermat-prime?) is vulnerable: ~a~%"
        (if fermat-is-vulnerable
            "Yes"
            "No"))
#+END_SRC

#+RESULTS:
:results:
(prime?) is working: Yes
(fermat-prime?) is vulnerable: Yes
:end:

** Answer
#+NAME: expmod-mr
#+BEGIN_SRC scheme -n :eval no-export :results output silent :exports code
<<square>>
(define (expmod-mr base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (let ((sqr
                (square (expmod-mr base (/ exp 2) m))))
           (if (= 1 (modulo sqr m))
               0
               (remainder sqr m))))
        (else
         (remainder 
          (* base (expmod-mr base (- exp 1) m))
          m))))
#+END_SRC
#+NAME: mr-test
#+BEGIN_SRC scheme :eval no-export :results output silent :exports code
(define (mr-test n)
  (define (try-it a)
    (let ((it (expmod-mr a n n)))
      (or (= it a)
          (= it 0))))
  (try-it (+ 1 (random (- n 1)))))
#+END_SRC
#+NAME: mr-prime
#+BEGIN_SRC scheme :eval no-export :results output silent :exports code
(define (mr-prime? n times)
  (cond ((= times 0) #t)
        ((mr-test n) 
         (mr-prime? n (- times 1)))
        (else #f)))
#+END_SRC

#+NAME: mr-verification
#+BEGIN_SRC scheme :eval no-export :results value :exports both :tangle Ex28/mr_check.scheme
<<expmod-mr>>
<<mr-test>>
<<mr-prime>>
(define mr-times 100)
<<get-lists-of-primes>>
(format #t "      mr detects primes: ~a~%mr false-positives Carmichaels: ~a~%"
        (and-map (λ(x)(mr-prime? x mr-times)) list-of-primes)
      (and-map (λ(x)(mr-prime? x mr-times)) list-of-carmichaels))
#+END_SRC

#+RESULTS[949daa71bbf35095f8025130b9fb179b5308e7fa]: mr-verification
#+BEGIN_SRC 
      mr detects primes: #t
mr false-positives Carmichaels: #t
#+END_SRC

Shoot. And I thought I did a very literal interpretation of what the book asked.

Ah, I see the problem. I need to keep track of what the pre-squaring number was
and use that to determine whether the square is valid or not.

#+NAME: expmod-mr2
#+BEGIN_SRC scheme -n :eval no-export :results output silent :exports code
<<square>>
(define (expmod-mr base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         ;; Keep result and remainder seperate
         (let* ((result (expmod-mr base (/ exp 2) m))
                (rem (remainder (square result) m)))
           (if (and (not (= result 1))
                    (not (= result (- m 1)))
                    (= 1 rem))
               0 ;; non-trivial sqrt mod 1 is found
               rem)))
        (else
         (remainder 
          (* base (expmod-mr base (- exp 1) m))
          m))))
#+END_SRC
#+NAME: mr-verification2
#+BEGIN_SRC scheme :noeval :exports none :tangle Ex28/mr_check2.scheme
<<expmod-mr2>>
<<mr-test>>
<<mr-prime>>
(define mr-times 100)
<<get-lists-of-primes>>
(format #t "      mr detects primes: ~a~%mr false-positives Carmichaels: ~a~%"
        (and-map (λ(x)(mr-prime? x mr-times)) list-of-primes)
      (and-map (λ(x)(mr-prime? x mr-times)) list-of-carmichaels))
#+END_SRC

Unfortunately this one has the same problem. What's the issue?

Sadly, there's a massive issue in ~mr-test~.
#+BEGIN_SRC scheme +n :eval no-export :results output silent :exports code
(define (mr-test n)
  (define (try-it a)
    (let ((it (expmod-mr a n n))) ;; Should be "a (- n 1) n"
      (or (= it a)    ;; Should be (= it 1)
          (= it 0)))) ;; Two strikes, you're out
  (try-it (+ 1 (random (- n 1)))))
#+END_SRC

One more time.
#+NAME: mr-test2
#+BEGIN_SRC scheme +n :eval no-export :results output silent :exports code
(define (mr-test n)
  (define (try-it a)
    (= 1 (expmod-mr a (- n 1) n)))
  (try-it (+ 1 (random (- n 1)))))
#+END_SRC

#+NAME: mr-verification2
#+BEGIN_SRC scheme -n :exports both :results output raw :tangle Ex28/mr_check3.scheme
<<expmod-mr2>>
<<mr-test2>>
<<mr-prime>>
(define mr-times 100)
<<get-lists-of-primes>>
(format #t "      mr detects primes: ~a~%mr false-positives Carmichaels: ~a~%"
        (and-map (λ(x)(mr-prime? x mr-times)) list-of-primes)
      (and-map (λ(x)(mr-prime? x mr-times)) list-of-carmichaels))
#+END_SRC

#+BEGIN_SRC
     mr detects primes: #t
mr false-positives Carmichaels: #f
#+END_SRC

* Exercise 1.29
** Text
#+NAME: sum
#+BEGIN_SRC scheme -n :eval no-export :results output silent :exports code
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
#+END_SRC
#+NAME: integral
#+BEGIN_SRC scheme -n :eval no-export :results output silent :exports code
(define (integral f a b dx)
  (define (add-dx x)
    (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b)
     dx))
#+END_SRC
** Question
Simpson's Rule is a more accurate method of numerical integration than the
method illustrated above. Using Simpson's Rule, the integral of a function \(f\)
between \(a\) and \(b\) is approximated as

\[
{h\over 3}(y_0 + 4y_1 + 2y_2 + 4y_3 + 2y_4 + \dots + 2y_{n-2} + 4y_{n-1} + y_n)
\]

where \(h = (b - a) / n\), for some even integer \(n\), and \(y_k = f(a + kh)\).
(Increasing \(n\) increases the accuracy of the approximation.) Define a
procedure that takes as arguments \(f\), \(a\), \(b\), and \(n\) and returns the
value of the integral, computed using Simpson's Rule. Use your procedure to
integrate ~cube~ between 0 and 1 (with \(n = 100\) and \(n = 1000\)), and
compare the results to those of the ~integral~ procedure shown above.
** Answer
#+NAME: int-simp
#+BEGIN_SRC scheme -n :eval no-export :results output silent :exports code
(define (int-simp f a b n)
  (define h
    (/ (- b a)
     n))
  (define (gety k)
    (f (+ a (* k h))))
  (define (series-y sum k) ;; start with sum = y_0
    (cond ((= k n) (+ sum (gety k)));; and k = 1
          ((even? k) (series-y
                      (+ sum (* 2 (gety k)))
                      (+ 1 k)))
          (else (series-y
                 (+ sum (* 4 (gety k)))
                 (+ 1 k)))))
  (define sum-of-series (series-y (gety a) 1)) ;; (f a) = y_0
  (* (/ h 3) sum-of-series))
#+END_SRC

Let's compare these at equal levels of computational difficulty.
#+BEGIN_SRC scheme -n :noeval :exports both :results output table :tangle Ex29-bench.scheme
<<mattbench2>>
<<print-table>>
(define (cube x)
  (* x x x))
<<sum>>
<<integral>>
<<int-simp>>

(define iterations 100000) ;; benchmark iterations
(define (run-test1)
  (integral cube 0.0 1.0 0.0008))
(define (run-test2)
  (int-simp cube 0.0 1.0 1000.0))
(print-table (list (list "integral dx:0.0008" "int-simp i:1000")
                   (list (run-test1) (run-test2))
                   (list (cadr (mattbench2 run-test1 iterations))
                         (cadr (mattbench2 run-test2 iterations))))
             #:colnames #t)
#+END_SRC

#+RESULTS[f1ab42d01728399d2e9c3b9f8c996a3766a58da4]:
:results:
|  integral dx:0.0008 |     int-simp i:1000 |
|---------------------+---------------------|
| 0.24999992000001311 | 0.25000000000000006 |
|         321816.2755 |         330405.8918 |
:end:

So, more accurate for roughly the same effort or less.

* Exercise 1.30
** Question
The ~sum~ procedure above generates a linear recursion. The procedure can be
rewritten so that the sum is performed iteratively. Show how to do this by
filling in the missing expressions in the following definition:

** Answer
#+NAME: sum-iter
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (sum-iter term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ result (term a)))))
  (iter a 0))
#+END_SRC

Let's check the stats!
#+NAME: sum-bench
#+BEGIN_SRC scheme -n :noeval :exports results :results output :tangle Ex30-bench.scheme
<<print-table>>
<<mattbench2>>
<<sum>>
<<sum-iter>>
(define iterations 1000000)
(define (test1)
  (sum + 1 1+ 1000))
(define (test2)
  (sum-iter + 1 1+ 1000))
(print-table (list
              (list "recursive" "iterative")
              (list (cadr (mattbench2 test1 iterations))
                   (cadr (mattbench2 test2 iterations))))
             #:colnames #t)
#+END_SRC

#+RESULTS:
|    recursive |    iterative |
|--------------+--------------|
| 30051.080005 | 19568.685587 |

* Exercise 1.31
** Question A.1
The ~sum~ procedure is only the simplest of a vast number of similar
abstractions that can be captured as higher-order procedures. Write an analogous
procedure called ~product~ that returns the product of the values of a function
at points over a given range.
** Answer A.1
#+NAME: product-iter
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (product-iter term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (* result (term a)))))
  (iter a 1)) ;; start at 1 so it's not always 0
#+END_SRC
** Question A.2
Show how to define ~factorial~ in
terms of ~product~.
** Answer A.2
I was briefly stumped because ~product~ only counts upward. Then I realized
that's just how it's presented and it can go either direction, since addition
and multiplication are commutative. I look forward to building up a more
intuitive sense of numbers.
#+NAME: factorial-product
#+BEGIN_SRC scheme -n :eval no-export :exports both :results output
<<product-iter>>
(define (identity x)
  x)
(define (inc x)
  (1+ x))

(define (factorial n)
  (product-iter identity 1 inc n))

(display (factorial 7))
#+END_SRC

#+RESULTS[62b530c1156728394dbfd7f2df3aa06defdbe68c]: product-iter
:results:
5040
:end:

** Question A.3
Also use ~product~ to compute approximations to
\(\pi\) using the formula

\[
{\pi\over 4} = {2\cdot 4\cdot 4\cdot 6\cdot 6\cdot 8\cdots\over
		   3\cdot 3\cdot 5\cdot 5\cdot 7\cdot 7\cdots}
\]

** Answer A.3
Once this equation is encoded, you just need to multiply it by two to get \(\pi\).

Fun fact: the formula is slightly wrong, it should start the series with \({1 \over 2}\).
#+NAME: pi-product
#+BEGIN_SRC scheme -n :eval no-export :exports both :results output
<<product-iter>>
(define (pi-product n)
  (define (div x)
    (let ((x1 (- x 1))
          (x2 (+ x 1)))
      (* (/ x x1) (/ x x2))))
  (* 2.0 (product-iter div 2 (lambda (z) (+ z 2)) n)))

(display (pi-product 100000))
#+END_SRC

#+RESULTS[ec9a51379631fed566dd2d3883f600356c3f0dd8]: pi-product
:results:
3.1415769458228726
:end:

** Question B
If your product procedure generates a recursive process, write one that
generates an iterative process. If it generates an iterative process, write one
that generates a recursive process.

** Answer B
#+NAME: product-rec
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (product-rec term a next b)
  (if (> a b)
      1
      (* (term a)
         (product-rec term (next a) next b))))
#+END_SRC

#+NAME: product-bench
#+BEGIN_SRC scheme -n :exports both :tangle Ex31-bench.scheme
<<mattbench2>>
<<print-table>>
<<product-iter>>
(define (pi-product n)
  (define (div x)
    (let ((x1 (- x 1))
          (x2 (+ x 1)))
      (* (/ x x1) (/ x x2))))
  (* 2.0 (product-iter div 2 (lambda (z) (+ z 2)) n)))
<<product-rec>>
(define (pi-product-rec n)
  (define (div x)
    (let ((x1 (- x 1))
          (x2 (+ x 1)))
      (* (/ x x1) (/ x x2))))
  (* 2.0 (product-rec div 2 (lambda (z) (+ z 2)) n)))

(define iterations 50000)
(print-table
 (list (list "iterative" "recursive")
       (list (cadr (mattbench2 (λ()(pi-product 1000)) iterations))
             (cadr (mattbench2 (λ()(pi-product-rec 1000)) iterations))))
 #:colnames #t)
#+END_SRC

#+RESULTS:
|    iterative |    recursive |
|--------------+--------------|
| 1267118.0538 | 3067085.5323 |

* Exercise 1.32
** Question A
Show that ~sum~ and ~product~ are both special cases of a still more general
notion called ~accumulate~ that combines a collection of terms, using some
general accumulation function:

#+BEGIN_SRC scheme
(accumulate combiner null-value term a next b)
#+END_SRC

~accumulate~ takes as arguments the same term and range specifications as ~sum~
and ~product~, together with a ~combiner~ procedure (of two arguments) that
specifies how the current term is to be combined with the accumulation of the
preceding terms and a ~null-value~ that specifies what base value to use when
the terms run out. Write ~accumulate~ and show how ~sum~ and ~product~ can both
be defined as simple calls to ~accumulate~.

** Answer A
When I first did this question, I struggled a lot before realizing ~accumulate~
was much closer to the exact definitions of sum/product than I thought.
#+NAME: accumulate-iter
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (accumulate-iter combiner null-value term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a)
              (combiner result (term a)))))
  (iter a null-value))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export
<<accumulate-iter>>

;; here you can see definitions in terms of accumulate
(define (sum term a next b)
  (accumulate-iter + 0 term a next b))
(define (product term a next b)
  (accumulate-iter * 1 term a next b))

(define (identity x)
  x)
(define (inc x)
  (1+ x))

;; accumulate in action
(define (factorial n)
  (accumulate-iter * 1 identity 1 inc n))

(display (factorial 7))
#+END_SRC

#+RESULTS[4887ddb9da2fc846473c03144fb7dfe4f69aa8f1]:
:results:
5040
:end:

** Question B
If your ~accumulate~ procedure generates a recursive process, write one
that generates an iterative process.  If it generates an iterative process,
write one that generates a recursive process.

** Answer B
#+NAME: accumulate-rec
#+BEGIN_SRC scheme -n :eval no-export :exports code :results silent
(define (accumulate-rec combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a)
         (accumulate-rec combiner null-value
                         term (next a) next b))))
#+END_SRC

* Question 1.33
** Question A
#+INDEX: filter
You can obtain an even more general version of ~accumulate~ by introducing the
notion of a filter on the terms to be combined. That is, combine only those
terms derived from values in the range that satisfy a specified condition. The
resulting ~filtered-accumulate~ abstraction takes the same arguments as
accumulate, together with an additional predicate of one argument that specifies
the filter. Write ~filtered-accumulate~ as a procedure. 

** Question B
Show how to express the following using ~filtered-accumulate~:

#+NAME: filtered-accumulate-iter
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (filtered-accumulate-iter
           predicate? combiner null-value
           term a next b)
  (define (iter a result)
    (cond ((> a b) result)
          ((predicate? a)
           (iter (next a)
                 (combiner result (term a))))
          (else (iter (next a)
                      result))))
  (iter a null-value))
#+END_SRC

*** A
Find the sum of the squares of the prime numbers in the interval \(a\) to \(b\)
(assuming that you have a ~prime?~ predicate already written)

#+BEGIN_SRC scheme -n :eval no-export :results output :results both
(load "mattcheck.scm")
(define (square x)
  (* x x))
<<filtered-accumulate-iter>>
<<expmod-mr2>>
<<mr-test2>>
<<mr-prime>>
(define mr-times 100)
(define (prime? x)
  (mr-prime? x mr-times))
(define (prime-sum a b)
  (filtered-accumulate-iter prime? + 0
                            square a 1+ b))

(mattcheck-equal "1 prime correct"
                 (prime-sum 1008 1010)
                 (square 1009)) ;; 1009
(mattcheck-equal "many primes correct"
                 (prime-sum 1000 2001)
                 (apply +
                        (map square
                             (filter prime? (iota (- 2001 1000)
                                                  1000)))))
#+END_SRC

#+RESULTS[9d2efd935ed9abfe7480e0fd9117c25f7db9eb02]:
:results:

SUCCEED at 1 prime correct

SUCCEED at many primes correct
:end:

*** B
Find the product of all the positive integers less than \(n\) that are
relatively prime to \(n\) (i.e., all positive integers \(i < n\) such that
\(\textsc{gcd}(i, n) = 1\).

#+BEGIN_SRC scheme -n :eval no-export :results output :results both
(load "mattcheck.scm")
(define (square x)
  (* x x))
(define (id x) x)
<<filtered-accumulate-iter>>
<<gcd>>
(define (relative-prime? x y)
  (= 1 (gcd x y)))

(define (Ex_1-33B n)
  (filtered-accumulate-iter
   (λ(i) (relative-prime? i n))
   ,* 1 id
   1 1+ (1- n)))

(define (alternate n)
  (apply *
         (filter (λ(i) (relative-prime? i n))
                 (iota (- n 1) 1))))

(mattcheck-equal "Ex_1-33B"
                 (Ex_1-33B 100)
                 (alternate 100))
#+END_SRC

#+RESULTS[55bb2d7ee1ab4c812a9f57fd811be17be87b2093]:
:results:

SUCCEED at Ex_1-33B
:end:

* Exercise 1.34
** Question
Suppose we define the procedure

#+BEGIN_SRC scheme
(define (f g) (g 2))
#+END_SRC

Then, we have

#+BEGIN_SRC scheme
(f square)
; 4
(f (lambda (z) (* z (+ z 1))))
; 6
#+END_SRC

What happens if we (perversely) ask the interpreter to evaluate the combination
src_scheme{(f f)}? Explain.
** Wrong Answer
This creates a recursive call. Since there is no conditional to interrupt it, ~f~ calls itself forever.
** Real Answer
#+BEGIN_SRC scheme -n :eval no-export :results output
;; Will be evaluated like this:
;;   (f f)
;;   (f 2)
;;   (2 2)
(define (f g) (g 2))
(f f)
#+END_SRC

#+RESULTS[fa3fee1227bd981f86a7f021bb6f63e9ad869b8e]:
:results:
=ice-9/boot-9.scm:1685:16: In procedure raise-exception:
Wrong type to apply: 2=
:end:
* Question 1.35
** Text
#+NAME: close-enough-txt
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (close-enough? x y) 
  (< (abs (- x y)) 0.001))
#+END_SRC

#+NAME: fixed-point-txt
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define tolerance 0.00001)

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) 
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))
#+END_SRC
** Question
Show that the golden ratio \(\varphi\) is a fixed point of the transformation
\(x \mapsto 1 + 1 / x\), and use this fact to compute \(\varphi\) by means of
the ~fixed-point~ procedure.
** Answer
#+NAME: fixed-point-txt
#+BEGIN_SRC scheme -n :eval no-export :results output
<<close-enough>>
<<fixed-point-txt>>
(define golden-ratio
  (fixed-point (λ(x)(+ 1 (/ 1 x)))
               1.0))

(display golden-ratio)
#+END_SRC

#+RESULTS[ab642d672c1d63abecbdf383dc53da955f5e11c7]: fixed-point-txt
:results:
1.6180327868852458
:end:

* Question 1.36
** Question
Modify ~fixed-point~ so that it prints the sequence of approximations it
generates, using the ~newline~ and ~display~ primitives shown in Exercise 1.22.
Then find a solution to \(x^x = 1000\) by finding a fixed point of \(x \mapsto
\log(1000) / \log(x)\). (Use Scheme's primitive ~log~ procedure, which computes
natural logarithms.) Compare the number of steps this takes with and without
average damping. (Note that you cannot start ~fixed-point~ with a guess of 1, as
this would cause division by \(\log(1) = 0\).)

** Answer
Using the ~display~ and ~newline~ functions at any great extent is pretty
exhausting, so I'll use ~format~ instead.
#+NAME: fixed-point-debug
#+BEGIN_SRC scheme -n :eval no-export :results silent
(use-modules (ice-9 format))
(define tolerance 0.00001)

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) 
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (format #t "~&~a~%" next)
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :results output :export code
<<close-enough>>
<<fixed-point-debug>>
(fixed-point (λ(x) (/ (log 1000) (log x))) 1.1)
#+END_SRC

#+RESULTS[26e30764924462e2d22df8d8ba9a56af22698a31]:
:results:
72.47657378429035
1.6127318474109593
14.45350138636525
2.5862669415385087
7.269672273367045
3.4822383620848467
5.536500810236703
4.036406406288111
4.95053682041456
4.318707390180805
4.721778787145103
4.450341068884912
4.626821434106115
4.509360945293209
4.586349500915509
4.535372639594589
4.568901484845316
4.546751100777536
4.561341971741742
4.551712230641226
4.558059671677587
4.55387226495538
4.556633177654167
4.554812144696459
4.556012967736543
4.555220997683307
4.555743265552239
4.555398830243649
4.555625974816275
4.555476175432173
4.555574964557791
4.555509814636753
4.555552779647764
4.555524444961165
4.555543131130589
4.555530807938518
4.555538934848503
:end:

Undamped, fixed-point makes 37 guesses.

#+BEGIN_SRC scheme -n :eval no-export :results output :export code
<<close-enough>>
<<fixed-point-debug>>
(define (average x y)
  (/ (+ x y) 2))
(fixed-point (λ(x) (average (log x) (/ (log 1000) (log x)))) 1.1)
#+END_SRC

#+RESULTS[c8b656c007db26b56776bc139a6cba1a86bb3755]:
:results:
36.28594198204734
2.7574149265729444
3.912351744086603
3.213980298130383
3.542082820324556
3.363310959347184
3.4540216132238184
3.4061901980695635
3.4309216866411916
3.418001560431991
3.4247152892453725
3.4212168715053366
3.42303720142058
3.4220893146379012
3.422582706729079
3.4223258347369994
3.4224595543381247
3.4223899401968296
3.4224261801254277
3.422407313956363
3.4224171354313153
:end:

Damped, it makes 21.

* Exercise 1.37
** Question A
An infinite continued fraction is an expression of the form

\[ {f} = \cfrac{N_1}{D_1 + \cfrac{N_2}{D_2 + \cfrac{N_3}{D_3 + \dots}}} \]

As an example, one can show that the infinite continued fraction expansion with
the \(N_i\) and the \(D_i\) all equal to 1 produces \(1 / \varphi\), where
\(\varphi\) is the golden ratio (described in 1.2.2). One way to approximate an
infinite continued fraction is to truncate the expansion after a given number of
terms. Such a truncation---a so-called \(k\)-term finite continued
fraction}---has the form

\[ \cfrac{N_1}{D_1 + \cfrac{N_2}{\ddots + \cfrac{N_k}{D_k}}} \]

Suppose that ~n~ and ~d~ are procedures of one argument (the term index \(i\))
that return the \(N_i\) and \(D_i\) of the terms of the continued fraction.
Define a procedure ~cont-frac~ such that evaluating
src_scheme{(cont-frac n d k)} computes the value of the \(k\)-term finite continued
fraction.
** Answer A
A note: the "golden ratio" this code estimates is exactly =1.0= less than the golden ratio anyone else seems to be talking about.
#+NAME: cont-frac
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (cont-frac n d k)
  (define (iter i result)
    (if (= i 0)
        result
        (iter (1- i) (/ (n i) (+ (d i) result)))))

  (iter (1- k) (/ (n k) (d k))))
#+END_SRC

** Question B
Check your procedure by approximating \(1 / \varphi\) using

#+BEGIN_SRC scheme
(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           k)
#+END_SRC

for successive values of ~k~. How large must you make ~k~ in order to get an
approximation that is accurate to 4 decimal places?

** Answer B
#+NAME: cont-frac-data
#+BEGIN_SRC scheme -n :eval no-export :results value table :exports results
<<cont-frac>>
(define (golden-ratio k)
  (cont-frac (λ(i) 1.0)(λ(i)1.0) k))

(map (λ(x y) (list x y))
     (iota 10 1)
      (map (λ(x)(- 0.61803398874989484820
                   (golden-ratio x)))
           (iota 10 1)))
#+END_SRC

#+RESULTS[c254d70f15375afe5614dfb4a165f1fa23fa4c6f]: cont-frac-data
:results:
|  1 |     -0.3819660112501051 |
|  2 |      0.1180339887498949 |
|  3 |    -0.04863267791677173 |
|  4 |    0.018033988749894814 |
|  5 |  -0.0069660112501050975 |
|  6 |   0.0026493733652794837 |
|  7 |  -0.0010136302977241662 |
|  8 |  0.00038692992636546464 |
|  9 | -0.00014782943192326314 |
| 10 |  5.6460660007306984e-05 |
:end:


#+begin_src gnuplot :var data=cont-frac-data :file fig/1-36-1.png :exports results :cache no :eval no-export
reset
#set logscale xy
set xlabel 'iterations'
set xtics rotate by -45
set ylabel 'error'
set title 'distance from true golden ratio'

plot data using 2:xticlabels(1) with fillsteps fs solid 0.3 noborder lt 1 notitle,\
     data using 2:xticlabels(1) with steps lt 1 lw 4 title '(golden-ratio)'
#+end_src

#+RESULTS:
:results:
[[file:fig/1-36-1.png]]
:end:

\(k\) must be at least 10 to get precision of 4 decimal places.

** Question B

If your ~cont-frac~ procedure generates a recursive process, write one that
generates an iterative process. If it generates an iterative process, write one
that generates a recursive process.

#+NAME: cont-frac-rec
#+BEGIN_SRC scheme -n :eval no-export :results silent
(define (cont-frac-rec n d k)
  (define (rec i)
    (if (= i k)
        (/ (n i) (d i))
        (/ (n i) (+ (d i) (rec (1+ i))))))

  (rec 1))
#+END_SRC
#+BEGIN_SRC scheme -n :eval no-export :results output :exports both
<<cont-frac>>
<<cont-frac-rec>>
(define (golden-ratio k)
  (cont-frac (λ(i) 1.0)(λ(i)1.0) k))
(define (golden-ratio-rec k)
  (cont-frac-rec (λ(i) 1.0)(λ(i)1.0) k))

(load "mattcheck.scm")
(mattcheck-equal "cont-frac iter and recursive equivalence"
           (golden-ratio-rec 15)
           (golden-ratio 15))
#+END_SRC

#+RESULTS[061d67cf4b680c4b50b710fad1cf7538691b71ac]:
:results:
SUCCEED at cont-frac iter and recursive equivalence
:end:

* Exercise 1.38
** Question
In 1737, the Swiss mathematician Leonhard Euler published a memoir /De
Fractionibus Continuis/, which included a continued fraction expansion for \(e -
2\), where \(e\) is the base of the natural logarithms. In this fraction, the
\(N_i\) are all 1, and the \(D_i\) are successively 1, 2, 1, 1, 4, 1, 1, 6, 1,
1, 8, \(\dots\). Write a program that uses your ~cont-frac~ procedure from
Exercise 1.37 to approximate \(e\), based on Euler's expansion.
** Answer
#+BEGIN_SRC scheme -n :eval no-export :results value :exports both
<<cont-frac>>
(define (euler k)
  (+ 2
     (cont-frac (λ(i) 1.0)
             (λ(i) (let ((j (1+ i)))
                     (if (= 0 (modulo j 3))
                         (* 2 (/ j 3))
                         1)))
             k)))

(euler 100)
#+END_SRC

#+RESULTS[a208d4dc1b978fe45e625fd5adc3de43be87dd9c]:
:results:
2.7182818284590455
:end:

* Exercise 1.39
** Question
A continued fraction representation of the tangent function was published in
1770 by the German mathematician J.H. Lambert:

\[ {\tan x} = \cfrac{x}{1 - \cfrac{x^2}{3 - \cfrac{x^2}{5 - \dots}}} \]

where \(x\) is in radians. Define a procedure src_scheme{(tan-cf x k)} that
computes an approximation to the tangent function based on Lambert's formula.
~k~ specifies the number of terms to compute, as in Exercise 1.37.
** Answer
#+BEGIN_SRC scheme -n :eval no-export :results value :exports both
<<cont-frac>>
(define (tan-cf x k)
  (cont-frac (λ(i) (if (= i 1)
                       x
                       (* x x -1.0)))
             (λ(i) (if (= i 1)
                       1.0
                       (- (* i 2.0) 1.0)))
             k))

(tan-cf 55 101)
#+END_SRC

#+RESULTS[a9f862c95bda0554e11a254c33a0772723442763]:
:results:
-45.1830879105221
:end:
* Exercise 1.40
** Text
#+NAME: average-damp
#+BEGIN_SRC scheme -n :eval no-export :results silent :exports code
(define (average-damp f)
  (lambda (x) (average x (f x))))
#+END_SRC

#+NAME: dx
#+BEGIN_SRC scheme -n :eval no-export :results silent :exports code
(define dx 0.00001)
#+END_SRC

#+NAME: deriv
#+BEGIN_SRC scheme -n :eval no-export :results silent :exports code
(define (deriv g)
  (lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))
#+END_SRC

#+NAME: newtons-method
#+BEGIN_SRC scheme -n :eval no-export :results silent :exports code
(define (newton-transform g)
  (lambda (x) (- x (/ (g x) ((deriv g) x)))))
(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))
#+END_SRC
#+NAME: newtons-method-txt
#+BEGIN_SRC scheme -n :eval no-export :results silent :exports code
<<average>>
<<average-damp>>
<<dx>>
<<deriv>>
<<newtons-method>>
#+END_SRC
** Question
Define a procedure ~cubic~ that can be used together with the ~newtons-method~
procedure in expressions of the form:

#+BEGIN_SRC scheme
(newtons-method (cubic a b c) 1)
#+END_SRC

to approximate zeros of the cubic \(x^3 + ax^2 + bx + c\).
** Answer
#+NAME: cubic
#+BEGIN_SRC scheme -n :eval no-export :results silent :exports code
(define (cubic a b c)
  (lambda (x)
    (+ (expt x 3)
       (* a (expt x 2))
       (* b x)
       c)))
#+END_SRC

#+NAME: cubic-zero
#+BEGIN_SRC scheme -n :eval no-export :results silent :exports code
(define (cubic-zero a b c)
  (newtons-method (cubic a b c) 1))
#+END_SRC

#+BEGIN_SRC scheme -n :eval no-export :results value :exports code
<<fixed-point-txt>>
<<newtons-method-txt>>
<<cubic>>
<<cubic-zero>>

(cubic-zero 2 3 4)
#+END_SRC

#+RESULTS[b8fe4f9579a7f55cc0714e136ae1b983a07db228]:
:results:
-1.6506291914330982
:end:

* Exercise 1.41
** Question
Define a procedure ~double~ that takes a procedure of one argument as argument
and returns a procedure that applies the original procedure twice. For example,
if ~inc~ is a procedure that adds 1 to its argument, then src_scheme{(double inc)}
should be a procedure that adds 2. What value is returned by

#+NAME: Ex1-41
#+BEGIN_SRC scheme :eval no-export
(((double (double double)) inc) 5)
#+END_SRC

** Answer
#+NAME: double
#+BEGIN_SRC scheme :eval no-export :results silent
(define (double f)
  (λ (x)
    (f (f x))))
#+END_SRC

#+BEGIN_SRC scheme :eval no-export :results value
(define inc 1+)
<<double>>
<<Ex1-41>>
#+END_SRC

#+RESULTS[d378985b9b2b6be8eb74b8df173275c6bd56ae10]:
:results:
21
:end:

* Exercise 1.42
** Question
Let \(f\) and \(g\) be two one-argument functions. The composition \(f\) after
\(g\) is defined to be the function \(x \mapsto f(g(x))\). Define a procedure
~compose~ that implements composition.

** Answer
#+NAME: compose
#+BEGIN_SRC scheme :eval no-export :results silent
(define (compose f g)
  (λ(x)
    (f (g x))))
#+END_SRC

#+BEGIN_SRC scheme :eval no-export :results value
<<compose>>
<<square>>
(define inc 1+)
((compose square inc) 6)
#+END_SRC

#+RESULTS[80a0d7155cb9d63a3166cc9ed13620258b09201d]:
:results:
49
:end:

* Exercise 1.43
** Question
If \(f\) is a numerical function
and \(n\) is a positive integer, then we can form the \(n^{\mathrm{th}}\) repeated
application of \(f\), which is defined to be the function whose value at \(x\)
is \(f(f(\dots (f(x))\dots ))\).  For example, if \(f\) is the
function \(x \mapsto x + 1\), then the \(n^{\mathrm{th}}\) repeated application of \(f\) is
the function \(x \mapsto x + n\).  If \(f\) is the operation of squaring a
number, then the \(n^{\mathrm{th}}\) repeated application of \(f\) is the function that
raises its argument to the \(2^n\)-th power.  Write a procedure that takes as
inputs a procedure that computes \(f\) and a positive integer \(n\) and returns
the procedure that computes the \(n^{\mathrm{th}}\) repeated application of \(f\).

** Answer
#+NAME: repeated
#+BEGIN_SRC scheme :eval no-export :results silent
<<compose>>
(define (repeated f n)
  (if (= n 1)
      f
      (repeated (compose f f)
                (- n 1))))
#+END_SRC

#+BEGIN_SRC scheme :eval no-export :results value
<<square>>
<<repeated>>
(if (= ((repeated square 2) 5) 625)
    "Success"
    "Fail")
#+END_SRC

#+RESULTS[272bb6d728bab74579f0a931d49a14a7ad2a5498]:
:results:
Success
:end:
