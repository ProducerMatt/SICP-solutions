% Created 2022-08-27 Sat 00:54
% Intended LaTeX compiler: xelatex
\documentclass[final,fleqn,titlepage]{article}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{fontspec}
\setmonofont[Mapping=tex-text,Scale=MatchLowercase]{FiraMono-Regular}
\usepackage[cache=false]{minted}
\usemintedstyle{colorful}
\listfiles
\author{ProducerMatt}
\date{\today}
\title{SICP Chapter 1 Answers}
\hypersetup{
 pdfauthor={ProducerMatt},
 pdftitle={SICP Chapter 1 Answers},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.1 (Org mode 9.6)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{HOW THIS DOCUMENT IS MADE}
\label{sec:org13dca9e}
\textbf{\textbf{TODO}}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (foo a b)
  (+ a (* 2 b)))

(foo 5 3)
\end{minted}

11

\^{} Dynamically evaluated when you press ``enter'' on the \texttt{BEGIN\_SRC} block!

\subsubsection{Also consider:}
\label{sec:org8654b1d}
\begin{itemize}
\item \texttt{:results output} for what the code prints
\item \texttt{:exports code} or \texttt{:exports results} to just get one or the other
\end{itemize}

\(a + (\pi \times b)\) <\textasciitilde{} inline Latex btw :)

\subsubsection{Current command for conversion}
\label{sec:org4470481}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{sh}
pandoc --from org --to latex 1.org -o 1.tex -s; xelatex 1.tex
\end{minted}

\subsection{Helpers for org-mode tables}
\label{sec:org1efd094}
\subsubsection{\texttt{try-these}}
\label{sec:org7f6dc72}
Takes function \texttt{f} and list \texttt{testvals} and applies \texttt{f} to each item \texttt{i}. For
each \texttt{i} returns a list with \texttt{i} and the result. Useful dor making tables with a
column for input and a column for output.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; Surely this could be less nightmarish
(define (try-these f . testvals)
  (let ((l (if (and (= 1 (length testvals))
                    (list? (car testvals)))
               (car testvals)
               testvals)))
    (map (λ (i) (cons i
                      (cons (if (list? i)
                                (apply f i)
                                (f i))
                            #nil)))
         l)))
\end{minted}
\subsubsection{\texttt{transpose-list}}
\label{sec:orgdf6229e}
``Rotate'' a list, for example from \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{'(1 2 3)} to
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{'('(1) '(2) '(3))}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (transpose-list l)
  (map list l))
\end{minted}
\subsubsection{\texttt{print-as-rows}}
\label{sec:org58eb3ca}
For manually printing items in rows to stdout. Not currently used.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (p-nl a)
  (display a)
  (newline))
(define (print-spaced args)
  (let ((a (car args))
        (d (cdr args)))
    (if (null? d)
        (p-nl a)
        (begin (display a)
               (display " ")
               (print-spaced d)))))
(define (print-as-rows . args)
  (let ((a (car args))
        (d (cdr args)))
    (if (list? a)
        (if (= 1 (length args))
            (apply print-as-rows a)
            (print-spaced a))
        (p-nl a))
    (if (null? d)
        '()
        (apply print-as-rows d))))
\end{minted}
\subsubsection{\texttt{print-table}}
\label{sec:orgda48e37}
Print \texttt{args} as a table separated by pipes. Optionally print spacer for
colnames.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define* (print-table table #:key (colnames #f))
  (define* (print-row ll #:key (fmt " ~s |"))
    (format #t "~&|")
    (map (λ(x) (format #t fmt x)) ll)
    (format #t "~%"))
  (define (iter t)
    (print-row (car t))
    (if colnames
        (print-row (car t) #:fmt "---|"))
    (map print-row (cdr t)))
  (cond ((and (= 1 (length table))
              (list? (car table))) (iter (car table)))
        ((<= 1 (length table)) (iter table))
        (else error "Invalid Input??")))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<print-table>>
(let* ((l (iota 3))
      (table (list
              (list 'column-1 'column-2 'column-3 'column-4)
              (cons 'row-a l)
              (cons 'row-b l)
              (cons 'row-c l))))
  (print-table table #:colnames #t ))
\end{minted}

\begin{center}
\begin{tabular}{lrrr}
column-1 & column-2 & column-3 & column-4\\
\hline
row-a & 0 & 1 & 2\\
row-b & 0 & 1 & 2\\
row-c & 0 & 1 & 2\\
\end{tabular}
\end{center}

\section{Exercise 1.1}
\label{sec:orgecf5b3b}
\subsection{Question}
\label{sec:org0cd4e21}
Below is a sequence of expressions. What is the result printed by the
interpreter in response to each expression? Assume that the sequence is to be
evaluated in the order in which it is presented.
\subsection{Answer}
\label{sec:orgbebeebf}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
10 ;; 10
(+ 5 3 4) ;; 12
(- 9 1) ;; 8
(/ 6 2) ;; 3
(+ (* 2 4) (- 4 6)) ;; 6
(define a 3) ;; a=3
(define b (+ a 1)) ;; b=4
(+ a b (* a b)) ;; 19
(= a b) ;; false
(if (and (> b a) (< b (* a b)))
    b
    a) ;; 4
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25)) ;; 16
(+ 2 (if (> b a) b a)) ;; 6
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1)) ;; 16
\end{minted}

\section{Exercise 1.2}
\label{sec:org3e7131b}
\subsection{Question}
\label{sec:org9e94413}
Translate the following expression into prefix form:
\[
  \frac{5 + 2 + (2 - 3 - (6 + \frac{4}{5})))}
            {3(6 - 2)(2 - 7)}
\]
\subsection{Answer}
\label{sec:org477c70c}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(/ (+ 5 2 (- 2 3 (+ 6 (/ 4 5))))
   (* 3 (- 6 2) (- 2 7)))
\end{minted}

1/75

\section{Exercise 1.3}
\label{sec:org2e969ab}
\subsection{Text}
\label{sec:org15c45a0}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (square x)
  (* x x))
\end{minted}
\subsection{Question}
\label{sec:orga9ccb29}
Define a procedure that takes three numbers as arguments and returns the sum of
the squares of the two larger numbers.
\subsection{Answer}
\label{sec:orge086af1}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
(define (sum-square x y)
  (+ (square x) (square y)))
(define (square-2of3 a b c)
  (cond ((and (>= a b) (>= b c)) (sum-square a b))
        ((and (>= a b) (> c b)) (sum-square a c))
        (else (sum-square b c))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<EX1-3>>
<<try-these>>
 (try-these square-2of3 '(7 5 3)
                        '(7 3 5)
                        '(3 5 7))
\end{minted}

\begin{center}
\begin{tabular}{lr}
(7 5 3) & 74\\
(7 3 5) & 74\\
(3 5 7) & 74\\
\end{tabular}
\end{center}

\section{Exercise 1.4}
\label{sec:org5814e88}
\subsection{Question}
\label{sec:orgbf42edd}
Observe that our model of evaluation allows for combinations whose operators are
compound expressions. Use this observation to describe the behavior of the
following procedure:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
\end{minted}

\subsection{Answer}
\label{sec:org4e60715}
This code accepts the variables \texttt{a} and \texttt{b}, and if \texttt{b} is positive, it adds \texttt{a}
and \texttt{b}. However, if \texttt{b} is zero or negative, it subtracts them. This decision
is made by using the \texttt{+} and \texttt{-} procedures as the results of an if expression,
and then evaluating according to the results of that expression. This is in
contrast to a language like Python, which would do something like this:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{python}
if b > 0: a + b
else: a - b
\end{minted}

\section{Exercise 1.5}
\label{sec:orge477ca1}
\subsection{Question}
\label{sec:org855081b}
Ben Bitdiddle has invented a test to determine whether the interpreter he is
faced with is using applicative-order evaluation or normal-order evaluation. He
defines the following two procedures:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
\end{minted}
Then he evaluates the expression

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(test 0 (p))
\end{minted}

What behavior will Ben observe with an interpreter that uses applicative-order
evaluation? What behavior will he observe with an interpreter that uses
normal-order evaluation? Explain your answer. (Assume that the evaluation rule
for the special form if is the same whether the interpreter is using normal or
applicative order: The predicate expression is evaluated first, and the result
determines whether to evaluate the consequent or the alternative expression.)

\subsection{Answer}
\label{sec:org7bf8d4e}
In either type of language, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(define (p) (p))} is an infinite
loop. However, a normal-order language will encounter the special form, return
\texttt{0}, and never evaluate \texttt{(p)}. An applicative-order language evaluates the
arguments to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(test 0 (p))}, thus triggering the infinite
loop.

\section{Exercise 1.6}
\label{sec:org5a44259}
\subsection{Text code}
\label{sec:orgf1e143b}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (abs x)
  (if (< x 0)
	  (- x)
	  x))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (average x y)
  (/ (+ x y) 2))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<average>>
(define (improve guess x)
  (average guess (/ x guess)))

<<square>>
<<abs>>
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))

(define (sqrt x)
  (sqrt-iter 1.0 x))
\end{minted}

\subsection{Question}
\label{sec:orgfd61dc1}
Exercise 1.6: Alyssa P. Hacker doesn’t see why if needs to be provided as a
special form. “Why can’t I just define it as an ordinary procedure in terms of
cond?” she asks. Alyssa’s friend Eva Lu Ator claims this can indeed be done, and
she defines a new version of if:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (new-if predicate
                then-clause
                else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
\end{minted}
Eva demonstrates the program for Alyssa:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(new-if (= 2 3) 0 5)
;; => 5

(new-if (= 1 1) 0 5)
;; => 0
\end{minted}

Delighted, Alyssa uses new-if to rewrite the square-root program:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))
\end{minted}

What happens when Alyssa attempts to use this to compute square roots? Explain.

\subsection{Answer}
\label{sec:org61c2261}
Using Alyssa's \texttt{new-if} leads to an infinite loop because the recursive call to
\texttt{sqrt-iter} is evaluated before the actual call to \texttt{new-if}. This is because
\texttt{if} and \texttt{cond} are special forms that change the way evaluation is handled;
whichever branch is chosen leaves the other branches unevaluated.

\section{Exercise 1.7}
\label{sec:orgf802fb5}
\subsection{Text}
\label{sec:org76b6d4b}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (mean-square x y)
  (average (square x) (square y)))
\end{minted}
\subsection{Question}
\label{sec:org3905865}
The good-enough? test used in computing square roots will not be very effective
for finding the square roots of very small numbers. Also, in real computers,
arithmetic operations are almost always performed with limited precision. This
makes our test inadequate for very large numbers. Explain these statements, with
examples showing how the test fails for small and large numbers. An alternative
strategy for implementing good-enough? is to watch how guess changes from one
iteration to the next and to stop when the change is a very small fraction of
the guess. Design a square-root procedure that uses this kind of end test. Does
this work better for small and large numbers?
\subsection{Diary}
\label{sec:org3935fc0}
\subsubsection{Solving}
\label{sec:org4f28a4c}
My original answer was this, which compares the previous iteration until the new
and old are within an arbitrary \(dx\).

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<txt-sqrt>>
(define (inferior-good-enough? guess lastguess)
  (<=
   (abs (-
         (/ lastguess guess)
         1))
   0.0000000000001)) ; dx
(define (new-sqrt-iter guess x lastguess) ;; Memory of previous value
  (if (inferior-good-enough? guess lastguess)
      guess
      (new-sqrt-iter (improve guess x) x guess)))
(define (new-sqrt x)
  (new-sqrt-iter 1.0 x 0))
\end{minted}

This solution can correctly find small and large numbers:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<inferior-good-enough>>
(new-sqrt 10000000000000)
\end{minted}

3162277.6601683795

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<try-these>>
<<inferior-good-enough>>
(try-these new-sqrt '(0.01 0.0001 0.000001 0.00000001 0.0000000001))
\end{minted}

\begin{center}
\begin{tabular}{rr}
0.01 & 0.1\\
0.0001 & 0.01\\
1e-06 & 0.001\\
1e-08 & 9.999999999999999e-05\\
1e-10 & 9.999999999999999e-06\\
\end{tabular}
\end{center}


However, I found this solution online that isn't just simpler but automatically
reaches the precision limit of the system:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<txt-sqrt>>
(define (best-good-enough? guess x)
   (= (improve guess x) guess))
\end{minted}

\subsubsection{Imroving (sqrt) by avoiding extra (improve) call}
\label{sec:org933b6ca}
\begin{enumerate}
\item Non-optimized
\label{sec:org1fb9e6b}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-modules (ice-9 format))
(load "../mattbench.scm")
(define (average x y)
  (/ (+ x y) 2))
(define (improve guess x)
  (average guess (/ x guess)))
(define (good-enough? guess x)
   (= (improve guess x) guess)) ;; improve call 1
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x))) ;; call 2
(define (sqrt x)
  (sqrt-iter 1.0 x))
(newline)
(display (mattbench (λ() (sqrt 69420)) 400000000))
(newline)
;; 4731.30 <- Benchmark results
\end{minted}

\item Optimized
\label{sec:orga591ace}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-modules (ice-9 format))
(load "../mattbench.scm")
(define (average x y)
  (/ (+ x y) 2))
(define (improve guess x)
  (average guess (/ x guess)))
(define (good-enough? guess nextguess x)
  (= nextguess guess))
(define (sqrt-iter guess x)
  (let ((nextguess (improve guess x)))
    (if (good-enough? guess nextguess x)
        guess
        (sqrt-iter nextguess x))))
(define (sqrt x)
  (sqrt-iter 1.0 x))
(newline)
(display (mattbench (λ() (sqrt 69420)) 400000000))
(newline)
\end{minted}
\item Benchmark results
\label{sec:org84d4f20}
\begin{center}
\begin{tabular}{lr}
Unoptimized & 4731.30\\
Optimized & 2518.44\\
\end{tabular}
\end{center}
\end{enumerate}

\subsection{Answer}
\label{sec:orga3a4759}
The current method has decreasing accuracy with smaller numbers. Notice the
steady divergence from correct answers here (should be decreasing powers of
0.1):
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<txt-sqrt>>
<<try-these>>
(try-these sqrt 0.01 0.0001 0.000001 0.00000001 0.0000000001)
\end{minted}

\begin{center}
\begin{tabular}{rr}
0.01 & 0.10032578510960605\\
0.0001 & 0.03230844833048122\\
1e-06 & 0.031260655525445276\\
1e-08 & 0.03125010656242753\\
1e-10 & 0.03125000106562499\\
\end{tabular}
\end{center}

And for larger numbers, an infinite loop will eventually be reached. \(10^{12}\)
can resolve, but \(10^{13}\) cannot.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<txt-sqrt>>
(sqrt 1000000000000)
\end{minted}

1000000.0

So, my definition of \texttt{sqrt}:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<average>>
(define (improve guess x)
  (average guess (/ x guess)))
(define (good-enough? guess x)
   (= (improve guess x) guess))
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
(define (sqrt x)
  (sqrt-iter 1.0 x))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<try-these>>
<<sqrt>>
(try-these sqrt '(0.01 0.0001 0.000001 0.00000001 0.0000000001))
\end{minted}

\begin{center}
\begin{tabular}{rr}
0.01 & 0.1\\
0.0001 & 0.01\\
1e-06 & 0.001\\
1e-08 & 9.999999999999999e-05\\
1e-10 & 9.999999999999999e-06\\
\end{tabular}
\end{center}

\section{Exercise 1.8}
\label{sec:orgf0ec247}
\subsection{Question}
\label{sec:orgd30cda1}
Newton’s method for cube roots is based on the fact that if y is an
approximation to the cube root of x, then a better approximation is given by the
value:
\begin{equation}
\frac{\frac{x}{y^2} + 2y}{3}
\end{equation}
Use this formula to implement a cube-root procedure analogous to the square-root
procedure. (In 1.3.4 we will see how to implement Newton’s method in general as
an abstraction of these square-root and cube-root procedures.)
\subsection{Diary}
\label{sec:org16648d5}
My first attempt works, but needs an arbitrary limit to stop infinite loops:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
<<try-these>>
(define (cb-good-enough? guess x)
  (= (cb-improve guess x) guess))
(define (cb-improve guess x)
  (/
   (+
    (/ x (square guess))
    (* guess 2))
   3))
(define (cbrt-iter guess x counter)
  (if (or (cb-good-enough? guess x) (> counter 100))
      guess
      (begin
        (cbrt-iter (cb-improve guess x) x (+ 1 counter)))))
(define (cbrt x)
  (cbrt-iter 1.0 x 0))

(try-these cbrt 7 32 56 100)
\end{minted}

\begin{center}
\begin{tabular}{rr}
7 & 1.912931182772389\\
32 & 3.174802103936399\\
56 & 3.825862365544778\\
100 & 4.641588833612779\\
\end{tabular}
\end{center}

However, this will hang on an infinite loop when trying to run \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(cbrt 100)}.
I speculate it's a floating point precision issue with the ``improve''
algorithm. So to avoid it I'll just keep track of the last guess and stop
improving when there's no more change occurring. Also while researching I
discovered that (again due to floating point) \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(cbrt -2)} loops
forever unless you initialize your guess with a slightly different value, so
let's do 1.1 instead.
\subsection{Answer}
\label{sec:org0a2385e}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
(define (cb-good-enough? nextguess guess lastguess x)
  (or (= nextguess guess)
      (= nextguess lastguess)))
(define (cb-improve guess x)
  (/
   (+
    (/ x (square guess))
    (* guess 2))
   3))
(define (cbrt-iter guess lastguess x)
  (define nextguess (cb-improve guess x))
  (if (cb-good-enough? nextguess guess lastguess x)
      nextguess
      (cbrt-iter nextguess guess x)))
(define (cbrt x)
  (cbrt-iter 1.1 9999 x))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<cbrt>>
<<try-these>>
(try-these cbrt 7 32 56 100 -2)
\end{minted}

\begin{center}
\begin{tabular}{rr}
7 & 1.912931182772389\\
32 & 3.174802103936399\\
56 & 3.825862365544778\\
100 & 4.641588833612779\\
-2 & -1.2599210498948732\\
\end{tabular}
\end{center}

\section{Exercise 1.9}
\label{sec:orgb3d655d}
\subsection{Question}
\label{sec:orgf78b872}
Each of the following two procedures defines a method for adding two positive
integers in terms of the procedures inc, which increments its argument by 1, and
dec, which decrements its argument by 1.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
\end{minted}

Using the substitution model, illustrate the process generated by each procedure
in evaluating \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(+ 4 5)}. Are these processes iterative or recursive?
\subsection{Answer}
\label{sec:org220ef2b}
The first procedure is recursive, while the second is iterative though
tail-recursion.
\subsubsection{recursive procedure}
\label{sec:orgfda0313}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
\end{minted}

\subsubsection{iterative procedure}
\label{sec:org06790cc}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
\end{minted}

\section{Exercise 1.10}
\label{sec:orge9c6b08}
\subsection{Question}
\label{sec:org0ef9bab}
The following procedure computes a mathematical function called Ackermann’s
function.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
\end{minted}

What are the values of the following expressions?

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(A 1 10)
(A 2 4)
(A 3 3)
\end{minted}
\begin{center}
\begin{tabular}{lr}
(1 10) & 1024\\
(2 4) & 65536\\
(3 3) & 65536\\
\end{tabular}
\end{center}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<ackermann>>
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
\end{minted}

Give concise mathematical definitions for the functions computed by the
procedures \texttt{f}, \texttt{g}, and \texttt{h} for positive integer values of \(n\). For example,
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(k n)} computes \(5n^2\).

\subsection{Answer}
\label{sec:org719a6bc}
\subsubsection{\texttt{f}}
\label{sec:orgd068894}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<try-these>>
<<EX1-10-defs>>
(try-these f 1 2 3 10 15 20)
\end{minted}

\begin{center}
\begin{tabular}{rr}
1 & 2\\
2 & 4\\
3 & 6\\
10 & 20\\
15 & 30\\
20 & 40\\
\end{tabular}
\end{center}

\[
f(n)=2n
\]
\subsubsection{\texttt{g}}
\label{sec:orge0c4b93}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<try-these>>
<<EX1-10-defs>>
(try-these g 1 2 3 4 5 6 7 8)
\end{minted}

\begin{center}
\begin{tabular}{rr}
1 & 2\\
2 & 4\\
3 & 8\\
4 & 16\\
5 & 32\\
6 & 64\\
7 & 128\\
8 & 256\\
\end{tabular}
\end{center}

\[
g(n)=2^n
\]

\subsubsection{\texttt{h}}
\label{sec:org62646a4}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<try-these>>
<<EX1-10-defs>>
(try-these h 1 2 3 4)
\end{minted}

\begin{center}
\begin{tabular}{rr}
1 & 2\\
2 & 4\\
3 & 16\\
4 & 65536\\
\end{tabular}
\end{center}

It took a while to figure this one out, just because I didn't know the term.
This is repeated exponentiation. This operation is to exponentiation, what
exponentiation is to multiplication. It's called either \emph{tetration} or \emph{hyper-4}
and has no formal notation, but two common ways would be these:

\[
h(n)=2 \uparrow\uparrow n
\]
\[
h(n)={}^{n}2
\]

\section{Exercise 1.11}
\label{sec:org12d7673}
\subsection{Question}
\label{sec:orgbc1c1ab}
A function \(f\) is defined by the rule that:
\[
f(n)=n \text{ if } n<3
\]
\[
\text{ and }
\]
\[
f(n)=f(n-1)+2f(n-2)+3f(n-3) \text{ if } n \geq 3
\]

Write a procedure that computes \(f\) by means of a recursive process. Write a
procedure that computes \(f\) by means of an iterative process.
\subsection{Answer}
\label{sec:org1255f25}
\subsubsection{Recursive}
\label{sec:orge03f7c9}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (fr n)
  (if (< n 3)
      n
      (+      (fr (- n 1))
         (* 2 (fr (- n 2)))
         (* 3 (fr (- n 3))))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<try-these>>
<<EX1-11-fr>>
(try-these fr 1 3 5 10)
\end{minted}

\begin{center}
\begin{tabular}{rr}
1 & 1\\
3 & 4\\
5 & 25\\
10 & 1892\\
\end{tabular}
\end{center}

\subsubsection{Iterative}
\label{sec:org16cd1d6}
\begin{enumerate}
\item Attempt 1
\label{sec:org455e331}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; This seems like it could be better
(define (fi n)
  (define (formula l)
    (let ((a (car l))
           (b (cadr l))
           (c (caddr l)))
      (+ a
         (* 2 b)
         (* 3 c))))
  (define (iter l i)
    (if (= i n)
        (car l)
        (iter (cons (formula l) l)
              (+ 1 i))))
  (if (< n 3)
      n
      (iter '(2 1 0) 2)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<try-these>>
<<EX1-11-fi>>
(try-these fi 1 3 5 10)
\end{minted}

\begin{center}
\begin{tabular}{rr}
1 & 1\\
3 & 4\\
5 & 25\\
10 & 1892\\
\end{tabular}
\end{center}

It works but it seems wasteful.

\item Attempt 2
\label{sec:org64e992a}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (fi2 n)
  (define (formula a b c)
      (+ a
         (* 2 b)
         (* 3 c)))
  (define (iter a b c i)
    (if (= i n)
        a
        (iter (formula a b c)
              a
              b
              (+ 1 i))))
  (if (< n 3)
      n
      (iter 2 1 0 2)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<try-these>>
<<EX1-11-fi2>>
(try-these fi2 1 3 5 10)
\end{minted}

\begin{center}
\begin{tabular}{rr}
1 & 1\\
3 & 4\\
5 & 25\\
10 & 1892\\
\end{tabular}
\end{center}

I like that better.
\end{enumerate}

\section{Exercise 1.12}
\label{sec:orgb741d15}
\subsection{Question}
\label{sec:org275113e}
The following pattern of numbers is called Pascal’s triangle.

\emph{Pretend there's a Pascal's triangle here.}

The numbers at the edge of the triangle are all 1, and each number inside the
triangle is the sum of the two numbers above it. Write a procedure that
computes elements of Pascal’s triangle by means of a recursive process.
\subsection{Answer}
\label{sec:org9b9513d}
I guess I'll rotate the triangle 45 degrees to make it the top-left corner of an
infinite spreadsheet.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (pascal x y)
  (if (or (= x 0)
          (= y 0))
      1
      (+ (pascal (- x 1) y)
         (pascal x (- y 1)))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<try-these>>
<<pascal-rec>>
(let ((l (iota 8)))
  (map (λ (row)
         (map (λ (xy)
                (apply pascal xy))
              row))
       (map (λ (x)
              (map (λ (y)
                     (list x y))
                   l))
            l)))
\end{minted}

\begin{center}
\begin{tabular}{rrrrrrrr}
1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\
1 & 2 & 3 & 4 & 5 & 6 & 7 & 8\\
1 & 3 & 6 & 10 & 15 & 21 & 28 & 36\\
1 & 4 & 10 & 20 & 35 & 56 & 84 & 120\\
1 & 5 & 15 & 35 & 70 & 126 & 210 & 330\\
1 & 6 & 21 & 56 & 126 & 252 & 462 & 792\\
1 & 7 & 28 & 84 & 210 & 462 & 924 & 1716\\
1 & 8 & 36 & 120 & 330 & 792 & 1716 & 3432\\
\end{tabular}
\end{center}

The test code was much harder to write than the actual solution.

\section{Exercise 1.13}
\label{sec:org102bb6b}
\subsection{Question}
\label{sec:org3d5e42e}
Prove that \(\text{Fib}(n)\) is the closest integer to
\(\frac{ϕ^n}{\sqrt{5}}\) where Phi is \(\frac{1 + \sqrt{5}}{2}\). Hint: let
\(Υ = \frac{1 - \sqrt{5}}{2}\). Use induction and the definition of the
Fibonacci numbers to prove that

\[
 \text{Fib}(n) = \frac{ϕ^n - Υ^n}{\sqrt{5}}
\]

\subsection{Answer}
\label{sec:org0f8a4d0}
I don't know how to write a proof yet, but I can make functions to
demonstrate it.

\subsubsection{Fibonacci number generator}
\label{sec:org8e5352d}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (fib-iter n)
  (define (iter i a b)
    (if (= i n)
        b
    (iter (+ i 1)
          b
          (+ a b))))
  (if (<= n 2)
      1
      (iter 2 1 1)))
\end{minted}
\subsubsection{Various algorithms relating to the question}
\label{sec:orgc0380db}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<sqrt>>
(define sqrt5
  (sqrt 5))
(define phi
  (/ (+ 1 sqrt5) 2))
(define upsilon
  (/ (- 1 sqrt5) 2))
(define (fib-phi n)
  (/ (- (expt phi n)
        (expt upsilon n))
     sqrt5))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
<<fib-iter>>
<<fib-phi>>
<<try-these>>

(let* ((vals (drop (iota 21) 10))
       (fibs (map fib-iter vals))
       (approx (map fib-phi vals)))
  (zip vals fibs approx))
\end{minted}

\begin{center}
\begin{tabular}{rrr}
10 & 55 & 54.99999999999999\\
11 & 89 & 89.0\\
12 & 144 & 143.99999999999997\\
13 & 233 & 232.99999999999994\\
14 & 377 & 377.00000000000006\\
15 & 610 & 610.0\\
16 & 987 & 986.9999999999998\\
17 & 1597 & 1596.9999999999998\\
18 & 2584 & 2584.0\\
19 & 4181 & 4181.0\\
20 & 6765 & 6764.999999999999\\
\end{tabular}
\end{center}

You can see they follow closely. Graphing the differences, it's just
an exponential curve at very low values, presumably following the
exponential increase of the Fibonacci sequence itself.
\begin{center}
\includegraphics[width=.9\linewidth]{fig/1-13.png}
\end{center}

\section{Exercise 1.14}
\label{sec:orge3be246}
Below is the default version of the count-change function. I'll be aggressively
modifying it in order to get a graph out of it.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0)
             (= kinds-of-coins 0))
         0)
        (else
         (+ (cc amount (- kinds-of-coins 1))
            (cc (- amount (first-denomination
                           kinds-of-coins))
                kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
\end{minted}
\subsection{Question}
\label{sec:org6f20ff3}
Draw the tree illustrating the process generated by the count-change procedure
of 1.2.2 in making change for 11 cents.
\subsection{Answer}
\label{sec:orgb89e6ec}
I want to generate this graph algorithmically.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; cursed global
(define bubblecounter 0)
;; Returns # of ways change can be made
;; "Helper" for (cc)
(define (count-change amount)
  (display "digraph {\n") ;; start graph
  (cc amount 5 0)
  (display "}\n") ;; end graph
  (set! bubblecounter 0))

;; GraphViz output
;; Derivative: https://stackoverflow.com/a/14806144
(define (cc amount kinds-of-coins oldbubble)
  (let ((recur (lambda (new-amount new-kinds)
                 (begin
                   (display "\"") ;; Source bubble
                   (display `(,oldbubble ,amount ,kinds-of-coins))
                   (display "\"")
                   (display " -> ") ;; arrow pointing from parent to child
                   (display "\"") ;; child bubble
                   (display `(,bubblecounter ,new-amount ,new-kinds))
                   (display "\"")
                   (display "\n")
                   (cc new-amount new-kinds bubblecounter)))))
    (set! bubblecounter (+ bubblecounter 1))
    (cond ((= amount 0) 1)
          ((or (< amount 0) (= kinds-of-coins 0)) 0)
          (else (+
                 (recur amount (- kinds-of-coins 1))
                 (recur (- amount
                           (first-denomination kinds-of-coins))
                        kinds-of-coins))))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
\end{minted}

I'm not going to include the full printout of the \texttt{(count-change 11)}, here's an example of what this looks like via \texttt{1}.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<count-change-graphviz>>
(count-change 1)
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{dot}
digraph {
"(0 1 5)" -> "(1 1 4)"
"(1 1 4)" -> "(2 1 3)"
"(2 1 3)" -> "(3 1 2)"
"(3 1 2)" -> "(4 1 1)"
"(4 1 1)" -> "(5 1 0)"
"(4 1 1)" -> "(6 0 1)"
"(3 1 2)" -> "(7 -4 2)"
"(2 1 3)" -> "(8 -9 3)"
"(1 1 4)" -> "(9 -24 4)"
"(0 1 5)" -> "(10 -49 5)"
}
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{fig/cc-test.png}
\end{center}

So, the graph of \texttt{(count-change 11)} is:
\begin{center}
\includegraphics[width=.9\linewidth]{fig/cc-11.png}
\end{center}

\subsection{Question 2}
\label{sec:org58c6875}
What are the orders of growth of the space and number of steps used by this
process as the amount to be changed increases?

\subsection{Answer 2}
\label{sec:orga98031c}
Let's look at this via the number of function calls needed for value \texttt{n}. Instead
of returning an integer, I'll return a pair where \texttt{car} is the number of ways to
count change, and \texttt{cdr} is the number of function calls that have occurred down
that branch of the tree.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (count-calls amount)
  (cc-calls amount 5))

(define (cc-calls amount kinds-of-coins)
  (cond ((= amount 0) '(1 . 1))
        ((or (< amount 0)
             (= kinds-of-coins 0))
         '(0 . 1))
        (else
         (let ((a (cc-calls amount (- kinds-of-coins 1)))
               (b (cc-calls (- amount (first-denomination
                                 kinds-of-coins))
                      kinds-of-coins)))
           (cons (+ (car a)
                    (car b))
                 (+ 1
                    (cdr a)
                    (cdr b)))))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
\end{minted}


\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
<<cc-calls>>
(let* ((vals (drop (iota 101) 1))
       (mine (map count-calls vals)))
  (zip vals (map car mine) (map cdr mine)))
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{fig/cc-100.png}
\end{center}

I believe the space to be \(\Theta(n+d)\) as the function calls count down the
denominations before counting down the change. However I notice most answers
describe \(\Theta(n)\) instead, maybe I'm being overly pedantic and getting the
wrong answer.

My issues came finding the time. The book describes the meaning and properties
of \(\Theta\) notation in \href{http://sarabander.github.io/sicp/html/1\_002e2.xhtml\#g\_t1\_002e2\_002e3}{Section 1.2.3}. However, my lack of formal math
education made realizing the significance of this passage difficult. For one, I
didn't understand that \(k_{1}f(n) \leq R(n) \leq k_{2}f(n)\) means ``you can
find the \(\Theta\) by proving that a graph of the algorithm's resource usage is
bounded by two identical functions multiplied by constants.'' So, the graph of
resource usage for an algorithm with \(\Theta(n^{2})\) will by bounded by lines
of \(n^{2} \times some constant\), the top boundary's constant being larger than
the small boundary. These are arbitrarily chosen constants, you're just proving
that the function behaves the way you think it does.

Overall, finding the \(\Theta\) and \(\Omega\) and \(O\) notations (they are all
different btw!) is about aggressively simplifying to make a very general
statement about the behavior of the algorithm.

I could tell that a ``correct'' way to find the \(\Theta\) would be to make a
formula which describes the algorithm's function calls for given input and
denominations. This is one of the biggest time sinks, although I had a lot of
fun and learned a lot. In the end, with some help from Jach in a Lisp Discord, I
had the following formula:

\[
\sum_{i=1}^{ceil(n / val(d))} T(n - val(d)*i, d)
\]

But I wasn't sure where to go from here. The graphs let me see some interesting
trends, though I didn't get any closer to an answer in the process.

By reading on other websites, I knew that you could find \(\Theta\) by obtaining
a formula for \(R(n)\) and removing constants to end up with a term of interest.
For example, if your algorithm's resource usage is \(\frac{n^{2} + 7n}{5}\),
this demonstrates \(\Theta(n^{2})\). So I know a formula \textbf{without} a \(\sum\)
would give me the answer I wanted. It didn't occur to me that it might be
possible to use calculus to remove the \(\sum\) from the equation. At this point
I knew I was stuck and decided to look up a guide.

After seeing a few solutions that I found somewhat confusing, I landed on \href{https://codology.net/post/sicp-solution-exercise-1-14/}{this
awesome article from Codology.net}. They show how you can remove the summation,
and proposed this equation for count-change with 5 denominations:

\[
T(n,5)=\frac n{50}+1+\sum_{i=0}^{n/50}T(n-50i,1)
\]

Which, when expanded and simplified, demonstrates \(\Theta(n^{5})\) for 5
denominations.

Overall I'm relieved that I wasn't entirely off, given I haven't done math work
like this since college. It's inspired me to restart my remedial math courses, I
don't think I really grasped the nature of math as a tool of empowerment until
now.

\section{Exercise 1.15}
\label{sec:org1c30774}
\subsection{Question 1}
\label{sec:orgf3a4b6e}
The sine of an angle (specified in radians) can be computed by making use of the
approximation \(\sin x ≈ x\) if \(x\) is sufficiently small, and the
trigonometric identity \(\sin x = 3\sin\frac{x}{3} − 4\sin^3\frac{x}{3}\)
to reduce the size of the argument of sin. (For purposes of this exercise an
angle is considered “sufficiently small” if its magnitude is not greater than
0.1 radians.) These ideas are incorporated in the following procedures:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))
\end{minted}

How many times is the procedure \texttt{p} applied when \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(sine 12.15)} is evaluated?

\subsection{Answer 1}
\label{sec:orgd4db000}
Let's find out!
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
  (if (not (> (abs angle) 0.1))
      (cons angle 0)
      (let ((x (sine (/ angle 3.0))))
        (cons (p (car x)) (+ 1 (cdr x))))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<1-15-p-measure>>
(let ((xy (sine 12.15)))
  (list (car xy) (cdr xy)))
\end{minted}

\begin{center}
\begin{tabular}{rr}
-0.39980345741334 & 5\\
\end{tabular}
\end{center}

\texttt{p} is evaluated 5 times.

\subsection{Question 2}
\label{sec:org832a9cd}
What is the order of growth in space and number of steps (as a function of \texttt{a})
used by the process generated by the sine procedure when \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(sine a)} is
evaluated?

\subsection{Answer 2}
\label{sec:orgf3543f9}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
<<1-15-p-measure>>
(let* ((vals (iota 300 0.1 0.1))
       (sines (map (λ (i)
                     (cdr (sine i)))
                   vals)))
  (zip vals sines))
\end{minted}
\#+end\textsubscript{src}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
<<1-15-p-measure>>
(let* ((vals (iota 10 0.1 0.1))
       (sines (map (λ (i)
                     (cdr (sine i)))
                   vals)))
  (zip vals sines))
\end{minted}

Example output:
\begin{center}
\begin{tabular}{rr}
0.1 & 0\\
0.2 & 1\\
0.30000000000000004 & 2\\
0.4 & 2\\
0.5 & 2\\
0.6 & 2\\
0.7000000000000001 & 2\\
0.8 & 2\\
0.9 & 2\\
1.0 & 3\\
\end{tabular}
\end{center}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{gnuplot}
reset # helps with various issues in execution
set xlabel 'values of x'
set logscale x
set key top left
set style fill solid 1.00 border
set style function fillsteps below

f(x) = log(x) + 2.3

plot data using 1:2 with fillsteps title 'function calls', \
     data using 1:(f($1)) with lines title 'log(x) + 2. 3'
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{fig/1-15-step.png}
\end{center}

This graph shows that the number of times \texttt{sine} will be called is logarithmic.
\begin{itemize}
\item 0.1 to 0.2 are divided once
\item 0.3 to 0.8 are divided twice
\item 0.9 to 2.6 are divided three times
\item 2.7 to 8 are divided four times
\item 8.5 to 23.8 are divided five times
\end{itemize}

Given that the calls to \texttt{p} get stacked recursively, like this:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(sine 12.15)
(p (sine 4.05))
(p (p (sine 1.35)))
(p (p (p (sine 0.45))))
(p (p (p (p (sine 0.15)))))
(p (p (p (p (p (sine 0.05))))))
(p (p (p (p (p 0.05)))))
(p (p (p (p 0.14950000000000002))))
(p (p (p 0.43513455050000005)))
(p (p 0.9758465331678772))
(p -0.7895631144708228)
-0.39980345741334
\end{minted}

So I argue the space and time is \(\Theta(\log(n))\)


We can also prove this for the time by benchmarking the function:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; This execution takes too long for org-mode, so I'm doing it
;; externally and importing the results
(use-srfis '(1))
(use-modules (ice-9 format))
(load "../../mattbench.scm")
<<1-15-deps>>
(let* ((vals (iota 300 0.1 0.1))
       (times (map (λ (i)
                     (mattbench (λ () (sine i)) 1000000))
                   vals)))
  (with-output-to-file "sine-bench.dat" (λ ()
     (map (λ (x y)
           (format #t "~s~/~s~%" x y))
         vals times))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{gnuplot}
reset # helps with various issues in execution
set xtics 0.5
set xlabel 'values of x'
set logscale x
set key top left
set style fill solid 1.00 border
#set style function fillsteps below

f(x) = (log(x) * a) + b
fit f(x) 'Ex15/sine-bench.dat' using 1:2 via a,b

plot 'Ex15/sine-bench.dat' using 1:2 with fillsteps title 'time to execute', \
     'Ex15/sine-bench.dat' using 1:(f($1)) with lines title sprintf('(log(x) * %.2f) + %.2f', a, b)
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{fig/1-15-bench.png}
\end{center}

\section{Exercise 1.16}
\label{sec:orgf5d1f82}
\subsection{Text}
\label{sec:orgc22699f}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (expt-rec b n)
  (if (= n 0) 
      1 
      (* b (expt-rec b (- n 1)))))

(define (expt-iter b n) 
  (define (iter counter product)
    (if (= counter 0)
        product
        (iter (- counter 1)
              (* b product))))
  (iter n 1))

(define (fast-expt b n)
  (cond ((= n 0) 
         1)
        ((even? n) 
         (square (fast-expt b (/ n 2))))
        (else 
         (* b (fast-expt b (- n 1))))))
\end{minted}
\subsection{Question}
\label{sec:org4025896}
Design a procedure that evolves an iterative exponentiation process that uses
successive squaring and uses a logarithmic number of steps, as does fast-expt.
(Hint: Using the observation that \((b^{n/2})^2=(b^2)^{n/2}\), keep, along with
the exponent \(n\) and the base \(b\), an additional state variable \(a\) , and
define the state transformation in such a way that the product \({ab}^n\) is
unchanged from state to state. At the beginning of the process \(a\) is taken to
be 1, and the answer is given by the value of \(a\) at the end of the process.
In general, the technique of defining an \emph{invariant quantity} that remains
unchanged from state to state is a powerful way to think about the design of
iterative algorithms.)
\subsection{Diary}
\label{sec:org5e52169}
First I made this program which tries to use a false equivalence:
\[ab^2 = (a + 1)b^{n - 1}\]
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
(define (fast-expt-iter b n)
  (define (iter b n a)
    (format #t "~&|~s~/~/|~s~/~/|~s|~%" b n a)
    (cond ((= n 1) (begin (format #t "~&|~s~/~/|~s~/~/|~s|~%" (* b a) 1 1)
                          (* b a)))
          ((even? n) (iter (square b)
                         (/ n 2)
                         a))
          (else (iter b (- n 1) (+ a 1)))))
  (format #t "|~a~/|~a~/|~a|~%" "base" "power" "variable")
  (format #t "~&|--|--|--|~%")
  (iter b n 1))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<fast-expt-iter-fail1>>
<<try-these>>
(fast-expt-iter 2 6)
\end{minted}

Here's what the internal state looks like during \(2^6\) (correct answer is 64):
\begin{center}
\begin{tabular}{rrr}
base & power & variable\\
\hline
2 & 6 & 1\\
4 & 3 & 1\\
4 & 2 & 2\\
16 & 1 & 2\\
32 & 1 & 1\\
\end{tabular}
\end{center}

\subsection{Answer}
\label{sec:orgbaf30fe}
There are two key transforms to a faster algorithm. The first was already shown
in the text:

\[
    ab^n \to a(b^2)^{n/2}
\]

The second which I needed to deduce was this:

\[
    ab^n \to ((a \times b) \times b)^{n - 1}
\]

The solution essentially follows this logic:
\begin{itemize}
\item initialize \(a\) to 1
\item If \(n\) is 1, return \(b * a\)
\item else if \(n\) is even, halve \(n\), square \(b\), and iterate
\item else \(n\) is odd, so subtract 1 from \(n\) and \(a \to a \times b\)
\end{itemize}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
(define (fast-expt-iter b n)
  (define (iter b n a)
    (cond ((= n 1) (* b a))
          ((even? n) (iter (square b)
                         (/ n 2)
                         a))
          (else (iter b (- n 1) (* b a)))))
  (iter b n 1))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<fast-expt-iter>>
<<try-these>>
(try-these (λ(x) (fast-expt-iter 3 x)) (cdr (iota 11)))
\end{minted}

\begin{center}
\begin{tabular}{rr}
1 & 3\\
2 & 9\\
3 & 27\\
4 & 81\\
5 & 243\\
6 & 729\\
7 & 2187\\
8 & 6561\\
9 & 19683\\
10 & 59049\\
\end{tabular}
\end{center}

\section{Exercise 1.17}
\label{sec:orge3bb60b}
\subsection{Question}
\label{sec:org493cfb5}
The exponentiation algorithms in this section are based on performing
exponentiation by means of repeated multiplication. In a similar way, one can
perform integer multiplication by means of repeated addition. The following
multiplication procedure (in which it is assumed that our language can only add,
not multiply) is analogous to the expt procedure:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))
\end{minted}

This algorithm takes a number of steps that is linear in \(b\). Now suppose we
include, together with addition, operations double, which doubles an integer,
and halve, which divides an (even) integer by 2. Using these, design a
multiplication procedure analogous to fast-expt that uses a logarithmic number
of steps.

\subsection{Answer}
\label{sec:orge1c3fd7}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (double x)
  (+ x x))
(define (halve x)
  (/ x 2))
(define (fast-mult-rec a b)
  (cond ((= b 0) 0)
        ((even? b)
         (double (fast-mult-rec a (halve b)))) ; This was kind of a stretch to think of.G
         ;(fast-mult (double a) (halve b))) <== My first instinct is iterative
        (else (+ a (fast-mult-rec a (- b 1))))))
\end{minted}

Proof it works:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<fast-mult-rec>>
<<try-these>>
(try-these (λ(x) (fast-mult-rec 3 x)) (cdr (iota 11)))
\end{minted}

\begin{center}
\begin{tabular}{rr}
1 & 3\\
2 & 6\\
3 & 9\\
4 & 12\\
5 & 15\\
6 & 18\\
7 & 21\\
8 & 24\\
9 & 27\\
10 & 30\\
\end{tabular}
\end{center}

\section{Exercise 1.18}
\label{sec:org251e5d4}
\subsection{Question}
\label{sec:org1202639}
Using the results of \hyperref[sec:orgf5d1f82]{Exercise 1.16} and \hyperref[sec:orge3bb60b]{Exercise 1.17}, devise a procedure that
generates an iterative process for multiplying two integers in terms of adding,
doubling, and halving and uses a logarithmic number of steps.
\subsection{Diary}
\label{sec:org276c075}
\subsubsection{Comparison benchmarks:}
\label{sec:org59175c2}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "../mattbench.scm")
<<fast-mult-iter>>
<<fast-mult-rec>>
<<print-table>>
(print-table (list (list "fast-mult-rec" "fast-mult-iter")
                   (list (mattbench (λ() (fast-mult-rec 32 32)) 10000000)
                         (mattbench (λ() (fast-mult 32 32)) 10000000)))
             #:colnames #t)
\end{minted}

\begin{center}
\begin{tabular}{rr}
``fast-mult-rec'' & ``fast-mult-iter''\\
\hline
196.89 & 166.35\\
\end{tabular}
\end{center}

So the iterative version takes 0.84 times less to do \(32 \times 32\).
\subsubsection{Hall of shame}
\label{sec:org656ff6a}
Some of my \emph{very} incorrect ideas:
\[ab = (a+1)(b-1)\]
\[ab = \big(a+\Big(\frac{a}{2}\Big)(b-1)\big)\]
\[ab+c = \big(a(b-1)+(b+c)\big)\]
\subsection{Answer}
\label{sec:org864e140}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (double x)
  (+ x x))
(define (halve x)
  (/ x 2))
(define (fast-mult a b)
  (define (iter a b c)
    (cond ((= b 0) 0)
          ((= b 1) (+ a c))
          ((even? b)
           (iter (double a) (halve b) c))
          (else (iter a (- b 1) (+ a c)))))
  (iter a b 0))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<fast-mult-iter>>
<<try-these>>
(try-these (λ(x) (fast-mult 3 x)) (cdr (iota 11)))
\end{minted}

\begin{center}
\begin{tabular}{rr}
1 & 3\\
2 & 6\\
3 & 9\\
4 & 12\\
5 & 15\\
6 & 18\\
7 & 21\\
8 & 24\\
9 & 27\\
10 & 30\\
\end{tabular}
\end{center}

\section{Exercise 1.19}
\label{sec:org3c8e5ac}
\subsection{Question}
\label{sec:org090761f}
There is a clever algorithm for computing the Fibonacci numbers in a logarithmic
number of steps. Recall the transformation of the state variables a and b in the
\texttt{fib-iter} process of section 1-2-2:

\[a <- a + b\text{ and }b <- a\]

Call this transformation T, and observe that applying T over and over again n
times, starting with 1 and 0, produces the pair \_Fib\textsubscript{(n + 1)} and \_Fib\textsubscript{(n)}. In
other words, the Fibonacci numbers are produced by applying \(T^n\), the nth
power of the transformation T, starting with the pair (1,0). Now consider T to
be the special case of p = 0 and q = 1 in a family of transformations \(T_{(pq)}\), where \(T_{(pq)}\) transforms the pair (a,b) according to \(a <-
bq + aq + ap\) and \(b <- bp + aq\). Show that if we apply such a
transformation \(T_{(pq)}\) twice, the effect is the same as using a single
transformation \(T_{(p'q')}\) of the same form, and compute p' and q' in terms
of p and q. This gives us an explicit way to square these transformations, and
thus we can compute \(T^n\) using successive squaring, as in the `fast-expt'
procedure. Put this all together to complete the following procedure, which runs
in a logarithmic number of steps:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   <??>      ; compute p'
                   <??>      ; compute q'
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
\end{minted}

\subsection{Diary}
\label{sec:org8b8db08}
More succinctly put:

\[
    \text{Fib}_n \begin{cases}
        a \leftarrow a + b\\
        b \leftarrow a
    \end{cases}
\]
\[
    \text{Fib-iter}_{abpq} \begin{cases}
        a \leftarrow bq + aq + ap\\
        b \leftarrow bp + aq
    \end{cases}
\]

\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(T)} returns a transformation function based on the two numbers in
the attached list. so \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(T 0 1)} returns a fib function.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (T p q)
  (λ (a b)
    (cons (+ (* b q) (* a q) (* a p))
          (+ (* b p) (* a q)))))

(define T-fib
  (T 0 1))

;; Repeatedly apply T functions:
(define (Tr f n)
  (Tr-iter f n 0 1))
(define (Tr-iter f n a b)
  (if (= n 0)
      a
      (let ((l (f a b)))
        (Tr-iter f (- n 1) (car l) (cdr l)))))
\end{minted}

\[
    \text{T}_{pq}: a,b\mapsto \begin{cases}
        a \leftarrow bq + aq + ap\\
        b \leftarrow bp + aq
    \end{cases}
\]

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<T-func>>
<<try-these>>
(try-these (λ (x) (Tr (T 0 1) x)) (cdr (iota 11)))
\end{minted}

\begin{center}
\begin{tabular}{rr}
1 & 1\\
2 & 1\\
3 & 2\\
4 & 3\\
5 & 5\\
6 & 8\\
7 & 13\\
8 & 21\\
9 & 34\\
10 & 55\\
\end{tabular}
\end{center}

\subsection{Answer}
\label{sec:org535ef70}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (fib-rec n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib-rec (- n 1))
                 (fib-rec (- n 2))))))
(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (+ (* p p)
                      (* q q))      ; compute p'
                   (+ (* p q)
                      (* q q)
                      (* q p))      ; compute q'
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
\end{minted}

\begin{center}
\begin{tabular}{rrr}
``n'' & ``fib-rec'' & ``fib-iter''\\
\hline
1 & 1 & 1\\
2 & 1 & 1\\
3 & 2 & 2\\
4 & 3 & 3\\
5 & 5 & 5\\
6 & 8 & 8\\
7 & 13 & 13\\
8 & 21 & 21\\
9 & 34 & 34\\
\end{tabular}
\end{center}
\end{document}
