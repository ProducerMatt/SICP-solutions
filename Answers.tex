% Created 2023-03-30 Thu 22:32
% Intended LaTeX compiler: xelatex
\documentclass[final,fleqn,titlepage,twoside]{article}
\usepackage{titletoc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{fontspec}
\usepackage{calligra}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\setmonofont[Mapping=tex-text,Ligatures=TeX,Scale=MatchLowercase]{Fira Code Regular Nerd Font Complete}
\usepackage[cache=true]{minted}
\usemintedstyle{colorful}
\setminted{fontsize=\small}
\setmintedinline{fontsize=\normalsize,breakbytoken=false,breakbytokenanywhere=false,breaklines=false,breakaftergroup=false}
\usepackage{mdframed}
\definecolor{my-bg}{rgb}{0.99,0.99,0.99}
\definecolor{gray}{rgb}{0.60,0.60,0.60}
\mdfdefinestyle{theoremstyle}{%
linecolor=gray,linewidth=.5pt,%
backgroundcolor=my-bg
}
\usepackage{etoolbox}
\BeforeBeginEnvironment{minted}{\begin{mdframed}[style=theoremstyle]}
\AfterEndEnvironment{minted}{\end{mdframed}}
\listfiles
\setcounter{secnumdepth}{20}
\author{ProducerMatt}
\date{\today}
\title{A Journey Through SICP\\\medskip
\large Notes, exercises and analyses of Abelson and Sussman}
\hypersetup{
 pdfauthor={ProducerMatt},
 pdftitle={A Journey Through SICP},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.2 (Org mode 9.6.1)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Introduction Notes}
\label{sec:orgd03c78a}
\subsection{Text Foreword}
\label{sec:org9db5832}
This book centers on three areas: the human mind, collections of computer
programs, and the computer.

Every program is a model of a real or mental process, and these processes are at
any time only partially understood. We change these programs as our
understandings of these processes evolve.

Ensuring the correctness of programs becomes a Herculean task as complexity
grows. Because of this, it's important to make fundamentals that can be relied
upon to support larger structures.

\subsection{Preface, 1e}
\label{sec:orgc78baaa}
\index{procedural epistemology}
\index{declarative knowledge}
\index{imperative knowledge}

``Computer Science'' isn't really about computers or science, in the same way that
geometry isn't really about measuring the earth ('geometry' translates to
'measurement of earth').

Programming is a medium for expressing ideas about methodology. For this reason,
programs should be written first for people to read, and second for machines to
execute.

The essential material for introductory programming is how to control complexity
when building programs.

Computer Science is about imperative knowledge, as opposed to declarative. This
can be called \emph{procedural epistemology}.

\begin{description}
\item[{\textbf{Declarative knowledge}}] \emph{what is true}. For example: \(\sqrt{x}\) is the
\(y\) such that \(y^2 = x\) and \(y \geq 0\)

\item[{\textbf{Imperative knowledge}}] \emph{How to follow a process}. For example: to find an
approximation to \(\sqrt{x}\), make a guess \(G\), improve the guess by
averaging \(G\) and \(x/G\), keep improving until the guess is good enough.
\end{description}

\begin{enumerate}
\item Techniques for controlling complexity
\label{sec:org8f9de2e}
\begin{description}
\item[{Black-box abstraction}] Encapsulating an operation so the details of it are
irrelevant.

The fixed point of a function \(f()\) is a value \(y\) such that \(f(y) = y\).
Method for finding a fixed point: start with a guess for \(y\) and keep applying
\(f(y)\) over and over until the result doesn't change very much.

Define a box of the method for finding the fixed point of \(f()\).

One way to find \(\sqrt{x}\) is to take our function for approaching a square
root \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(lambda(guess target) (average guess (divide target guess)))}, applying
that to our method for finding a fixed point, and this creates a \textbf{procedure} to
find a square root.

Black-box abstraction
\begin{enumerate}
\item Start with primitive objects of procedures and data.
\item Combination: combine procedures with \emph{composition}, combine data with
\emph{construction} of compound data.
\item Abstraction: defining procedures and abstracting data. Capture common
patterns by making high-order procedures composed of other procedures. Use
data as procedures.
\end{enumerate}

\item[{Conventional interfaces}] Agreed-upon ways of connecting things together.

\begin{itemize}
\item How do you make operations generalized?
\item How do you make large-scale structure and modularity?
\begin{description}
\item[{Object-oriented programming}] thinking of your structure as a society of
discrete but interacting parts.
\item[{Operations on aggregates}] thinking of your structure as operating on a
stream, comparable to signal processing. \emph{(Needs clarification.)}
\end{description}
\end{itemize}

\item[{Metalinguistic abstractions}] Making new languages. This changes the way you
interact with the system by letting you emphasize some parts and deemphasize
other parts.
\end{description}
\end{enumerate}

\section{Chapter 1: Building Abstractions with Procedures}
\label{sec:org8962a33}
\textbf{Computational processes} are abstract 'beings' that inhabit computers. Their
evolution is directed by a pattern of rules called a \textbf{program}, and processes
manipulate other abstract things called \textbf{data}.

Master software engineers are able to organize programs so they can be
reasonably sure the resulting process performs the task intended, without
catastrophic consequences, and that any problems can be debugged.

Lisp's users have traditionally resisted attempts to select an ``official''
version of the language, which has enabled Lisp to continually evolve.

There are powerful program-design techniques which rely on the ability to blur
the distinction between data and processes. Lisp enables these techniques by
allowing processes to be represented and manipulated as data.

\subsection{1.1: The Elements of Programming}
\label{sec:org5594823}
A programming language isn't just a way to instruct a computer -- it's also a
framework for the programmer to organize their ideas. Thus it's important to
consider the means the language provides for combining ideas. Every powerful
language has three mechanisms for this:

\begin{description}
\item[{\textbf{primitive expressions}}] the simplest entities the language is concerned with
\item[{\textbf{means of combination}}] how compound elements can be built from simpler ones
\item[{\textbf{means of abstraction}}] how which compound elements can be named and
manipulated as units
\end{description}

In programming, we deal with \textbf{data} which is what we want to manipulate, and
\textbf{procedures} which are descriptions of the rules for manipulating the data.

A procedure has \textbf{formal parameters}. When the procedure is applied, the formal
parameters are replaced by the \textbf{arguments} it is being applied to. For example,
take the following code:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (square x)
  (* x x))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
(square 5)
\end{minted}

\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{x} is the formal parameter and  \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{5} is the argument.

\subsection{1.1.1: Expressions}
\label{sec:org3c67918}
The general form of Lisp is evaluating \textbf{combinations}, denoted by parenthesis,
in the form \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(operator operands)}, where \emph{operator} is a procedure and
\emph{operands} are the 0 or more arguments to the operator.

Lisp uses \textbf{prefix notation}, which is not customary mathematical notation, but
provides several advantages.
\begin{enumerate}
\item It supports procedures that take arbitrary numbers of arguments,
i.e.Â \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(+ 1 2 3 4 5)}.
\item It's straightforward to nest combinations in other combinations.
\end{enumerate}

\subsection{1.1.3: Evaluating Combinations}
\label{sec:orgec0aba4}
The evaluator can evaluate nested expressions recursively. \textbf{Tree accumulation}
is the process of evaluating nested combinations, ``percolating'' values upward.

The recursive evaluation of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(* (+ 2 (* 4 6)) (+ 3 5 7))} breaks down
into four parts:

\begin{center}
\includegraphics[width=.9\linewidth]{1/fig/t_1-1-3.png}
\end{center}

\subsection{1.1.4: Compound Procedures}
\label{sec:orgc231c98}
We have identified the following in Lisp:
\begin{itemize}
\item primitive data are numbers, primitive procedures are arithmetic operations
\item Operations can be combined by nesting combinations
\item Data and procedures can be abstracted by variable \& procedure definitions
\end{itemize}

Procedure definitions give a name to a compound procedure.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (square x) (* x x)) ; to square something, multiply it by itself
; now it can be applied or used in other definitions:
(square 4) ; => 16

(define (sum-of-squares x y)
  (+ (square x) (square y)))
(sum-of-squares 3 4) ; => 25
\end{minted}

Note how these compound procedures are used in the same way as primitive
procedures.

\subsection{1.1.5: The Substitution Model for Procedure Application}
\label{sec:org39b56ff}
To understand how the interpreter works, imagine it substituting the procedure
calls with the bodies of the procedure and its arguments.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(* (square 3) (square 4))
; has the same results as
(* (* 3 3) (* 3 3))
\end{minted}

This way of understanding procedure application is called the \textbf{substitution
model}. This model is to help you understand procedure substitution, and is
usually not how the interpreter actually works. This book will progress through
more intricate models of interpreters as it goes. This is the natural
progression when learning scientific phenomena, starting with a simple model,
and replace it with more refined models as the phenomena is examined in more
detail.

Evaluations can be done in different orders.

\begin{description}
\item[{\textbf{Applicative order}}] evaluates the operator and operands, and then applies the
\end{description}
resulting procedure to the resulting arguments. In other words, reducing, then
expanding, then reducing.

\begin{description}
\item[{\textbf{Normal order}}] substitutes expressions until it obtains an expression involving
\end{description}
only primitive operators, or until it can't substitute any further, and then
evaluates. This results in expanding the expression completely before doing any
reduction, which results in some repeated evaluations.

For all procedure applications that can be modeled using substitution,
applicative and normal order evaluation produce the same result. Normal order
becomes more complicated once dealing with procedures that can't be modeled by
substitution.

Lisp uses applicative order evaluation because it helps avoid repeated work and
other complications. But normal has its own advantages which will be explored in
Chapter 3 and 4.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
; Applicative evaluation
(f 5)
(sum-of-squares (+ a 1) (* a 2))
(sum-of-squares (+ 5 1) (* 5 2))
(sum-of-squares 6 10)
(+ (square x)(square y))
(+ (square 6)(square 10))
(+ (* 6 6)(* 10 10))
(+ 36 100)
136
; Normal evaluation
(f 5)
(sum-of-squares (+ a 1) (* a 2))
(sum-of-squares (+ 5 1) (* 5 2))
(+ (square (+ 5 1)) (square (* 5 2)))
(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))
(+ (* 6 6) (* 10 10))
(+ 36 100)
136
\end{minted}

(Extra-curricular clarification: Normal order delays evaluating arguments until
they're needed by a procedure, which is called lazy evaluation.)

\subsection{1.1.6: Conditional Expressions and Predicates}
\label{sec:org0d5229d}
An important aspect of programming is testing and branching depending on the
results of the test. \texttt{cond} tests \textbf{predicates}, and upon encountering one,
returns a \textbf{consequent}.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(cond
     (predicate1 consequent1)
     ...
     (predicateN consequentN))
\end{minted}

A shorter form of conditional:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(if predicate consequent alternative)
\end{minted}

If \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{predicate} is true, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{consequent} is returned. Else,
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{alternative} is returned.

Combining predicates:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(and expression1 ... expressionN)
; if encounters false, stop eval and returns false.
(or expression1 ... expressionN)
; if encounters true, stop eval and return true. Else false.
(not expression)
; true is expression is false, false if expression is true.
\end{minted}

A small clarification:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define A (* 5 5))
(define (D) (* 5 5))
A ; => 25
D ; => compound procedure D
(D) ; => 25 (result of executing procedure D)
\end{minted}

Special forms bring more nuances into the substitution model mentioned
previously. For example, when evaluating an \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{if} expression, you
evaluate the predicate and, depending on the result, either evaluate the
\textbf{consequent} or the \textbf{alternative}. If you were evaluating in a standard manner,
the consequent and alternative would both be evaluated, rendering the
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{if} expression ineffective.

\subsection{Exercise 1.1: Trying expressions}
\label{sec:org2531ebb}
\subsubsection{Question}
\label{sec:orgd5be737}
Below is a sequence of expressions. What is the result printed by the
interpreter in response to each expression? Assume that the sequence is to be
evaluated in the order in which it is presented.


\subsubsection{Answer}
\label{sec:org87b5f4d}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
10 ;; 10
(+ 5 3 4) ;; 12
(- 9 1) ;; 8
(/ 6 2) ;; 3
(+ (* 2 4) (- 4 6)) ;; 6
(define a 3) ;; a=3
(define b (+ a 1)) ;; b=4
(+ a b (* a b)) ;; 19
(= a b) ;; false
(if (and (> b a) (< b (* a b)))
    b
    a) ;; 4
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25)) ;; 16
(+ 2 (if (> b a) b a)) ;; 6
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1)) ;; 16
\end{minted}

\subsection{Exercise 1.2: Prefix form}
\label{sec:orgb06463a}
\subsubsection{Question}
\label{sec:orgb7da1eb}
Translate the following expression into prefix form:
\[
  \frac{5 + 2 + (2 - 3 - (6 + \frac{4}{5})))}
            {3(6 - 2)(2 - 7)}
\]


\subsubsection{Answer}
\label{sec:org42a275b}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(/ (+ 5 2 (- 2 3 (+ 6 (/ 4 5))))
   (* 3 (- 6 2) (- 2 7)))
\end{minted}

\begin{verbatim}
1/75
\end{verbatim}

\subsection{Exercise 1.3: Conditionals}
\label{sec:orgb5bf3d9}
\subsubsection{Question}
\label{sec:org309078b}
Define a procedure that takes three numbers as arguments and
returns the sum of the squares of the two larger numbers.

\subsubsection{Answer}
\label{sec:org711472c}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
(define (sum-square x y)
  (+ (square x) (square y)))
(define (square-2of3 a b c)
  (cond ((and (>= a b) (>= b c)) (sum-square a b))
        ((and (>= a b) (> c b)) (sum-square a c))
        (else (sum-square b c))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<EX1-3>>
<<try-these>>
 (try-these square-2of3 '(7 5 3)
                        '(7 3 5)
                        '(3 5 7))
\end{minted}

\begin{center}
\begin{tabular}{lr}
(7 5 3) & 74\\[0pt]
(7 3 5) & 74\\[0pt]
(3 5 7) & 74\\[0pt]
\end{tabular}
\end{center}

\subsection{Exercise 1.4: Compound expressions}
\label{sec:orgbb5eeef}
\subsubsection{Question}
\label{sec:org58e6b43}
Observe that our model of evaluation allows for combinations whose operators are
compound expressions. Use this observation to describe the behavior of the
following procedure:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
\end{minted}

\subsubsection{Answer}
\label{sec:orga450331}
This code accepts the variables \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{a} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{b}, and if
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{b} is positive, it adds \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{a} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{b}. However, if
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{b} is zero or negative, it subtracts them. This decision is made by
using the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{+} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{-} procedures as the results of an if
expression, and then evaluating according to the results of that expression.
This is in contrast to a language like Python, which would do something like
this:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{python}
if b > 0: a + b
else: a - b
\end{minted}

\subsection{Exercise 1.5: Applicative vs normal-order evaluation}
\label{sec:orge310715}
\subsubsection{Question}
\label{sec:orgc2d97e5}
Ben Bitdiddle has invented a test to determine whether the interpreter he is
faced with is using applicative-order evaluation or normal-order evaluation. He
defines the following two procedures:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
\end{minted}

Then he evaluates the expression:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(test 0 (p))
\end{minted}

What behavior will Ben observe with an interpreter that uses applicative-order
evaluation?  What behavior will he observe with an interpreter that uses
normal-order evaluation?  Explain your answer.  (Assume that the evaluation
rule for the special form \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{if} is the same whether the interpreter is
using normal or applicative order: The predicate expression is evaluated first,
and the result determines whether to evaluate the consequent or the alternative
expression.)

\subsubsection{Answer}
\label{sec:org42f9f70}
In either type of language, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(define (p) (p))} is an infinite loop.
However, a normal-order language will encounter the special form, return
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{0}, and never evaluate \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(p)}. An applicative-order language
evaluates the arguments to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(test 0 (p))}, thus triggering the
infinite loop.

\subsection{1.1.7: Example: Square Roots by Newton's Method}
\label{sec:org5847173}
Functions in the formal mathematical sense are \textbf{declarative knowledge}, while
procedures like in computer science are \textbf{imperative knowledge}.

Notice that the elements of the language that have been introduced so far are
sufficient for writing any purely numerical program, despite not having
introduced any looping constructs like \texttt{FOR} loops.

\subsection{1.1.8: Procedures as Black-Box Abstractions}
\label{sec:orgb93f5fa}
Notice how the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{sqrt} procedure is divided into other procedures,
which mirror the division of the square root problem into sub problems.

A procedure should accomplish an identifiable task, and be ready to be used as a
module in defining other procedures. This lets the programmer know how to use
the procedure while not needing to know the details of how it works.

Suppressing these details are particularly helpful:
\begin{description}
\item[{Local names.}] A procedure user shouldn't need to know a procedure's choices
of variable names. A formal parameter of a procedure whose name is irrelevant
is called a \textbf{bound variable}. A procedure definition \textbf{binds} its parameters. A
\textbf{free variable} isn't bound. The set of expressions in which a binding defines
a name is the \textbf{scope} of that name.
\item[{Internal definitions and block structure.}] By nesting relevant definitions
inside other procedures, you hide them from the global namespace. This nesting
is called \textbf{block structure}. Nesting these definitions also allows relevant
variables to be shared across procedures, which is called \textbf{lexical scoping}.
\end{description}

\subsection{Exercise 1.6: Special form evaluation}
\label{sec:org51c850c}
\subsubsection{Text code}
\label{sec:org06e5fd8}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (abs x)
  (if (< x 0)
      (- x)
      x))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (average x y)
  (/ (+ x y) 2))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<average>>
(define (improve guess x)
  (average guess (/ x guess)))

<<square>>
<<abs>>
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))

(define (sqrt x)
  (sqrt-iter 1.0 x))
\end{minted}

\subsubsection{Question}
\label{sec:org1798564}
Alyssa P. Hacker doesn't see why \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{if} needs to be provided as a
special form. ``Why can't I just define it as an ordinary procedure in terms of
cond?'' she asks. Alyssa's friend Eva Lu Ator claims this can indeed be done, and
she defines a new version of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{if}:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (new-if predicate
                then-clause
                else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
\end{minted}

Eva demonstrates the program for Alyssa:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(new-if (= 2 3) 0 5)
;; => 5

(new-if (= 1 1) 0 5)
;; => 0
\end{minted}

Delighted, Alyssa uses \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{new-if} to rewrite the square-root program:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))
\end{minted}

What happens when Alyssa attempts to use this to compute square roots? Explain.

\subsubsection{Answer}
\label{sec:org6a59082}
Using Alyssa's \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{new-if} leads to an infinite loop because the
recursive call to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{sqrt-iter} is evaluated before the actual call to
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{new-if}. This is because \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{if} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cond} are
special forms that change the way evaluation is handled; whichever branch is
chosen leaves the other branches unevaluated.

\subsection{Exercise 1.7: \texttt{sqrt} with small and large numbers}
\label{sec:org9243f23}
\subsubsection{Text}
\label{sec:orgb4501a3}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (mean-square x y)
  (average (square x) (square y)))
\end{minted}

\subsubsection{Question}
\label{sec:orgf0fd211}
The \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{good-enough?} test used in computing square roots will not be
very effective for finding the square roots of very small numbers. Also, in real
computers, arithmetic operations are almost always performed with limited
precision. This makes our test inadequate for very large numbers. Explain these
statements, with examples showing how the test fails for small and large
numbers. An alternative strategy for implementing \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{good-enough?} is to
watch how \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{guess} changes from one iteration to the next and to stop
when the change is a very small fraction of the guess. Design a square-root
procedure that uses this kind of end test. Does this work better for small and
large numbers?

\subsubsection{Diary}
\label{sec:orgef5c123}
\begin{enumerate}
\item Solving
\label{sec:orgfc79353}
My original answer was this, which compares the previous iteration until the new
and old are within an arbitrary \(dx\).

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<txt-sqrt>>
(define (inferior-good-enough? guess lastguess)
  (<=
   (abs (-
         (/ lastguess guess)
         1))
   0.0000000000001)) ; dx
(define (new-sqrt-iter guess x lastguess) ;; Memory of previous value
  (if (inferior-good-enough? guess lastguess)
      guess
      (new-sqrt-iter (improve guess x) x guess)))
(define (new-sqrt x)
  (new-sqrt-iter 1.0 x 0))
\end{minted}

This solution can correctly find small and large numbers:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<inferior-good-enough>>
(new-sqrt 10000000000000)
\end{minted}

\begin{verbatim}
3162277.6601683795
\end{verbatim}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<try-these>>
<<inferior-good-enough>>
(try-these new-sqrt '(0.01 0.0001 0.000001 0.00000001 0.0000000001))
\end{minted}

\begin{center}
\begin{tabular}{rr}
0.01 & 0.1\\[0pt]
0.0001 & 0.01\\[0pt]
1e-06 & 0.001\\[0pt]
1e-08 & 9.999999999999999e-05\\[0pt]
1e-10 & 9.999999999999999e-06\\[0pt]
\end{tabular}
\end{center}


However, I found this solution online that isn't just simpler but automatically
reaches the precision limit of the system:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<txt-sqrt>>
(define (best-good-enough? guess x)
   (= (improve guess x) guess))
\end{minted}

\item Imroving \texttt{sqrt} by avoiding extra \texttt{improve} call
\label{sec:org39dfa11}
\begin{enumerate}
\item Non-optimized
\label{sec:org2f56043}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-modules (ice-9 format))
(load "../mattbench.scm")
(define (average x y)
  (/ (+ x y) 2))
(define (improve guess x)
  (average guess (/ x guess)))
(define (good-enough? guess x)
   (= (improve guess x) guess)) ;; improve call 1
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x))) ;; call 2
(define (sqrt x)
  (sqrt-iter 1.0 x))
(newline)
(display (mattbench (lambda() (sqrt 69420)) 400000000))
(newline)
;; 4731.30 <- Benchmark results
\end{minted}

\item Optimized
\label{sec:org79d494a}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-modules (ice-9 format))
(load "../mattbench.scm")
(define (average x y)
  (/ (+ x y) 2))
(define (improve guess x)
  (average guess (/ x guess)))
(define (good-enough? guess nextguess x)
  (= nextguess guess))
(define (sqrt-iter guess x)
  (let ((nextguess (improve guess x)))
    (if (good-enough? guess nextguess x)
        guess
        (sqrt-iter nextguess x))))
(define (sqrt x)
  (sqrt-iter 1.0 x))
(newline)
(display (mattbench (lambda() (sqrt 69420)) 400000000))
(newline)
\end{minted}

\item Benchmark results
\label{sec:orgf68aaef}
\begin{center}
\begin{tabular}{lr}
Unoptimized & 4731.30\\[0pt]
Optimized & 2518.44\\[0pt]
\end{tabular}
\end{center}
\end{enumerate}
\end{enumerate}

\subsubsection{Answer}
\label{sec:org8ebfafe}
The current method has decreasing accuracy with smaller numbers. Notice the
steady divergence from correct answers here (should be decreasing powers of
0.1):
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<txt-sqrt>>
<<try-these>>
(try-these sqrt 0.01 0.0001 0.000001 0.00000001 0.0000000001)
\end{minted}

\begin{center}
\begin{tabular}{rr}
0.01 & 0.10032578510960605\\[0pt]
0.0001 & 0.03230844833048122\\[0pt]
1e-06 & 0.031260655525445276\\[0pt]
1e-08 & 0.03125010656242753\\[0pt]
1e-10 & 0.03125000106562499\\[0pt]
\end{tabular}
\end{center}

And for larger numbers, an infinite loop will eventually be reached. \(10^{12}\)
can resolve, but \(10^{13}\) cannot.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<txt-sqrt>>
(sqrt 1000000000000)
\end{minted}

\begin{verbatim}
1000000.0
\end{verbatim}

So, my definition of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{sqrt}:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<average>>
(define (improve guess x)
  (average guess (/ x guess)))
(define (good-enough? guess x)
   (= (improve guess x) guess))
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
(define (sqrt x)
  (sqrt-iter 1.0 x))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<try-these>>
<<sqrt>>
(try-these sqrt '(0.01 0.0001 0.000001 0.00000001 0.0000000001))
\end{minted}

\begin{center}
\begin{tabular}{rr}
0.01 & 0.1\\[0pt]
0.0001 & 0.01\\[0pt]
1e-06 & 0.001\\[0pt]
1e-08 & 9.999999999999999e-05\\[0pt]
1e-10 & 9.999999999999999e-06\\[0pt]
\end{tabular}
\end{center}

\subsection{Exercise 1.8: Cube roots}
\label{sec:org0503efc}
\subsubsection{Question}
\label{sec:org05c3658}
Newton's method for cube roots is based on the fact that if \(y\) is an
approximation to the cube root of \(x\), then a better approximation is given by
the value

\[
\frac{\frac{x}{y^2} + 2y}{3}
\]

Use this formula to implement a cube-root procedure analogous to the
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{square-root} procedure. (In \hyperref[sec:orgda8f430]{1.3.4 Procedures as Returned Values} we
will see how to implement Newton's method in general as an abstraction of these
square-root and cube-root procedures.)

\subsubsection{Diary}
\label{sec:orgb63ca58}
My first attempt works, but needs an arbitrary limit to stop infinite loops:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
<<try-these>>
(define (cb-good-enough? guess x)
  (= (cb-improve guess x) guess))
(define (cb-improve guess x)
  (/
   (+
    (/ x (square guess))
    (* guess 2))
   3))
(define (cbrt-iter guess x counter)
  (if (or (cb-good-enough? guess x) (> counter 100))
      guess
      (begin
        (cbrt-iter (cb-improve guess x) x (+ 1 counter)))))
(define (cbrt x)
  (cbrt-iter 1.0 x 0))

(try-these cbrt 7 32 56 100)
\end{minted}

\begin{center}
\begin{tabular}{rr}
7 & 1.912931182772389\\[0pt]
32 & 3.174802103936399\\[0pt]
56 & 3.825862365544778\\[0pt]
100 & 4.641588833612779\\[0pt]
\end{tabular}
\end{center}

However, this will hang on an infinite loop when trying to run \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(cbrt 100)}. I speculate it's a floating point precision issue with the ``improve''
algorithm. So to avoid it I'll just keep track of the last guess and stop
improving when there's no more change occurring. Also while researching I
discovered that (again due to floating point) \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(cbrt -2)} loops
forever unless you initialize your guess with a slightly different value, so
let's do 1.1 instead.

\subsubsection{Answer}
\label{sec:orgdd46723}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
(define (cb-good-enough? nextguess guess lastguess x)
  (or (= nextguess guess)
      (= nextguess lastguess)))
(define (cb-improve guess x)
  (/
   (+
    (/ x (square guess))
    (* guess 2))
   3))
(define (cbrt-iter guess lastguess x)
  (define nextguess (cb-improve guess x))
  (if (cb-good-enough? nextguess guess lastguess x)
      nextguess
      (cbrt-iter nextguess guess x)))
(define (cbrt x)
  (cbrt-iter 1.1 9999 x))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<cbrt>>
<<try-these>>
(try-these cbrt 7 32 56 100 -2)
\end{minted}

\begin{center}
\begin{tabular}{rr}
7 & 1.912931182772389\\[0pt]
32 & 3.174802103936399\\[0pt]
56 & 3.825862365544778\\[0pt]
100 & 4.641588833612779\\[0pt]
-2 & -1.2599210498948732\\[0pt]
\end{tabular}
\end{center}

\subsection{1.2: Procedures and the Processes They Generate}
\label{sec:orgadb8cb0}
Procedures define the \textbf{local evolution} of processes. We would like to be able
to make statements about the \textbf{global} behavior of a process.

\subsection{1.2.1: Linear Recursion and Iteration}
\label{sec:org396316d}
Consider these two procedures for obtaining factorials:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (factorial-recursion n)
  (if (= n 1)
      1
      (* n 
         (factorial-recursion (- n 1)))))

(define (factorial-iteration n)
  (define (fact-iter product counter max-count)
      (if (> counter max-count)
          product
          (fact-iter
                    (* counter product)
                    (+ counter 1)
                    max-count)))
  
  (fact-iter 1 1 n))
\end{minted}

These two procedures reach the same answers, but form very different processes.
The \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{factorial-recursion} version takes more computational \textbf{time} and
\textbf{space} to evaluate, by building up a chain of deferred operations. This is a
\textbf{recursive process}. As the number of steps needed to operate, and the amount of
info needed to keep track of these operations, both grow linearly with \(n\),
this is a \textbf{linear recursive process}.

The second version forms an \textbf{iterative process}. Its state can be summarized
with a fixed number of state variables. The number of steps required grow
linearly with \(n\), so this is a \textbf{linear iterative process}.

\begin{description}
\item[{recursive procedure}] is a procedure whose definition refers to itself.
\item[{recursive process}] is a process that evolves recursively.
\end{description}

So \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{fact-iter} is a recursive \emph{procedure} that generates an iterative
\emph{process}.

Many implementations of programming languages interpret all recursive procedures
in a way that consume memory that grows with the number of procedure calls, even
when the process is essentially iterative. These languages instead use looping
constructs such as \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{do}, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{repeat}, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{for}, etc.
Implementations that execute iterative processes in constant space, even if the
procedure is recursive, are \textbf{tail-recursive}.

\subsection{Exercise 1.9: Peano counting and recursion}
\label{sec:org9d7e08a}
\subsubsection{Question}
\label{sec:org7c5c246}
Each of the following two procedures defines a method for adding two positive
integers in terms of the procedures \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{inc}, which increments its
argument by 1, and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{dec}, which decrements its argument by 1.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
\end{minted}

Using the substitution model, illustrate the process generated by each procedure
in evaluating \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(+ 4 5)}. Are these processes iterative or recursive?

\subsubsection{Answer}
\label{sec:org2a7df86}
The first procedure is recursive, while the second is iterative though
tail-recursion.

\begin{enumerate}
\item recursive procedure
\label{sec:org8925f15}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
\end{minted}

\item iterative procedure
\label{sec:orgb6d696c}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
\end{minted}
\end{enumerate}

\subsection{Exercise 1.10: Ackermann's Function}
\label{sec:org1737b78}
\subsubsection{Question}
\label{sec:orge5b3db1}
The following procedure computes a mathematical function called Ackermann's
function.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
\end{minted}

What are the values of the following expressions?

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(A 1 10)
(A 2 4)
(A 3 3)
\end{minted}
\begin{center}
\begin{tabular}{lr}
(1 10) & 1024\\[0pt]
(2 4) & 65536\\[0pt]
(3 3) & 65536\\[0pt]
\end{tabular}
\end{center}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<ackermann>>
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
\end{minted}

Give concise mathematical definitions for the functions computed by the
procedures \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{f}, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{g}, and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{h} for positive integer
values of \(n\). For example, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(k n)} computes \(5n^2\).

\subsubsection{Answer}
\label{sec:org9846e10}
\begin{enumerate}
\item \texttt{f}
\label{sec:org5e7d167}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<try-these>>
<<EX1-10-defs>>
(try-these f 1 2 3 10 15 20)
\end{minted}

\begin{center}
\begin{tabular}{rr}
1 & 2\\[0pt]
2 & 4\\[0pt]
3 & 6\\[0pt]
10 & 20\\[0pt]
15 & 30\\[0pt]
20 & 40\\[0pt]
\end{tabular}
\end{center}

\[
f(n)=2n
\]

\item \texttt{g}
\label{sec:org2edf455}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<try-these>>
<<EX1-10-defs>>
(try-these g 1 2 3 4 5 6 7 8)
\end{minted}

\begin{center}
\begin{tabular}{rr}
1 & 2\\[0pt]
2 & 4\\[0pt]
3 & 8\\[0pt]
4 & 16\\[0pt]
5 & 32\\[0pt]
6 & 64\\[0pt]
7 & 128\\[0pt]
8 & 256\\[0pt]
\end{tabular}
\end{center}

\[
g(n)=2^n
\]

\item \texttt{h}
\label{sec:org0756000}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<try-these>>
<<EX1-10-defs>>
(try-these h 1 2 3 4)
\end{minted}

\begin{center}
\begin{tabular}{rr}
1 & 2\\[0pt]
2 & 4\\[0pt]
3 & 16\\[0pt]
4 & 65536\\[0pt]
\end{tabular}
\end{center}

It took a while to figure this one out, just because I didn't know the term.
This is repeated exponentiation. This operation is to exponentiation, what
exponentiation is to multiplication. It's called either \emph{tetration} or \emph{hyper-4}
and has no formal notation, but two common ways would be these:

\[
h(n)=2 \uparrow\uparrow n
\]
\[
h(n)={}^{n}2
\]
\end{enumerate}

\subsection{1.2.2: Tree Recursion}
\label{sec:org14a9342}
Consider a recursive procedure for computing Fibonacci numbers:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
\end{minted}

The resulting process splits into two with every iteration, creating a tree of
computations, many of which are duplicates of previous computations. This kind
of pattern is called \textbf{tree-recursion}. However, this one is quite inefficient.
The time and space required grows exponentially with the number of iterations
requested.

Instead, it makes much more sense to start from \texttt{Fib(1) \textasciitilde{} 1} and \texttt{Fib(0) \textasciitilde{} 0}
and iterate upwards to the desired value. This only requires a linear number of
steps relative to the input.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (fib n)
  (fib-iter 1 0 n))
(define (fib-iter a b count)
  (if (= count 0) b (fib-iter (+ a b) a (- count 1))))
\end{minted}

However, notice that the inefficient tree-recursive version is a fairly
straightforward translation of the Fibonacci sequence's definition, while the
iterative version required redefining the process as an iteration with three
variables.

\subsubsection{Example: Counting change}
\label{sec:org1ac6d2a}
I should come back and try to make the ``better algorithm'' suggested.

\subsection{Exercise 1.11: More recursion vs iteration}
\label{sec:org8dfcbf2}
\subsubsection{Question}
\label{sec:org7e5cbfd}
A function \(f\) is defined by the rule that:
\[
f(n)=n \text{ if } n<3
\]
\[
\text{ and }
\]
\[
f(n)=f(n-1)+2f(n-2)+3f(n-3) \text{ if } n \geq 3
\]

Write a procedure that computes \(f\) by means of a recursive process. Write a
procedure that computes \(f\) by means of an iterative process.

\subsubsection{Answer}
\label{sec:org5aa2876}
\begin{enumerate}
\item Recursive
\label{sec:org44ef941}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (fr n)
  (if (< n 3)
      n
      (+      (fr (- n 1))
         (* 2 (fr (- n 2)))
         (* 3 (fr (- n 3))))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<try-these>>
<<EX1-11-fr>>
(try-these fr 1 3 5 10)
\end{minted}

\begin{center}
\begin{tabular}{rr}
1 & 1\\[0pt]
3 & 4\\[0pt]
5 & 25\\[0pt]
10 & 1892\\[0pt]
\end{tabular}
\end{center}

\item Iterative
\label{sec:orgfb7acdf}
\begin{enumerate}
\item Attempt 1
\label{sec:org9152a3f}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; This seems like it could be better
(define (fi n)
  (define (formula l)
    (let ((a (car l))
           (b (cadr l))
           (c (caddr l)))
      (+ a
         (* 2 b)
         (* 3 c))))
  (define (iter l i)
    (if (= i n)
        (car l)
        (iter (cons (formula l) l)
              (+ 1 i))))
  (if (< n 3)
      n
      (iter '(2 1 0) 2)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<try-these>>
<<EX1-11-fi>>
(try-these fi 1 3 5 10)
\end{minted}

\begin{center}
\begin{tabular}{rr}
1 & 1\\[0pt]
3 & 4\\[0pt]
5 & 25\\[0pt]
10 & 1892\\[0pt]
\end{tabular}
\end{center}

It works but it seems wasteful.

\item Attempt 2
\label{sec:org024546f}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (fi2 n)
  (define (formula a b c)
      (+ a
         (* 2 b)
         (* 3 c)))
  (define (iter a b c i)
    (if (= i n)
        a
        (iter (formula a b c)
              a
              b
              (+ 1 i))))
  (if (< n 3)
      n
      (iter 2 1 0 2)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<try-these>>
<<EX1-11-fi2>>
(try-these fi2 1 3 5 10)
\end{minted}

\begin{center}
\begin{tabular}{rr}
1 & 1\\[0pt]
3 & 4\\[0pt]
5 & 25\\[0pt]
10 & 1892\\[0pt]
\end{tabular}
\end{center}

I like that better.
\end{enumerate}
\end{enumerate}

\subsection{Exercise 1.12: Pascal's Triangle}
\label{sec:orge953811}
\subsubsection{Question}
\label{sec:org47ba487}
The following pattern of numbers is called Pascal's triangle.

\begin{verbatim}
        1
      1   1
    1   2   1
  1   3   3   1
1   4   6   4   1
      . . .
\end{verbatim}

The numbers at the edge of the triangle are all 1, and each number inside the
triangle is the sum of the two numbers above it. Write a procedure that
computes elements of Pascal's triangle by means of a recursive process.

\subsubsection{Answer}
\label{sec:org3a21113}
I guess I'll rotate the triangle 45 degrees to make it the corner of an
infinite spreadsheet.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (pascal x y)
  (if (or (= x 0)
          (= y 0))
      1
      (+ (pascal (- x 1) y)
         (pascal x (- y 1)))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<try-these>>
<<pascal-rec>>
(let ((l (iota 8)))
  (map (lambda (row)
         (map (lambda (xy)
                (apply pascal xy))
              row))
       (map (lambda (x)
              (map (lambda (y)
                     (list x y))
                   l))
            l)))
\end{minted}

\begin{center}
\begin{tabular}{rrrrrrrr}
1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\[0pt]
1 & 2 & 3 & 4 & 5 & 6 & 7 & 8\\[0pt]
1 & 3 & 6 & 10 & 15 & 21 & 28 & 36\\[0pt]
1 & 4 & 10 & 20 & 35 & 56 & 84 & 120\\[0pt]
1 & 5 & 15 & 35 & 70 & 126 & 210 & 330\\[0pt]
1 & 6 & 21 & 56 & 126 & 252 & 462 & 792\\[0pt]
1 & 7 & 28 & 84 & 210 & 462 & 924 & 1716\\[0pt]
1 & 8 & 36 & 120 & 330 & 792 & 1716 & 3432\\[0pt]
\end{tabular}
\end{center}

The test code was much harder to write than the actual solution.

\subsection{Exercise 1.13: Proving Fibonacci approximation\hfill{}\textsc{optional}}
\label{sec:orgca16e01}
\subsubsection{Question}
\label{sec:org12e9818}
Prove that \(\text{Fib}(n)\) is the closest integer to
\(\frac\Phi^n}{\sqrt{5}}\) where \(\Phi\) is \(\frac{1 + \sqrt{5}}{2}\). Hint: let
\(\Upsilon = \frac{1 - \sqrt{5}}{2}\). Use induction and the definition of the
Fibonacci numbers to prove that

\[
 \text{Fib}(n) = \frac{\Phi^n - \Upsilon^n}{\sqrt{5}}
\]

\subsubsection{Answer}
\label{sec:orgf3e7a16}
I don't know how to write a proof yet, but I can make functions to
demonstrate it.

\begin{enumerate}
\item Fibonacci number generator
\label{sec:org3163f82}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (fib-iter n)
  (define (iter i a b)
    (if (= i n)
        b
    (iter (+ i 1)
          b
          (+ a b))))
  (if (<= n 2)
      1
      (iter 2 1 1)))
\end{minted}

\item Various algorithms relating to the question
\label{sec:orgab9f359}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<sqrt>>
(define sqrt5
  (sqrt 5))
(define phi
  (/ (+ 1 sqrt5) 2))
(define upsilon
  (/ (- 1 sqrt5) 2))
(define (fib-phi n)
  (/ (- (expt phi n)
        (expt upsilon n))
     sqrt5))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
<<fib-iter>>
<<fib-phi>>
<<try-these>>

(let* ((vals (drop (iota 21) 10))
       (fibs (map fib-iter vals))
       (approx (map fib-phi vals)))
  (zip vals fibs approx))
\end{minted}

\begin{center}
\begin{tabular}{rrr}
10 & 55 & 54.99999999999999\\[0pt]
11 & 89 & 89.0\\[0pt]
12 & 144 & 143.99999999999997\\[0pt]
13 & 233 & 232.99999999999994\\[0pt]
14 & 377 & 377.00000000000006\\[0pt]
15 & 610 & 610.0\\[0pt]
16 & 987 & 986.9999999999998\\[0pt]
17 & 1597 & 1596.9999999999998\\[0pt]
18 & 2584 & 2584.0\\[0pt]
19 & 4181 & 4181.0\\[0pt]
20 & 6765 & 6764.999999999999\\[0pt]
\end{tabular}
\end{center}

You can see they follow closely. Graphing the differences, it's just
an exponential curve at very low values, presumably following the
exponential increase of the Fibonacci sequence itself.
\begin{center}
\includegraphics[width=.9\linewidth]{1/fig/1-13.png}
\end{center}
\end{enumerate}

\subsection{1.2.3: Orders of Growth}
\label{sec:orgffcf4b4}
An \textbf{order of growth} gives you a gross measure of the resources required by a
process as its inputs grow larger.

Let \(n\) be a parameter for the size of a problem, and \(R(n)\) be the amount
of resources required for size \(n\). \(R(n)\) has order of growth
\(\Theta(f(n))\)

For example:
\begin{description}
\item[{\(\Theta(1)\)}] is constant, not growing regardless of input size.
\item[{\(\Theta(n)\)}] is growth 1-to-1 proportional to the input size.
\end{description}

Some algorithms we've already seen:
\begin{description}
\item[{Linear recursive}] is time and space \(\Theta(n)\)
\item[{Iterative}] is time \(\Theta(n)\) space \(\Theta(1)\)
\item[{Tree-recursive}] means in general, time is proportional to the number of
nodes, space is proportional to the depth of the tree. In the Fibonacci
algorithm example, \(\Theta(n)\) and time \(\Theta(\Upsilon^{n})\) where
\(\Upsilon\) is the golden ratio \(\frac{1 + \sqrt{5}}{2}\)
\end{description}

Orders of growth are very crude descriptions of process behaviors, but they are
useful in indicating how a process will change with the size of the problem.

\subsection{Exercise 1.14: \texttt{count-change}}
\label{sec:org0a051b9}
\subsubsection{Text}
\label{sec:org6b29646}
Below is the default version of the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{count-change} function. I'll be
aggressively modifying it in order to get a graph out of it.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0)
             (= kinds-of-coins 0))
         0)
        (else
         (+ (cc amount (- kinds-of-coins 1))
            (cc (- amount (first-denomination
                           kinds-of-coins))
                kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
\end{minted}

\subsubsection{Question A: Draw the tree}
\label{sec:org21c42cc}
Draw the tree illustrating the process generated by the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{count-change}
procedure of \hyperref[sec:org14a9342]{1.2.2: Tree Recursion} in making change for 11 cents.

\subsubsection{Answer}
\label{sec:org339a180}
I want to generate this graph algorithmically.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; cursed global
(define bubblecounter 0)
;; Returns # of ways change can be made
;; "Helper" for (cc)
(define (count-change amount)
  (display "digraph {\n") ;; start graph
  (cc amount 5 0)
  (display "}\n") ;; end graph
  (set! bubblecounter 0))

;; GraphViz output
;; Derivative: https://stackoverflow.com/a/14806144
(define (cc amount kinds-of-coins oldbubble)
  (let ((recur (lambda (new-amount new-kinds)
                 (begin
                   (display "\"") ;; Source bubble
                   (display `(,oldbubble ,amount ,kinds-of-coins))
                   (display "\"")
                   (display " -> ") ;; arrow pointing from parent to child
                   (display "\"") ;; child bubble
                   (display `(,bubblecounter ,new-amount ,new-kinds))
                   (display "\"")
                   (display "\n")
                   (cc new-amount new-kinds bubblecounter)))))
    (set! bubblecounter (+ bubblecounter 1))
    (cond ((= amount 0) 1)
          ((or (< amount 0) (= kinds-of-coins 0)) 0)
          (else (+
                 (recur amount (- kinds-of-coins 1))
                 (recur (- amount
                           (first-denomination kinds-of-coins))
                        kinds-of-coins))))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
\end{minted}

I'm not going to include the full printout of the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(count-change 11)},
here's an example of what this looks like via \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{1}.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<count-change-graphviz>>
(count-change 1)
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{dot}
digraph {
"(0 1 5)" -> "(1 1 4)"
"(1 1 4)" -> "(2 1 3)"
"(2 1 3)" -> "(3 1 2)"
"(3 1 2)" -> "(4 1 1)"
"(4 1 1)" -> "(5 1 0)"
"(4 1 1)" -> "(6 0 1)"
"(3 1 2)" -> "(7 -4 2)"
"(2 1 3)" -> "(8 -9 3)"
"(1 1 4)" -> "(9 -24 4)"
"(0 1 5)" -> "(10 -49 5)"
}
\end{minted}

\begin{center}
\includegraphics[width=0.6\linewidth]{1/fig/cc-test.png}
\end{center}

So, the graph of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(count-change 11)} is:
\begin{center}
\includegraphics[width=.9\linewidth]{1/fig/cc-11.png}
\end{center}

\subsubsection{Question B: Analyzing process growth}
\label{sec:org72a0160}
What are the orders of growth of the space and number of steps used by this
process as the amount to be changed increases?

\subsubsection{Answer B}
\label{sec:orgaa9a18f}
Let's look at this via the number of function calls needed for value
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{n}. Instead of returning an integer, I'll return a pair where
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{car} is the number of ways to count change, and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cdr} is
the number of function calls that have occurred down that branch of the tree.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (count-calls amount)
  (cc-calls amount 5))

(define (cc-calls amount kinds-of-coins)
  (cond ((= amount 0) '(1 . 1))
        ((or (< amount 0)
             (= kinds-of-coins 0))
         '(0 . 1))
        (else
         (let ((a (cc-calls amount (- kinds-of-coins 1)))
               (b (cc-calls (- amount (first-denomination
                                 kinds-of-coins))
                      kinds-of-coins)))
           (cons (+ (car a)
                    (car b))
                 (+ 1
                    (cdr a)
                    (cdr b)))))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
\end{minted}


\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
<<cc-calls>>
(let* ((vals (drop (iota 101) 1))
       (mine (map count-calls vals)))
  (zip vals (map car mine) (map cdr mine)))
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{1/fig/cc-100.png}
\end{center}

I believe the space to be \(\Theta(n+d)\) as the function calls count down the
denominations before counting down the change. However I notice most answers
describe \(\Theta(n)\) instead, maybe I'm being overly pedantic and getting the
wrong answer.

My issues came finding the time. The book describes the meaning and properties
of \(\Theta\) notation in \href{http://sarabander.github.io/sicp/html/1\_002e2.xhtml\#g\_t1\_002e2\_002e3}{Section 1.2.3}. However, my lack of formal math
education made realizing the significance of this passage difficult. For one, I
didn't understand that \(k_{1}f(n) \leq R(n) \leq k_{2}f(n)\) means ``you can
find the \(\Theta\) by proving that a graph of the algorithm's resource usage is
bounded by two identical functions multiplied by constants.'' So, the graph of
resource usage for an algorithm with \(\Theta(n^{2})\) will by bounded by lines
of \(n^{2} \times some constant\), the top boundary's constant being larger than
the small boundary. These are arbitrarily chosen constants, you're just proving
that the function behaves the way you think it does.

Overall, finding the \(\Theta\) and \(\Omega\) and \(O\) notations (they are all
different btw!) is about aggressively simplifying to make a very general
statement about the behavior of the algorithm.

I could tell that a ``correct'' way to find the \(\Theta\) would be to make a
formula which describes the algorithm's function calls for given input and
denominations. This is one of the biggest time sinks, although I had a lot of
fun and learned a lot. In the end, with some help from Jach in a Lisp Discord, I
had the following formula:

\[
\sum_{i=1}^{ceil(n / val(d))} T(n - val(d)*i, d)
\]

But I wasn't sure where to go from here. The graphs let me see some interesting
trends, though I didn't get any closer to an answer in the process.

By reading on other websites, I knew that you could find \(\Theta\) by obtaining
a formula for \(R(n)\) and removing constants to end up with a term of interest.
For example, if your algorithm's resource usage is \(\frac{n^{2} + 7n}{5}\),
this demonstrates \(\Theta(n^{2})\). So I know a formula \textbf{without} a \(\sum\)
would give me the answer I wanted. It didn't occur to me that it might be
possible to use calculus to remove the \(\sum\) from the equation. At this point
I knew I was stuck and decided to look up a guide.

After seeing a few solutions that I found somewhat confusing, I landed on \href{https://codology.net/post/sicp-solution-exercise-1-14/}{this
awesome article from Codology.net}\footnote{\url{https://codology.net/post/sicp-solution-exercise-1-14/}}. They show how you can
remove the summation, and proposed this equation for count-change with 5
denominations:

\[
T(n,5)=\frac n{50}+1+\sum_{i=0}^{n/50}T(n-50i,1)
\]

Which, when expanded and simplified, demonstrates \(\Theta(n^{5})\) for 5
denominations.

Overall I'm relieved that I wasn't entirely off, given I haven't done math work
like this since college. It's inspired me to restart my remedial math courses, I
don't think I really grasped the nature of math as a tool of empowerment until
now.

\subsection{Exercise 1.15: Sine approximation}
\label{sec:orgbb090eb}
\subsubsection{Question A}
\label{sec:org002a033}
The sine of an angle (specified in radians) can be computed by making use of the
approximation \(\sin x \approx x\) if \(x\) is sufficiently small, and the
trigonometric identity \(\sin x = 3\sin\frac{x}{3} - 4\sin^3\frac{x}{3}\)
to reduce the size of the argument of sin. (For purposes of this exercise an
angle is considered ``sufficiently small'' if its magnitude is not greater than
0.1 radians.) These ideas are incorporated in the following procedures:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))
\end{minted}

How many times is the procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{p} applied when \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(sine 12.15)} is evaluated?

\subsubsection{Answer A}
\label{sec:org9c63737}
Let's find out!
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
  (if (not (> (abs angle) 0.1))
      (cons angle 0)
      (let ((x (sine (/ angle 3.0))))
        (cons (p (car x)) (+ 1 (cdr x))))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<1-15-p-measure>>
(let ((xy (sine 12.15)))
  (list (car xy) (cdr xy)))
\end{minted}

\begin{center}
\begin{tabular}{rr}
-0.39980345741334 & 5\\[0pt]
\end{tabular}
\end{center}

\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{p} is evaluated 5 times.

\subsubsection{Question B}
\label{sec:org609b176}
What is the order of growth in space and number of steps (as a function of
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{a}) used by the process generated by the sine procedure when
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(sine a)} is evaluated?

\subsubsection{Answer B}
\label{sec:org59d443d}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
<<1-15-p-measure>>
(let* ((vals (iota 300 0.1 0.1))
       (sines (map (lambda (i)
                     (cdr (sine i)))
                   vals)))
  (zip vals sines))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
<<1-15-p-measure>>
(let* ((vals (iota 10 0.1 0.1))
       (sines (map (lambda (i)
                     (cdr (sine i)))
                   vals)))
  (zip vals sines))
\end{minted}

Example output:
\begin{center}
\begin{tabular}{rr}
0.1 & 0\\[0pt]
0.2 & 1\\[0pt]
0.30000000000000004 & 2\\[0pt]
0.4 & 2\\[0pt]
0.5 & 2\\[0pt]
0.6 & 2\\[0pt]
0.7000000000000001 & 2\\[0pt]
0.8 & 2\\[0pt]
0.9 & 2\\[0pt]
1.0 & 3\\[0pt]
\end{tabular}
\end{center}

\begin{center}
\includegraphics[width=.9\linewidth]{1/fig/1-15-step.png}
\end{center}

This graph shows that the number of times \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{sine} will be called is
logarithmic.
\begin{itemize}
\item 0.1 to 0.2 are divided once
\item 0.3 to 0.8 are divided twice
\item 0.9 to 2.6 are divided three times
\item 2.7 to 8 are divided four times
\item 8.5 to 23.8 are divided five times
\end{itemize}

Given that the calls to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{p} get stacked recursively, like this:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(sine 12.15)
(p (sine 4.05))
(p (p (sine 1.35)))
(p (p (p (sine 0.45))))
(p (p (p (p (sine 0.15)))))
(p (p (p (p (p (sine 0.05))))))
(p (p (p (p (p 0.05)))))
(p (p (p (p 0.14950000000000002))))
(p (p (p 0.43513455050000005)))
(p (p 0.9758465331678772))
(p -0.7895631144708228)
-0.39980345741334
\end{minted}

So I argue the space and time is \(\Theta(\log(n))\)


We can also prove this for the time by benchmarking the function:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; This execution takes too long for org-mode, so I'm doing it
;; externally and importing the results
(use-srfis '(1))
(use-modules (ice-9 format))
(load "../../mattbench.scm")
<<1-15-deps>>
(let* ((vals (iota 300 0.1 0.1))
       (times (map (lambda (i)
                     (mattbench (lambda () (sine i)) 1000000))
                   vals)))
  (with-output-to-file "sine-bench.dat" (lambda ()
     (map (lambda (x y)
           (format #t "~s~/~s~%" x y))
         vals times))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{gnuplot}
reset # helps with various issues in execution
set xtics 0.5
set xlabel 'values of x'
set logscale x
set key top left
set style fill solid 1.00 border
#set style function fillsteps below

f(x) = (log(x) * a) + b
fit f(x) 'Ex15/sine-bench.dat' using 1:2 via a,b

plot 'Ex15/sine-bench.dat' using 1:2 with fillsteps title 'time to execute', \
     'Ex15/sine-bench.dat' using 1:(f($1)) with lines title sprintf('(log(x) * %.2f) + %.2f', a, b)
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{1/fig/1-15-bench.png}
\end{center}

\begin{enumerate}
\item 1.2.4 Exponentiation
\label{sec:orgb789366}
Considering a few ways to compute the exponential of a given number.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (expt b n)
  (expt-iter b n 1))
(define (expt-iter b counter product)
  (if (= counter 0)
      product
      (expt-iter b (- counter 1) (* b product))))
\end{minted}

This iterative procedure is essentially equivalent to:

\[b^{8} = b \cdot (b \cdot (b \cdot (b \cdot (b \cdot (b \cdot (b \cdot b))))))\]

But note it could be approached faster with squaring:

\[\begin{aligned}b^2 &= b \cdot b\\
b^4 &= b^2\cdot b^2\\
b^8 &= b^4 \cdot b^4\end{aligned}\]
\end{enumerate}

\subsection{Exercise 1.16: Making \texttt{fast-expt} iterative}
\label{sec:org366d867}
\subsubsection{Text}
\label{sec:org0d9b39a}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (expt-rec b n)
  (if (= n 0) 
      1 
      (* b (expt-rec b (- n 1)))))

(define (expt-iter b n) 
  (define (iter counter product)
    (if (= counter 0)
        product
        (iter (- counter 1)
              (* b product))))
  (iter n 1))

(define (fast-expt b n)
  (cond ((= n 0) 
         1)
        ((even? n) 
         (square (fast-expt b (/ n 2))))
        (else 
         (* b (fast-expt b (- n 1))))))
\end{minted}

\subsubsection{Question}
\label{sec:org7407b29}
Design a procedure that evolves an iterative exponentiation process that uses
successive squaring and uses a logarithmic number of steps, as does fast-expt.
(Hint: Using the observation that \((b^{n/2})^2=(b^2)^{n/2}\), keep, along with
the exponent \(n\) and the base \(b\), an additional state variable \(a\) , and
define the state transformation in such a way that the product \({ab}^n\) is
unchanged from state to state. At the beginning of the process \(a\) is taken to
be 1, and the answer is given by the value of \(a\) at the end of the process.
In general, the technique of defining an \emph{invariant quantity} that remains
unchanged from state to state is a powerful way to think about the design of
iterative algorithms.)

\subsubsection{Diary}
\label{sec:org81fd6fa}
First I made this program which tries to use a false equivalence:
\[ab^2 = (a + 1)b^{n - 1}\]
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
(define (fast-expt-iter b n)
  (define (iter b n a)
    (format #t "~&|~s~/~/|~s~/~/|~s|~%" b n a)
    (cond ((= n 1) (begin (format #t "~&|~s~/~/|~s~/~/|~s|~%" (* b a) 1 1)
                          (* b a)))
          ((even? n) (iter (square b)
                         (/ n 2)
                         a))
          (else (iter b (- n 1) (+ a 1)))))
  (format #t "|~a~/|~a~/|~a|~%" "base" "power" "variable")
  (format #t "~&|--|--|--|~%")
  (iter b n 1))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<fast-expt-iter-fail1>>
<<try-these>>
(fast-expt-iter 2 6)
\end{minted}

Here's what the internal state looks like during \(2^6\) (correct answer is 64):
\begin{center}
\begin{tabular}{rrr}
base & power & variable\\[0pt]
\hline
2 & 6 & 1\\[0pt]
4 & 3 & 1\\[0pt]
4 & 2 & 2\\[0pt]
16 & 1 & 2\\[0pt]
32 & 1 & 1\\[0pt]
\end{tabular}
\end{center}

\subsubsection{Answer}
\label{sec:orgd2b8b49}
There are two key transforms to a faster algorithm. The first was already shown
in the text:

\[
    ab^n \to a(b^2)^{n/2}
\]

The second which I needed to deduce was this:

\[
    ab^n \to ((a \times b) \times b)^{n - 1}
\]

The solution essentially follows this logic:
\begin{itemize}
\item initialize \(a\) to 1
\item If \(n\) is 1, return \(b * a\)
\item else if \(n\) is even, halve \(n\), square \(b\), and iterate
\item else \(n\) is odd, so subtract 1 from \(n\) and \(a \to a \times b\)
\end{itemize}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
(define (fast-expt-iter b n)
  (define (iter b n a)
    (cond ((= n 1) (* b a))
          ((even? n) (iter (square b)
                         (/ n 2)
                         a))
          (else (iter b (- n 1) (* b a)))))
  (iter b n 1))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<fast-expt-iter>>
<<try-these>>
(try-these (lambda(x) (fast-expt-iter 3 x)) (cdr (iota 11)))
\end{minted}

\begin{center}
\begin{tabular}{rr}
1 & 3\\[0pt]
2 & 9\\[0pt]
3 & 27\\[0pt]
4 & 81\\[0pt]
5 & 243\\[0pt]
6 & 729\\[0pt]
7 & 2187\\[0pt]
8 & 6561\\[0pt]
9 & 19683\\[0pt]
10 & 59049\\[0pt]
\end{tabular}
\end{center}

\subsection{Exercise 1.17: Logarithmic multiplication (recursive)}
\label{sec:orgff1a868}
\subsubsection{Question}
\label{sec:orgb127663}
The exponentiation algorithms in this section are based on performing
exponentiation by means of repeated multiplication. In a similar way, one can
perform integer multiplication by means of repeated addition. The following
multiplication procedure (in which it is assumed that our language can only add,
not multiply) is analogous to the expt procedure:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))
\end{minted}

This algorithm takes a number of steps that is linear in \(b\). Now suppose we
include, together with addition, operations double, which doubles an integer,
and halve, which divides an (even) integer by 2. Using these, design a
multiplication procedure analogous to fast-expt that uses a logarithmic number
of steps.

\subsubsection{Answer}
\label{sec:org608a4a4}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (double x)
  (+ x x))
(define (halve x)
  (/ x 2))
(define (fast-mult-rec a b)
  (cond ((= b 0) 0)
        ((even? b)
         (double (fast-mult-rec a (halve b)))) ; This was kind of a stretch to think of.G
         ;(fast-mult (double a) (halve b))) <== My first instinct is iterative
        (else (+ a (fast-mult-rec a (- b 1))))))
\end{minted}

Proof it works:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<fast-mult-rec>>
<<try-these>>
(try-these (lambda(x) (fast-mult-rec 3 x)) (cdr (iota 11)))
\end{minted}

\begin{center}
\begin{tabular}{rr}
1 & 3\\[0pt]
2 & 6\\[0pt]
3 & 9\\[0pt]
4 & 12\\[0pt]
5 & 15\\[0pt]
6 & 18\\[0pt]
7 & 21\\[0pt]
8 & 24\\[0pt]
9 & 27\\[0pt]
10 & 30\\[0pt]
\end{tabular}
\end{center}

\subsection{Exercise 1.18: Logarithmic multiplication (iterative)}
\label{sec:org286a17c}
\subsubsection{Question}
\label{sec:orgda3870b}
Using the results of Exercise 1.16 and Exercise 1.17, devise a procedure that
generates an iterative process for multiplying two integers in terms of adding,
doubling, and halving and uses a logarithmic number of steps.

\subsubsection{Diary}
\label{sec:org1a36a1d}
\begin{enumerate}
\item Comparison benchmarks:
\label{sec:orgdaf3f6d}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "../mattbench.scm")
<<fast-mult-iter>>
<<fast-mult-rec>>
<<print-table>>
(print-table (list (list "fast-mult-rec" "fast-mult-iter")
                   (list (mattbench (lambda() (fast-mult-rec 32 32)) 10000000)
                         (mattbench (lambda() (fast-mult 32 32)) 10000000)))
             #:colnames #t)
\end{minted}

\begin{center}
\begin{tabular}{rr}
``fast-mult-rec'' & ``fast-mult-iter''\\[0pt]
\hline
196.89 & 166.35\\[0pt]
\end{tabular}
\end{center}

So the iterative version takes 0.84 times less to do \(32 \times 32\).

\item Hall of shame
\label{sec:org7da5ca6}
Some of my \emph{very} incorrect ideas:
\[ab = (a+1)(b-1)\]
\[ab = \big(a+\Big(\frac{a}{2}\Big)(b-1)\big)\]
\[ab+c = \big(a(b-1)+(b+c)\big)\]
\end{enumerate}

\subsubsection{Answer}
\label{sec:org35fcb1e}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (double x)
  (+ x x))
(define (halve x)
  (/ x 2))
(define (fast-mult a b)
  (define (iter a b c)
    (cond ((= b 0) 0)
          ((= b 1) (+ a c))
          ((even? b)
           (iter (double a) (halve b) c))
          (else (iter a (- b 1) (+ a c)))))
  (iter a b 0))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<fast-mult-iter>>
<<try-these>>
(try-these (lambda(x) (fast-mult 3 x)) (cdr (iota 11)))
\end{minted}

\begin{center}
\begin{tabular}{rr}
1 & 3\\[0pt]
2 & 6\\[0pt]
3 & 9\\[0pt]
4 & 12\\[0pt]
5 & 15\\[0pt]
6 & 18\\[0pt]
7 & 21\\[0pt]
8 & 24\\[0pt]
9 & 27\\[0pt]
10 & 30\\[0pt]
\end{tabular}
\end{center}

\subsection{Exercise 1.19: Logarithmic fibonacci computing with \(T\)}
\label{sec:org2174a12}
\subsubsection{Question}
\label{sec:orgfb73b1d}
There is a clever algorithm for computing the Fibonacci numbers in a logarithmic
number of steps. Recall the transformation of the state variables a and b in the
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{fib-iter} process of section 1-2-2:

\[a <- a + b\text{ and }b <- a\]

Call this transformation T, and observe that applying T over and over again n
times, starting with 1 and 0, produces the pair Fib\((n + 1)\) and Fib\((n)\). In
other words, the Fibonacci numbers are produced by applying \(T^n\), the nth
power of the transformation T, starting with the pair (1,0). Now consider T to
be the special case of p = 0 and q = 1 in a family of transformations \(T_{(pq)}\), where \(T_{(pq)}\) transforms the pair (a,b) according to \(a <-
bq + aq + ap\) and \(b <- bp + aq\). Show that if we apply such a
transformation \(T_{(pq)}\) twice, the effect is the same as using a single
transformation \(T_{(p'q')}\) of the same form, and compute p' and q' in terms
of p and q. This gives us an explicit way to square these transformations, and
thus we can compute \(T^n\) using successive squaring, as in the `fast-expt'
procedure. Put this all together to complete the following procedure, which runs
in a logarithmic number of steps:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   <??>      ; compute p'
                   <??>      ; compute q'
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
\end{minted}

\subsubsection{Diary}
\label{sec:org9731f0f}
More succinctly put:

\[
    \text{Fib}_n \begin{cases}
        a \leftarrow a + b\\
        b \leftarrow a
    \end{cases}
\]
\[
    \text{Fib-iter}_{abpq} \begin{cases}
        a \leftarrow bq + aq + ap\\
        b \leftarrow bp + aq
    \end{cases}
\]

\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(T)} returns a transformation function based on the two numbers in
the attached list. so \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(T 0 1)} returns a fib function.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (T p q)
  (lambda (a b)
    (cons (+ (* b q) (* a q) (* a p))
          (+ (* b p) (* a q)))))

(define T-fib
  (T 0 1))

;; Repeatedly apply T functions:
(define (Tr f n)
  (Tr-iter f n 0 1))
(define (Tr-iter f n a b)
  (if (= n 0)
      a
      (let ((l (f a b)))
        (Tr-iter f (- n 1) (car l) (cdr l)))))
\end{minted}

\text{T}\textsubscript{pq}: a,b\mapsto \begin{cases}
        a \(\leftarrow\) bq + aq + ap\\[0pt]
        b \(\leftarrow\) bp + aq
    \end{cases}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<T-func>>
<<try-these>>
(try-these (lambda (x) (Tr (T 0 1) x)) (cdr (iota 11)))
\end{minted}

\begin{center}
\begin{tabular}{rr}
1 & 1\\[0pt]
2 & 1\\[0pt]
3 & 2\\[0pt]
4 & 3\\[0pt]
5 & 5\\[0pt]
6 & 8\\[0pt]
7 & 13\\[0pt]
8 & 21\\[0pt]
9 & 34\\[0pt]
10 & 55\\[0pt]
\end{tabular}
\end{center}

\subsubsection{Answer}
\label{sec:org557c547}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (fib-rec n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib-rec (- n 1))
                 (fib-rec (- n 2))))))
(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (+ (* p p)
                      (* q q))      ; compute p'
                   (+ (* p q)
                      (* q q)
                      (* q p))      ; compute q'
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
\end{minted}

\begin{center}
\begin{tabular}{rrr}
``n'' & ``fib-rec'' & ``fib-iter''\\[0pt]
\hline
1 & 1 & 1\\[0pt]
2 & 1 & 1\\[0pt]
3 & 2 & 2\\[0pt]
4 & 3 & 3\\[0pt]
5 & 5 & 5\\[0pt]
6 & 8 & 8\\[0pt]
7 & 13 & 13\\[0pt]
8 & 21 & 21\\[0pt]
9 & 34 & 34\\[0pt]
\end{tabular}
\end{center}

\subsection{1.2.5: Greatest Common Divisor}
\label{sec:org4c79c76}
A greatest common divisor (or GCD) for two integers is the largest integer that
divides both of them. A GCD can be quickly found by transforming the problem
like so: \[a \% b = r\]

\[\text{GCD}(a, b) = \text{GCD}(b, r)\]

This eventually produces a pair where the second number is 0. Then, the GCD is
the other number in the pair. This is Euclid's Algorithm.

\[\begin{aligned}\text{GCD}(206,40) &= \text{GCD}(40,6)\\ &=
            \text{GCD}(6,4)\\ &= \text{GCD}(4,2)\\ &~ \text{GCD}(2,0) ~
            2\end{aligned}\]

\begin{quote}
\textbf{LamÃ©'s Theorem:} If Euclid's Algorithm requires \(k\) steps to compute the
 GCD of some pair, then the smaller number in the pair must be greater than or
 equal to the \(k^{th}\)Fibonacci number.
\end{quote}

\subsection{Exercise 1.20: Inefficiency of normal-order evaluation}
\label{sec:org238b70e}
\subsubsection{Text}
\label{sec:org8f2c2b3}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
\end{minted}

\subsubsection{Question}
\label{sec:org662adba}
The process that a procedure generates is of course dependent on the rules used
by the interpreter. As an example, consider the iterative \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{gcd}
procedure given above. Suppose we were to interpret this procedure using
normal-order evaluation, as discussed in 1.1.5: The Substitution Model for Procedure Application. (The normal-order-evaluation
rule for \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{if} is described in Exercise 1.5.) Using the substitution
method (for normal order), illustrate the process generated in evaluating
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(gcd 206 40)} and indicate the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{remainder} operations that
are actually performed. How many \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{remainder} operations are actually
performed in the normal-order evaluation of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(gcd 206 40)}? In the
applicative-order evaluation?

\subsubsection{Answer}
\label{sec:org3463c12}
I struggled to understand this, but the key here is that normal-order evaluation
causes the unevaluated expressions to be duplicated, meaning they get evaluated
multiple times.

\begin{enumerate}
\item Applicative order
\label{sec:orgb6ba5bf}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
call (gcd 206 40)
(if)
(gcd 40 (remainder 206 40))
eval remainder before call
call (gcd 40 6)
(if)
(gcd 6 (remainder 40 6))
eval remainder before call
call (gcd 6 4)
(if)
(gcd 2 (remainder 4 2))
eval remainder before call
call (gcd 2 0)
(if)
;; => 2
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; call gcd
(gcd 206 40)

;; eval conditional
(if (= 40 0)
    206
    (gcd 40 (remainder 206 40)))

;; recurse
(gcd 40 (remainder 206 40))

; encounter conditional
(if (= (remainder 206 40) 0)
    40
    (gcd (remainder 206 40)
         (remainder 40 (remainder 206 40))))

; evaluate 1 remainder
(if (= 6 0)
    40
    (gcd (remainder 206 40)
         (remainder 40 (remainder 206 40))))

; recurse
(gcd (remainder 206 40)
     (remainder 40 (remainder 206 40)))

; encounter conditional
(if (= (remainder 40 (remainder 206 40)) 0)
    (remainder 206 40)
    (gcd (remainder 40 (remainder 206 40))
         (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))

; eval 2 remainder
(if (= 4 0)
    (remainder 206 40)
    (gcd (remainder 40 (remainder 206 40))
         (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))

; recurse
(gcd (remainder 40 (remainder 206 40))
     (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))

; encounter conditional
(if (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0)
    (remainder 40 (remainder 206 40))
    (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
         (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))

; eval 4 remainders
(if (= 2 0)
    (remainder 40 (remainder 206 40))
    (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
         (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))

; recurse
(gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
     (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))

; encounter conditional
(if (= (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 0)
    (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
    (gcd (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) (remainder a  (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))

; eval 7 remainders
(if (= 0 0)
    (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
    (gcd (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) (remainder a  (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))

; eval 4 remainders
(remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
; => 2
\end{minted}

So, in normal-order eval, remainder is called 18 times, while in applicative order
it's called 5 times.
\end{enumerate}

\subsection{1.2.6: Example: Testing for Primality}
\label{sec:org01d97e2}
Two algorithms for testing primality of numbers.

\begin{enumerate}
\item \(\Theta(\sqrt{n})\): Start with \(x = 2\), check for divisibility with
\(n\), if not then increment \(x\) by 1 and check again. If \(x^2 > n\) and
you haven't found a divisor, \(n\) is prime.
\item \(\Theta(\log n)\): Given a number \(n\), pick a random number \(a < n\) and
compute the remainder of \(a^n\) modulo \(n\). If the result is not equal to
\(a\), then \(n\) is certainly not prime. If it is \(a\), then chances are
good that \(n\) is prime. Now pick another random number \(a\) and test it
with the same method. If it also satisfies the equation, then we can be even
more confident that \(n\) is prime. By trying more and more values of \(a\),
we can increase our confidence in the result. This algorithm is known as the
Fermat test.
\end{enumerate}

\begin{quote}
\textbf{Fermat's Little Theorem:} If \(n\) is a prime number and \(a\) is any
 positive integer less than \(n\), then \(a\) raised to the \(n^{th}\) power
 is congruent to \(a\) modulo \(n\). [Two numbers are \emph{congruent modulo} \(n\)
 if they both have the same remainder when divided by \(n\).]
\end{quote}

The Fermat test is a probabilistic algorithm, meaning its answer is likely to be
correct rather than guaranteed to be correct. Repeating the test increases the
likelihood of a correct answer.

\subsection{Exercise 1.21}
\label{sec:org3e60c1c}
\subsubsection{Text}
\label{sec:orgd2544f5}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) 
         n)
        ((divides? test-divisor n) 
         test-divisor)
        (else (find-divisor 
               n 
               (+ test-divisor 1)))))

(define (divides? a b)
  (= (remainder b a) 0))
\end{minted}

\subsubsection{Question}
\label{sec:orgbe31b80}
Use the smallest-divisor procedure to find the smallest divisor of each of the
following numbers: 199, 1999, 19999.

\subsubsection{Answer}
\label{sec:orgb19d988}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<find-divisor-txt>>
(map smallest-divisor '(199 1999 19999))
\end{minted}

\begin{center}
\begin{tabular}{rrr}
199 & 1999 & 7\\[0pt]
\end{tabular}
\end{center}

\subsection{Exercise 1.22}
\label{sec:org4e230a5}
\subsubsection{Question}
\label{sec:orgcc2b46d}
Most Lisp implementations include a primitive called \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{runtime} that
returns an integer that specifies the amount of time the system has been running
(measured, for example, in microseconds). The following
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{timed-prime-test} procedure, when called with an integer \(n\),
prints \(n\) and checks to see if \(n\) is prime. If \(n\) is prime, the
procedure prints three asterisks followed by the amount of time used in
performing the test.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<find-divisor-txt>>
(define (prime? n)
  (= n (smallest-divisor n)))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<prime-smallest-divisor>>
(define (timed-prime-test n)
  (newline)
  (display n) ;; Guile compatible \downarrow
  (start-prime-test n (get-internal-run-time)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (begin
        (report-prime (- (get-internal-run-time) 
                       start-time))
        n)
      #f))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))
\end{minted}

Using this procedure, write a procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{search-for-primes} that
checks the primality of consecutive odd integers in a specified range. Use your
procedure to find the three smallest primes larger than 1000; larger than
10,000; larger than 100,000; larger than 1,000,000. Note the time needed to test
each prime. Since the testing algorithm has order of growth of
\(\Theta(\sqrt{n})\), you should expect that testing for primes around 10,000
should take about \(\sqrt{10}\) times as long as testing for primes around 1000.
Do your timing data bear this out? How well do the data for 100,000 and
1,000,000 support the \(\Theta(\sqrt{n})\) prediction? Is your result compatible
with the notion that programs on your machine run in time proportional to the
number of steps required for the computation?

\subsubsection{Answer}
\label{sec:orgde887a5}
\begin{enumerate}
\item Part 1
\label{sec:orgb1621bd}
So this question is a little funky, because modern machines are so fast that the
single-run times can seriously vary.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<timed-prime-test-txt>>
(define (search-for-primes minimum goal)
  (define m (if (even? minimum)
                (+ minimum 1)
                (minimum)))
  (search-for-primes-iter m '() goal))
(define (search-for-primes-iter n lst goal)
  (if (= goal 0)
      lst
      (let ((x (timed-prime-test n)))
        (if (not (equal? x #f))
            (search-for-primes-iter (+ n 2) (cons x lst) (- goal 1))
            (search-for-primes-iter (+ n 2) lst goal)))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<search-primes-basic>>
(let ((lt1000-1 (search-for-primes 1000 3)))
  (list "Primes > 1000" lt1000-1))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
1001
1003
1005
1007
1009 *** 1651
1011
1013 *** 1425
1015
1017
1019 *** 1375
\end{minted}

There's proof it works. And here are the answers to the question:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<search-primes-basic>>
(let ((lt1000-1 (search-for-primes 1000 3))
      (lt10000-1 (search-for-primes 10000 3))
      (lt100000-1 (search-for-primes 100000 3))
      (lt100000000-1 (search-for-primes 1000000 3)))
  (list
   (list "Primes > 1000" (reverse lt1000-1))
   (list "Primes > 10000" (reverse lt10000-1))
   (list "Primes > 100000" (reverse lt100000-1))
   (list "Primes > 100000000" (reverse lt100000000-1))
   ))
\end{minted}

\begin{center}
\begin{tabular}{ll}
Primes > 1000 & (1009 1013 1019)\\[0pt]
Primes > 10000 & (10007 10009 10037)\\[0pt]
Primes > 100000 & (100003 100019 100043)\\[0pt]
Primes > 100000000 & (1000003 1000033 1000037)\\[0pt]
\end{tabular}
\end{center}

\item Part 2
\label{sec:org247d776}
Repeatedly re-running, it I see it occasionally jump to twice the time. I'm not
happy with this, so I'm going to refactor to use the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{mattbench2}
utility from the root of the project folder.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (mattbench2 f n)
  ;; Executes "f" for n times, and returns how long it took.
  ;; f is a lambda that takes no arguments, a.k.a. a "thunk"
  
  ;; Returns a list with car(last execution results) and cadr(time taken divided by iterations n)

  (define (time-getter) (get-internal-run-time))
  (define start-time (time-getter))
  (define (how-long) (- (time-getter) start-time))

  (define (iter i)
    (f)
    (if (<= i 0)
        (f) ;; return the results of the last function call
        (iter (- i 1))))

  (list (iter n) ;; result of last call of f
        (/ (how-long) (* n 1.0))));; Divide by iterations so changed n has no effect
\end{minted}

I'm going to get some more precise times. First, I need a prime searching
variant that doesn't bother benchmarking. This will call \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{prime?},
which will be bound later since we'll be trying different methods.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (search-for-primes minimum goal)
  (define m (if (even? minimum)
                (+ minimum 1)
                (minimum)))
  (search-for-primes-iter m '() goal))
(define (search-for-primes-iter n lst goal)
  (if (= goal 0)
      lst
      (let ((x (prime? n)))
        (if (not (equal? x #f))
            (search-for-primes-iter (+ n 2) (cons n lst) (- goal 1))
            (search-for-primes-iter (+ n 2) lst goal)))))
\end{minted}

I can benchmark these functions like so:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<mattbench2>>
<<prime-smallest-divisor>>
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 1000000)
(define (testit f)
  (list (cadr (mattbench2 (lambda() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 1000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
\end{minted}

Here are the results (run externally from Org-Mode):

\begin{table}[htbp]
\label{1-22-smd}
\centering
\begin{tabular}{rrrr}
5425.223086 & 20772.332491 & 53577.240193 & 121986.712395\\[0pt]
\end{tabular}
\end{table}

\begin{center}
\includegraphics[width=.9\linewidth]{1/fig/1-22-1.png}
\end{center}

The plot for the square root function doesn't quite fit the real one and I'm not
sure where the fault lies. I don't struggle to understand things like ``this
algorithm is slower than this other one,'' but when asked to find or prove the
\(\Theta\) notation I'm pretty clueless;
\end{enumerate}

\subsection{Exercise 1.23}
\label{sec:orgee7cf01}
\subsubsection{Question}
\label{sec:orgcd3e0cf}
The \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{smallest-divisor} procedure shown at the start of this section
does lots of needless testing: After it checks to see if the number is divisible
by 2 there is no point in checking to see if it is divisible by any larger even
numbers. This suggests that the values used for test-divisor should not be 2, 3,
4, 5, 6, \dots{}, but rather 2, 3, 5, 7, 9, \dots{}. To implement this change,
define a procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{next} that returns 3 if its input is equal to 2
and otherwise returns its input plus 2. Modify the smallest-divisor procedure to
use \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(next test-divisor)} instead of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(+ test-divisor 1)}.
With \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{timed-prime-test} incorporating this modified version of
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{smallest-divisor}, run the test for each of the 12 primes found in
Exercise 1.22. Since this modification halves the number of test steps, you
should expect it to run about twice as fast. Is this expectation confirmed? If
not, what is the observed ratio of the speeds of the two algorithms, and how do
you explain the fact that it is different from 2?

\subsubsection{A Comedy of Error (just the one)}
\label{sec:org9c00b7e}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
(define (smallest-divisor n)
  (find-divisor n 2))

(define (next n)
  (if (= n 2)
      3
      (+ n 1)))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) 
         n)
        ((divides? test-divisor n) 
         test-divisor)
        (else (find-divisor 
               n 
               (next test-divisor)))))

(define (divides? a b)
  (= (remainder b a) 0))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<mattbench2>>
<<find-divisor-faster>>
(define (prime? n)
  (= n (smallest-divisor n)))
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 1000000)
(define (testit f)
  (list (cadr (mattbench2 (lambda() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 1000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
\end{minted}

\begin{table}[htbp]
\label{1-22-smdf}
\centering
\begin{tabular}{rrrr}
6456.538118 & 25550.757304 & 66746.041644 & 148505.580638\\[0pt]
\end{tabular}
\end{table}


\begin{center}
\begin{tabular}{rrr}
min & (+1) & (next)\\[0pt]
1000 & 5507.42497 & 6366.99462\\[0pt]
10000 & 20913.71497 & 24845.9193\\[0pt]
100000 & 53778.74737 & 64756.73693\\[0pt]
1000000 & 122135.60511 & 143869.63561\\[0pt]
\end{tabular}
\end{center}

\begin{center}
\includegraphics[width=.9\linewidth]{1/fig/1-22-2.png}
\end{center}

So it's \emph{slower} than before. Why?

Oh, that's why.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (next n)
  (if (= n 2)
      3
      (+ n 1))) ;; <-- D'oh.
\end{minted}

\subsubsection{Answer}
\label{sec:org8206b11}
Ok, let's try that again.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
(define (smallest-divisor n)
  (find-divisor n 2))

(define (next n)
  (if (= n 2)
      3
      (+ n 2)))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) 
         n)
        ((divides? test-divisor n) 
         test-divisor)
        (else (find-divisor 
               n 
               (next test-divisor)))))

(define (divides? a b)
  (= (remainder b a) 0))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<mattbench2>>
<<find-divisor-faster-real>>
(define (prime? n)
  (= n (smallest-divisor n)))
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 500000)
(define (testit f)
  (list (cadr (mattbench2 (lambda() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 1000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
\end{minted}

\begin{table}[htbp]
\label{1-22-smdff}
\centering
\begin{tabular}{rrrr}
3863.7424 & 13519.209814 & 33520.676384 & 73005.539932\\[0pt]
\end{tabular}
\end{table}

\begin{center}
\begin{tabular}{rrrr}
min & (+1) & (next-broken) & (next-fixed)\\[0pt]
--- & --- & --- & ---\\[0pt]
1000 & 5425.223086 & 6456.538118 & 3863.7424\\[0pt]
10000 & 20772.332491 & 25550.757304 & 13519.209814\\[0pt]
100000 & 53577.240193 & 66746.041644 & 33520.676384\\[0pt]
1000000 & 121986.712395 & 148505.580638 & 73005.539932\\[0pt]
\end{tabular}
\end{center}

\begin{center}
\includegraphics[width=.9\linewidth]{1/fig/1-22-3.png}
\end{center}

I had a lot of trouble getting this one to compile, I have to restart Emacs in
order to get it to render.

Anyways, there's the speedup that was expected. Let's compare the ratios.

Defining a new average that takes arbitrary numbers of arguments:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (average . args)
  (let ((len (length args)))
    (/ (apply + args) len)))
\end{minted}

Using it for percentage comparisons:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<average-varargs>>
(list (cons "% speedup for broken (next)"
            (cons (format #f "~2$%"
                          (apply average
                                 (map (lambda (x y) (* 100 (/ x y)))
                                      (car smd) (car smdf))))
                  #nil))
      (cons "% speedup for real (next)"
            (cons (format #f "~2$%"
                          (apply average
                                 (map (lambda (x y) (* 100 (/ x y)))
                                      (car smd) (car smdff))))
                  #nil)))
\end{minted}

\begin{center}
\begin{tabular}{ll}
\% speedup for broken (next) & 81.93\%\\[0pt]
\% speedup for real (next) & 155.25\%\\[0pt]
\end{tabular}
\end{center}

Since this changed algorithm cuts out almost half of the steps, you might expect
something more like a 200\% speedup. Let's try optimizing it further. Two observations:

\begin{enumerate}
\item The condition \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(divides? 2 n)} only needs to be run once at the
start of the program.
\item Because it only needs to be run once, it doesn't need to be a separate
function at all.
\end{enumerate}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
(define (smallest-divisor n)
  (if (divides? 2 n)                  ;; check for division by 2
      2
      (find-divisor n 3)))            ;; start find-divisor at 3

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) 
         n)
        ((divides? test-divisor n) 
         test-divisor)
        (else (find-divisor 
               n 
               (+ 2 test-divisor))))) ;; just increase by 2

(define (divides? a b)
  (= (remainder b a) 0))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<mattbench2>>
<<find-divisor-faster-real2>>
(define (prime? n)
  (= n (smallest-divisor n)))
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 500000)
(define (testit f)
  (list (cadr (mattbench2 (lambda() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 1000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
\end{minted}


\begin{table}[htbp]
\label{1-22-smdff2}
\centering
\begin{tabular}{rrrr}
3151.259574 & 11245.20428 & 27803.067944 & 61997.275154\\[0pt]
\end{tabular}
\end{table}

\begin{center}
\begin{tabular}{rrrrr}
min & (+1) & (next-broken) & (next-fixed) & integrated\\[0pt]
--- & --- & --- & --- & ---\\[0pt]
1000 & 5425.223086 & 6456.538118 & 3863.7424 & 3151.259574\\[0pt]
10000 & 20772.332491 & 25550.757304 & 13519.209814 & 11245.20428\\[0pt]
100000 & 53577.240193 & 66746.041644 & 33520.676384 & 27803.067944\\[0pt]
1000000 & 121986.712395 & 148505.580638 & 73005.539932 & 61997.275154\\[0pt]
\end{tabular}
\end{center}

\begin{center}
\includegraphics[width=.9\linewidth]{1/fig/1-22-4.png}
\end{center}

\begin{center}
\begin{tabular}{ll}
\% speedup for broken (next) & 81.93\%\\[0pt]
\% speedup for real (next) & 155.25\%\\[0pt]
\% speedup for optimized & 186.59\%\\[0pt]
\end{tabular}
\end{center}

\subsection{Exercise 1.24}
\label{sec:orgd60b3fe}
\subsubsection{Text}
\label{sec:org7b913f7}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder 
          (square (expmod base (/ exp 2) m))
          m))
        (else
         (remainder 
          (* base (expmod base (- exp 1) m))
          m))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (fast-prime? n times)
  (cond ((= times 0) #t)
        ((fermat-test n) 
         (fast-prime? n (- times 1)))
        (else #f)))
\end{minted}

\subsubsection{Question}
\label{sec:org190be57}
Modify the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{timed-prime-test} procedure of \ref{sec:org4e230a5} to use
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{fast-prime?} (the Fermat method), and test each of the 12 primes you
found in that exercise. Since the Fermat test has \(\Theta(\text{log}n)\)
growth, how would you expect the time to test primes near 1,000,000 to compare
with the time needed to test primes near 1000? Do your data bear this out? Can
you explain any discrepancy you find?

\subsubsection{Answer}
\label{sec:org8f1d288}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<mattbench2>>
<<expmod>>
<<fermat-test>>
<<fast-prime>>
(define fermat-iterations 2)
(define (prime? n)
  (fast-prime? n fermat-iterations))
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 500000)
(define (testit f)
  (list (cadr (mattbench2 (lambda() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 1000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
\end{minted}

\begin{table}[htbp]
\label{1-24-fermat}
\centering
\begin{tabular}{rrrr}
11175.799722 & 23518.62116 & 32150.745642 & 32679.766448\\[0pt]
\end{tabular}
\end{table}

\begin{center}
\begin{tabular}{rrrr}
min & (+1) & integrated & fermat (2 guesses)\\[0pt]
--- & --- & --- & ---\\[0pt]
1000 & 5425.223086 & 3151.259574 & 11175.799722\\[0pt]
10000 & 20772.332491 & 11245.20428 & 23518.62116\\[0pt]
100000 & 53577.240193 & 27803.067944 & 32150.745642\\[0pt]
1000000 & 121986.712395 & 61997.275154 & 32679.766448\\[0pt]
\end{tabular}
\end{center}

\begin{center}
\includegraphics[width=.9\linewidth]{1/fig/1-24-1.png}
\end{center}

It definitely looks to be advancing much slower than the other methods. I'd like
to see more of the function.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<mattbench2>>
<<find-divisor-faster-real>>
(define (prime? n)
  (= n (smallest-divisor n)))
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 100000)
(define (testit f)
  (list (cadr (mattbench2 (lambda() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 1000000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 10000000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 100000000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 1000000000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 10000000000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 100000000000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 1000000000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<mattbench2>>
<<expmod>>
<<fermat-test>>
<<fast-prime>>
(define fermat-iterations 100)
(define (prime? n)
  (fast-prime? n fermat-iterations))
<<search-for-primes-untimed>>
<<print-table>>

(define benchmark-iterations 100000)
(define (testit f)
  (list (cadr (mattbench2 (lambda() (f 1000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 10000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 100000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 1000000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 10000000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 100000000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 1000000000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 10000000000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 100000000000 3)) benchmark-iterations))
        (cadr (mattbench2 (lambda() (f 1000000000000 3)) benchmark-iterations))))

(print-row
 (testit search-for-primes))
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{1/fig/1-24-2.png}
\end{center}

For the life of me I have no idea what that bump is. Maybe it needs more
aggressive bignum processing there?

\subsection{Exercise 1.25}
\label{sec:org412922b}
\subsubsection{Question}
\label{sec:org4318323}
Alyssa P. Hacker complains that we went to a lot of extra work in writing
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{expmod}. After all, she says, since we already know how to compute
exponentials, we could have simply written

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (expmod base exp m)
  (remainder (fast-expt base exp) m))
\end{minted}

Is she correct? Would this procedure serve as well for our fast prime tester?
Explain.

\subsubsection{Answer}
\label{sec:org3aa4819}
In Alyssa's version of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{expmod}, the result of the
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{fast-expt} operation is \emph{extremely} large. For example, in the
process of checking for divisors of 1,001, the number 455 will be tried.
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(expt 455 1001)} produces an integer 2,661 digits long. This is just
one of the thousands of exponentiations that \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{smallest-divisor} will
perform. It's best to avoid this, so we use to our advantage the fact that we
only need to know the remainder of the exponentiations. \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{expmod}
breaks down the exponentiation into smaller steps and performs
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{remainder} after every step, significantly reducing the memory
requirements.

As an example, let's trace (some of) the execution of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(expmod 455 1001 1001)}:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(expmod 455 1001 1001)
>  (even? 1001)
>  #f
>  (expmod 455 1000 1001)
>  >  (even? 1000)
>  >  #t
>  >  (expmod 455 500 1001)
>  >  >  (even? 500)
>  >  >  #t
;; ...
>  >  >  x11 (expmod 455 2 1001)
>  >  >  x11 >  (even? 2)
>  >  >  x11 >  #t
>  >  >  x11 >  (expmod 455 1 1001)
>  >  >  x11 >  >  (even? 1)
>  >  >  x11 >  >  #f
>  >  >  x11 >  >  (expmod 455 0 1001)
>  >  >  x11 >  >  1
>  >  >  x11 >  455
>  >  >  x11 >  (square 455)
>  >  >  x11 >  207025
>  >  >  x11 819
;; ...
>  >  >  (square 364)
>  >  >  132496
>  >  364
>  >  (square 364)
>  >  132496
>  364
455
\end{minted}

You can see that the numbers remain quite manageable throughout this process. So
taking these extra steps actually leads to an algorithm that performs better.

\subsection{Exercise 1.26}
\label{sec:org78769f7}
\subsubsection{Question}
\label{sec:org40dcecb}
Louis Reasoner is having great difficulty doing Exercise 1.24. His
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{fast-prime?} test seems to run more slowly than his
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{prime?} test. Louis calls his friend Eva Lu Ator over to help. When
they examine Louis's code, they find that he has rewritten the
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{expmod} procedure to use an explicit multiplication, rather than
calling \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{square}:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder 
          (* (expmod base (/ exp 2) m) ;; <== hmm.
             (expmod base (/ exp 2) m))
          m))
        (else
         (remainder 
          (* base 
             (expmod base (- exp 1) m))
          m))))
\end{minted}

``I don't see what difference that could make,'' says Louis. ``I do.'' says Eva. ``By
writing the procedure like that, you have transformed the \(\Theta(\log n)\)
process into a \(\Theta(n)\) process.'' Explain.

\subsubsection{Answer}
\label{sec:org2913feb}
Making the same function call twice isn't the same as using a variable twice --
Louis' version doubles the work, having two processes solving the exact same
problem. Since the number of processes used increases exponentially, this turns
\(\log n\) into \(n\).

\subsection{Exercise 1.27}
\label{sec:org0aa429f}
\subsubsection{Question}
\label{sec:orgecf6615}
Demonstrate that the Carmichael numbers listed in Footnote 1.47 really do fool
the Fermat test. That is, write a procedure that takes an integer \(n\) and
tests whether \(a^n\) is congruent to \(a\) modulo \(n\) for every \(a < n\),
and try your procedure on the given Carmichael numbers.
\begin{table}[htbp]
\label{carmichael}
\centering
\begin{tabular}{rrrrrr}
561 & 1105 & 1729 & 2465 & 2821 & 6601\\[0pt]
\end{tabular}
\end{table}

\subsubsection{Answer}
\label{sec:orgcf8cfe3}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<expmod>>
(define (car-test n)
  (define (check a)
    (= (remainder (expt a n) n)
       (remainder (modulo a n) n)))
  (every check
           (cddr (iota n))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<car-test>>
(list (car-test 12) ; <== false (not prime)
      (car-test 1009);<== true  (real prime)
      (car-test 561));<== true  (not prime,
                     ;      Carmichael number)
\end{minted}

\subsection{Exercise 1.28}
\label{sec:orgf0a50bc}
\subsubsection{Question}
\label{sec:org59bc849}
One variant of the Fermat test that cannot be fooled is called the
\textbf{\textbf{Miller-Rabin test}} (Miller 1976; Rabin 1980). This starts from an alternate
form of Fermat's Little Theorem, which states that if \(n\) is a prime number
and \(a\) is any positive integer less than \(n\), then \(a\) raised to
the \((n-1)\) -st power is congruent to 1 modulo \(n\). To test the
primality of a number \(n\) by the Miller-Rabin test, we pick a random number
\(a<n\) and raise \(a\) to the \((n-1)\) -st power modulo \(n\) using
the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{expmod} procedure. However, whenever we perform the squaring step
in \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{expmod}, we check to see if we have discovered a ``nontrivial
square root of 1 modulo \(n\),'' that is, a number not equal to 1 or \(n-1\)
whose square is equal to 1 modulo \(n\). It is possible to prove that if such
a nontrivial square root of 1 exists, then \(n\) is not prime. It is also
possible to prove that if \(n\) is an odd number that is not prime, then, for
at least half the numbers \(a<n\), computing \(an-1\) in this way will
reveal a nontrivial square root of 1 modulo \(n\). (This is why the
Miller-Rabin test cannot be fooled.) Modify the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{expmod} procedure to
signal if it discovers a nontrivial square root of 1, and use this to implement
the Miller-Rabin test with a procedure analogous to fermat-test. Check your
procedure by testing various known primes and non-primes. Hint: One convenient
way to make \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{expmod} signal is to have it return 0.

\subsubsection{Analysis}
\label{sec:org6646999}
For the sake of verifying this, I want to get a bigger list of primes and
Carmichael numbers to verify against. I'll save them using Guile's built in
read/write functions that save Lisp lists to text:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<find-divisor-faster-real>>
(define (prime? n)
  (= n (smallest-divisor n)))
(call-with-output-file "Data/primes-1k_to_1mil.txt" (lambda(port)
  (write (filter prime? (iota (- 1000000 1000) 1000))
         port)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; fermat prime test but checks *every* value from 2 to n-1
(define (fermat-prime? n)
  (define (iter a)
    (if (= a n)
        #f
        (if (= (expmod a n n) a)
            #t
            (iter (+ 1 a)))))
  (iter 2))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
<<expmod>>
<<fermat-prime?>>
<<find-divisor-faster-real>>
(define (prime? n)
  (= n (smallest-divisor n)))
(call-with-output-file "Data/carmichael-verification.txt" (lambda(port)
     (write (filter
             (lambda(x) (and (fermat-prime? x)
                        (not (prime? x))))
             (iota (- 1000000 1000) 1000))
            port)))
\end{minted}

This will be useful in various future functions:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define list-of-primes (call-with-input-file "Data/primes-1k_to_1mil.txt" read))
(define list-of-carmichaels (call-with-input-file "Data/carmichael.txt" read))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
<<expmod>>
<<fermat-prime?>>
<<find-divisor-faster-real>>
(define (prime? n)
  (= n (smallest-divisor n)))
<<get-lists-of-primes>>
(define prime-is-working
  (and (and-map prime? list-of-primes)
       (not (and-map prime? list-of-carmichaels))))
(format #t "(prime?) is working: ~a~%"
        (if prime-is-working
            "Yes"
            "No"))
(define fermat-is-vulnerable
  (and (and-map fermat-prime? list-of-primes)
       (and-map fermat-prime? list-of-carmichaels)))
(format #t "(fermat-prime?) is vulnerable: ~a~%"
        (if fermat-is-vulnerable
            "Yes"
            "No"))
\end{minted}

\begin{verbatim}
(prime?) is working: Yes
(fermat-prime?) is vulnerable: Yes
\end{verbatim}

\subsubsection{Answer}
\label{sec:org3da674d}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
(define (expmod-mr base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (let ((sqr
                (square (expmod-mr base (/ exp 2) m))))
           (if (= 1 (modulo sqr m))
               0
               (remainder sqr m))))
        (else
         (remainder 
          (* base (expmod-mr base (- exp 1) m))
          m))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (mr-test n)
  (define (try-it a)
    (let ((it (expmod-mr a n n)))
      (or (= it a)
          (= it 0))))
  (try-it (+ 1 (random (- n 1)))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (mr-prime? n times)
  (cond ((= times 0) #t)
        ((mr-test n) 
         (mr-prime? n (- times 1)))
        (else #f)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<expmod-mr>>
<<mr-test>>
<<mr-prime>>
(define mr-times 100)
<<get-lists-of-primes>>
(format #t "      mr detects primes: ~a~%mr false-positives Carmichaels: ~a~%"
        (and-map (lambda(x)(mr-prime? x mr-times)) list-of-primes)
      (and-map (lambda(x)(mr-prime? x mr-times)) list-of-carmichaels))
\end{minted}

\begin{verbatim}
      mr detects primes: #t
mr false-positives Carmichaels: #t
\end{verbatim}

Shoot. And I thought I did a very literal interpretation of what the book asked.

Ah, I see the problem. I need to keep track of what the pre-squaring number was
and use that to determine whether the square is valid or not.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
(define (expmod-mr base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         ;; Keep result and remainder seperate
         (let* ((result (expmod-mr base (/ exp 2) m))
                (rem (remainder (square result) m)))
           (if (and (not (= result 1))
                    (not (= result (- m 1)))
                    (= 1 rem))
               0 ;; non-trivial sqrt mod 1 is found
               rem)))
        (else
         (remainder 
          (* base (expmod-mr base (- exp 1) m))
          m))))
\end{minted}
Unfortunately this one has the same problem. What's the issue?

Sadly, there's a massive issue in \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{mr-test}.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (mr-test n)
  (define (try-it a)
    (let ((it (expmod-mr a n n))) ;; Should be "a (- n 1) n"
      (or (= it a)    ;; Should be (= it 1)
          (= it 0)))) ;; Two strikes, you're out
  (try-it (+ 1 (random (- n 1)))))
\end{minted}

One more time.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (mr-test n)
  (define (try-it a)
    (= 1 (expmod-mr a (- n 1) n)))
  (try-it (+ 1 (random (- n 1)))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<expmod-mr2>>
<<mr-test2>>
<<mr-prime>>
(define mr-times 100)
<<get-lists-of-primes>>
(format #t "      mr detects primes: ~a~%mr false-positives Carmichaels: ~a~%"
        (and-map (lambda(x)(mr-prime? x mr-times)) list-of-primes)
      (and-map (lambda(x)(mr-prime? x mr-times)) list-of-carmichaels))
\end{minted}

\begin{verbatim}
     mr detects primes: #t
mr false-positives Carmichaels: #f
\end{verbatim}

\subsection{1.3: Formulating Abstractions with Higher-Order Procedures}
\label{sec:orgdb8b840}
Procedures that manipulate procedures are called \emph{higher-order procedures}.

\subsection{1.3.1: Procedures as Arguments}
\label{sec:org7d083db}
Let's say we have several different types of series that we want to sum.
Functions for each of these tasks will look very similar, so we're better off
defining a general function that expresses the \emph{idea} of summation, that can
then be passed specific functions to cause the specific behavior of the series.
Mathematicians express this as \(\sum\) (``sigma'') notation.

For the program:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
\end{minted}

Which is equivalent to:

\[\sum^{b}_{n~a}term(n)~term(a)+term(next(a))+term(next(next(a)))+\cdots+term(b)\]

We can pass integers to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{a} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{b} and functions to
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{term} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{next}. Note that in order to simply sum
integers, we'd need to define and pass an identity function to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{term}.

\subsection{Exercise 1.29}
\label{sec:org4d20e55}
\subsubsection{Text}
\label{sec:org43dc8b3}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (integral f a b dx)
  (define (add-dx x)
    (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b)
     dx))
\end{minted}

\subsubsection{Question}
\label{sec:org21caae2}
Simpson's Rule is a more accurate method of numerical integration than the
method illustrated above. Using Simpson's Rule, the integral of a function \(f\)
between \(a\) and \(b\) is approximated as

\[
\frac{h}{3}(y_0 + 4y_1 + 2y_2 + 4y_3 + 2y_4 + \dots + 2y_{n-2} + 4y_{n-1} + y_n)
\]

where \(h = (b - a) / n\), for some even integer \(n\), and \(y_k = f(a + kh)\).
(Increasing \(n\) increases the accuracy of the approximation.) Define a
procedure that takes as arguments \(f\), \(a\), \(b\), and \(n\) and returns the
value of the integral, computed using Simpson's Rule. Use your procedure to
integrate \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cube} between 0 and 1 (with \(n = 100\) and \(n = 1000\)),
and compare the results to those of the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{integral} procedure shown
above.

\subsubsection{Answer}
\label{sec:orgf6f7746}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (int-simp f a b n)
  (define h
    (/ (- b a)
     n))
  (define (gety k)
    (f (+ a (* k h))))
  (define (series-y sum k) ;; start with sum = y_0
    (cond ((= k n) (+ sum (gety k)));; and k = 1
          ((even? k) (series-y
                      (+ sum (* 2 (gety k)))
                      (+ 1 k)))
          (else (series-y
                 (+ sum (* 4 (gety k)))
                 (+ 1 k)))))
  (define sum-of-series (series-y (gety a) 1)) ;; (f a) = y_0
  (* (/ h 3) sum-of-series))
\end{minted}

Let's compare these at equal levels of computational difficulty.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<mattbench2>>
<<print-table>>
(define (cube x)
  (* x x x))
<<sum>>
<<integral>>
<<int-simp>>

(define iterations 100000) ;; benchmark iterations
(define (run-test1)
  (integral cube 0.0 1.0 0.0008))
(define (run-test2)
  (int-simp cube 0.0 1.0 1000.0))
(print-table (list (list "integral dx:0.0008" "int-simp i:1000")
                   (list (run-test1) (run-test2))
                   (list (cadr (mattbench2 run-test1 iterations))
                         (cadr (mattbench2 run-test2 iterations))))
             #:colnames #t)
\end{minted}

\begin{center}
\begin{tabular}{rr}
integral dx:0.0008 & int-simp i:1000\\[0pt]
\hline
0.24999992000001311 & 0.25000000000000006\\[0pt]
321816.2755 & 330405.8918\\[0pt]
\end{tabular}
\end{center}

So, more accurate for roughly the same effort or less.

\subsection{Exercise 1.30}
\label{sec:org8d29d18}
\subsubsection{Question}
\label{sec:org3b18f90}
The \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{sum} procedure above generates a linear recursion. The procedure
can be rewritten so that the sum is performed iteratively. Show how to do this
by filling in the missing expressions in the following definition:

\subsubsection{Answer}
\label{sec:orgcf0f650}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (sum-iter term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ result (term a)))))
  (iter a 0))
\end{minted}

Let's check the stats!
\begin{center}
\begin{tabular}{rr}
recursive & iterative\\[0pt]
\hline
30051.080005 & 19568.685587\\[0pt]
\end{tabular}
\end{center}

\subsection{Exercise 1.31}
\label{sec:orgf1e3529}
\subsubsection{Question A.1}
\label{sec:org6acef6c}
The \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{sum} procedure is only the simplest of a vast number of similar
abstractions that can be captured as higher-order procedures. Write an analogous
procedure called \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{product} that returns the product of the values of a
function at points over a given range.

\subsubsection{Answer A.1}
\label{sec:org41beef6}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (product-iter term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (* result (term a)))))
  (iter a 1)) ;; start at 1 so it's not always 0
\end{minted}

\subsubsection{Question A.2}
\label{sec:org5a3a80c}
Show how to define \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{factorial} in terms of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{product}.

\subsubsection{Answer A.2}
\label{sec:orge156abb}
I was briefly stumped because \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{product} only counts upward. Then I
realized that's just how it's presented and it can go either direction, since
addition and multiplication are commutative. I look forward to building up a
more intuitive sense of numbers.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<product-iter>>
(define (identity x)
  x)
(define (inc x)
  (1+ x))

(define (factorial n)
  (product-iter identity 1 inc n))

(display (factorial 7))
\end{minted}

\subsubsection{Question A.3}
\label{sec:org3f9b91b}
Also use \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{product} to compute approximations to \(\pi\) using the
formula

\[
\frac{\pi}{4} =
\frac{2\cdot 4\cdot 4\cdot 6\cdot 6\cdot 8\cdots}{3\cdot 3\cdot 5\cdot 5\cdot 7\cdot 7\cdots}
\]

\subsubsection{Answer A.3}
\label{sec:org96e1402}
Once this equation is encoded, you just need to multiply it by two to get \(\pi\).

Fun fact: the formula is slightly wrong, it should start the series with \(\frac{1}{2}\).
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<product-iter>>
(define (pi-product n)
  (define (div x)
    (let ((x1 (- x 1))
          (x2 (+ x 1)))
      (* (/ x x1) (/ x x2))))
  (* 2.0 (product-iter div 2 (lambda (z) (+ z 2)) n)))

(display (pi-product 100000))
\end{minted}

\begin{verbatim}
3.1415769458228726
\end{verbatim}

\subsubsection{Question B}
\label{sec:orgdb57b26}
If your product procedure generates a recursive process, write one that
generates an iterative process. If it generates an iterative process, write one
that generates a recursive process.

\subsubsection{Answer B}
\label{sec:org9d2bc50}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (product-rec term a next b)
  (if (> a b)
      1
      (* (term a)
         (product-rec term (next a) next b))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<mattbench2>>
<<print-table>>
<<product-iter>>
(define (pi-product n)
  (define (div x)
    (let ((x1 (- x 1))
          (x2 (+ x 1)))
      (* (/ x x1) (/ x x2))))
  (* 2.0 (product-iter div 2 (lambda (z) (+ z 2)) n)))
<<product-rec>>
(define (pi-product-rec n)
  (define (div x)
    (let ((x1 (- x 1))
          (x2 (+ x 1)))
      (* (/ x x1) (/ x x2))))
  (* 2.0 (product-rec div 2 (lambda (z) (+ z 2)) n)))

(define iterations 50000)
(print-table
 (list (list "iterative" "recursive")
       (list (cadr (mattbench2 (lambda()(pi-product 1000)) iterations))
             (cadr (mattbench2 (lambda()(pi-product-rec 1000)) iterations))))
 #:colnames #t)
\end{minted}

\begin{center}
\begin{tabular}{rr}
iterative & recursive\\[0pt]
\hline
1267118.0538 & 3067085.5323\\[0pt]
\end{tabular}
\end{center}

\subsection{Exercise 1.32}
\label{sec:org80e6a06}
\subsubsection{Question A}
\label{sec:org00f3e80}
Show that \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{sum} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{product} are both special cases of a
still more general notion called \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{accumulate} that combines a
collection of terms, using some general accumulation function:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(accumulate combiner null-value term a next b)
\end{minted}

\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{accumulate} takes as arguments the same term and range specifications
as \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{sum} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{product}, together with a \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{combiner}
procedure (of two arguments) that specifies how the current term is to be
combined with the accumulation of the preceding terms and a
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{null-value} that specifies what base value to use when the terms run
out. Write \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{accumulate} and show how \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{sum} and
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{product} can both be defined as simple calls to
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{accumulate}.

\subsubsection{Answer A}
\label{sec:org3a25b80}
When I first did this question, I struggled a lot before realizing
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{accumulate} was much closer to the exact definitions of sum/product
than I thought.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (accumulate-iter combiner null-value term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a)
              (combiner result (term a)))))
  (iter a null-value))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<accumulate-iter>>

;; here you can see definitions in terms of accumulate
(define (sum term a next b)
  (accumulate-iter + 0 term a next b))
(define (product term a next b)
  (accumulate-iter * 1 term a next b))

(define (identity x)
  x)
(define (inc x)
  (1+ x))

;; accumulate in action
(define (factorial n)
  (accumulate-iter * 1 identity 1 inc n))

(display (factorial 7))
\end{minted}

\begin{verbatim}
5040
\end{verbatim}

\subsubsection{Question B}
\label{sec:orgc43c55f}
If your \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{accumulate} procedure generates a recursive process, write
one that generates an iterative process. If it generates an iterative process,
write one that generates a recursive process.

\subsubsection{Answer B}
\label{sec:org82038d7}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (accumulate-rec combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a)
         (accumulate-rec combiner null-value
                         term (next a) next b))))
\end{minted}

\subsection{Exercise 1.33}
\label{sec:org44ca429}
\subsubsection{Question A}
\label{sec:orgaa91167}
\index{filter}
You can obtain an even more general version of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{accumulate} by
introducing the notion of a filter on the terms to be combined. That is, combine
only those terms derived from values in the range that satisfy a specified
condition. The resulting \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{filtered-accumulate} abstraction takes the
same arguments as accumulate, together with an additional predicate of one
argument that specifies the filter. Write \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{filtered-accumulate} as a
procedure.

\subsubsection{Answer A}
\label{sec:orgfd7dddb}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (filtered-accumulate-iter
           predicate? combiner null-value
           term a next b)
  (define (iter a result)
    (cond ((> a b) result)
          ((predicate? a)
           (iter (next a)
                 (combiner result (term a))))
          (else (iter (next a)
                      result))))
  (iter a null-value))
\end{minted}

\subsubsection{Question B}
\label{sec:orgabdc4a9}
Show how to express the following using \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{filtered-accumulate}:

\begin{enumerate}
\item A
\label{sec:org80038d7}
Find the sum of the squares of the prime numbers in the interval \(a\) to \(b\)
(assuming that you have a \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{prime?} predicate already written)

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck.scm")
(define (square x)
  (* x x))
<<filtered-accumulate-iter>>
<<expmod-mr2>>
<<mr-test2>>
<<mr-prime>>
(define mr-times 100)
(define (prime? x)
  (mr-prime? x mr-times))
(define (prime-sum a b)
  (filtered-accumulate-iter prime? + 0
                            square a 1+ b))

(mattcheck-equal "1 prime correct"
                 (prime-sum 1008 1010)
                 (square 1009)) ;; 1009
(mattcheck-equal "many primes correct"
                 (prime-sum 1000 2001)
                 (apply +
                        (map square
                             (filter prime? (iota (- 2001 1000)
                                                  1000)))))
\end{minted}

\begin{verbatim}
SUCCEED at 1 prime correct
SUCCEED at many primes correct
\end{verbatim}

\item B
\label{sec:org424d724}
\begin{quote}
Find the product of all the positive integers less than \(n\) that are
relatively prime to \(n\) (i.e., all positive integers \(i < n\) such that
\(\textsc{gcd}(i, n) = 1\).
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck.scm")
(define (square x)
  (* x x))
(define (id x) x)
<<filtered-accumulate-iter>>
<<gcd>>
(define (relative-prime? x y)
  (= 1 (gcd x y)))

(define (Ex_1-33B n)
  (filtered-accumulate-iter
   (lambda(i) (relative-prime? i n))
   * 1 id
   1 1+ (1- n)))

(define (alternate n)
  (apply *
         (filter (lambda(i) (relative-prime? i n))
                 (iota (- n 1) 1))))

(mattcheck-equal "Ex_1-33B"
                 (Ex_1-33B 100)
                 (alternate 100))
\end{minted}

\begin{verbatim}
SUCCEED at Ex_1-33B
\end{verbatim}
\end{enumerate}

\subsection{1.3.2: Constructing Procedures Using lambda}
\label{sec:org810be09}
A procedure that's only used once is more conveniently expressed as the special
form \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{lambda}.

Variables that are only briefly used in a limited scope can be specified with
the special form \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{let}. Variables in \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{let} blocks override
external variables. The authors recommend using \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{define} for
procedures and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{let} for variables.

\subsection{Exercise 1.34}
\label{sec:orgba0325a}
\subsubsection{Question}
\label{sec:org6ae106d}
\begin{quote}
Suppose we define the procedure
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (f g) (g 2))
\end{minted}

\begin{quote}
Then, we have
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(f square)
; 4
(f (lambda (z) (* z (+ z 1))))
; 6
\end{minted}

\begin{quote}
What happens if we (perversely) ask the interpreter to evaluate the combination
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(f f)}? Explain.
\end{quote}

\subsubsection{Answer}
\label{sec:org9c1434d}
It ends up trying to execute \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{2} as a function.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; Will be evaluated like this:
;;   (f f)
;;   (f 2)
;;   (2 2)
(define (f g) (g 2))
(f f)
\end{minted}

\begin{verbatim}
ice-9/boot-9.scm:1685:16: In procedure raise-exception:
Wrong type to apply: 2
\end{verbatim}

\subsection{1.3.3 Procedures as General Methods}
\label{sec:org43aef10}
The \textbf{half-interval method}: if \(f(a)<0<f(b)\), then \(f\) must have at least
one 0 between \(a\) and \(b\). To find 0, let \(x\) be the average of \(a\) and
\(b\), if \(f(x) < 0\) then 0 must be between \(x\) and \(b\), if \(f(x)>0\)
than 0 must be between \(a\) and \(x\).

The \textbf{fixed point} of a function satisfies the equation \[f(x)=x\]

For some functions, we can locate a fixed point by beginning with an initial
guess \(y\) and applying \(f(y)\) repeatedly until the value doesn't change
much.

\textbf{Average damping} can help converge fixed-point searches.

The symbol \(\mapsto\) (``maps to'') can be considered equivalent to a lambda. For
example, \(x \mapsto x+x\) is equivalent to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(lambda (x) (+ x x))}. In
English, ``the function whose value at \(y\) is \(x/y\)''. \emph{Though it seems like
\(\mapsto\) doesn't necessarily describe a function, but the value of a function
at a certain point? Or maybe that would just be \(~\), ie \(f(x)~etc\)}

\subsection{Exercise 1.35}
\label{sec:orgc2377c1}
\subsubsection{Text}
\label{sec:orgceaa113}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (close-enough? x y) 
  (< (abs (- x y)) 0.001))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define tolerance 0.00001)

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) 
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))
\end{minted}

\subsubsection{Question}
\label{sec:org6abc939}
\begin{quote}
Show that the golden ratio \(\varphi\) is a fixed point of the transformation
\(x \mapsto 1 + 1 / x\), and use this fact to compute \(\varphi\) by means of
the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{fixed-point} procedure.
\end{quote}

\subsubsection{Answer}
\label{sec:org561994c}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<close-enough>>
<<fixed-point-txt>>
(define golden-ratio
  (fixed-point (lambda(x)(+ 1 (/ 1 x)))
               1.0))

(display golden-ratio)
\end{minted}

\begin{verbatim}
1.6180327868852458
\end{verbatim}

\subsection{Exercise 1.36}
\label{sec:org8adc9bc}
\subsubsection{Question}
\label{sec:orgc35c696}
\begin{quote}
Modify \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{fixed-point} so that it prints the sequence of approximations
it generates, using the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{newline} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{display} primitives
shown in Exercise 1.22. Then find a solution to \(x^x = 1000\) by finding a
fixed point of \(x \mapsto \log(1000) / \log(x)\). (Use Scheme's primitive
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{log} procedure, which computes natural logarithms.) Compare the
number of steps this takes with and without average damping. (Note that you
cannot start \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{fixed-point} with a guess of 1, as this would cause
division by \(\log(1) = 0\).)
\end{quote}

\subsubsection{Answer}
\label{sec:org3527e24}
Using the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{display} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{newline} functions at any great
extent is pretty exhausting, so I'll use \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{format} instead.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-modules (ice-9 format))
(define tolerance 0.00001)

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) 
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (format #t "~&~a~%" next)
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<close-enough>>
<<fixed-point-debug>>
(fixed-point (lambda(x) (/ (log 1000) (log x))) 1.1)
\end{minted}

Undamped, fixed-point makes 37 guesses.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<close-enough>>
<<fixed-point-debug>>
(define (average x y)
  (/ (+ x y) 2))
(fixed-point (lambda(x) (average (log x) (/ (log 1000) (log x)))) 1.1)
\end{minted}

Damped, it makes 21.

\subsection{Exercise 1.37}
\label{sec:org113eb4d}
\subsubsection{Question A}
\label{sec:org11676c6}
\begin{quote}
An infinite continued fraction is an expression of the form

\[ {f} = \cfrac{N_1}{D_1 + \cfrac{N_2}{D_2 + \cfrac{N_3}{D_3 + \dots}}} \]

As an example, one can show that the infinite continued fraction expansion with
the \(N_i\) and the \(D_i\) all equal to 1 produces \(1 / \varphi\), where
\(\varphi\) is the golden ratio (described in 1.2.2). One way to approximate an
infinite continued fraction is to truncate the expansion after a given number of
terms. Such a truncation---a so-called \(k\)-term finite continued
fraction\}---has the form

\[ \cfrac{N_1}{D_1 + \cfrac{N_2}{\ddots + \cfrac{N_k}{D_k}}} \]

Suppose that \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{n} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{d} are procedures of one argument (the
term index \(i\)) that return the \(N_i\) and \(D_i\) of the terms of the
continued fraction. Define a procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cont-frac} such that
evaluating \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(cont-frac n d k)} computes the value of the \(k\)-term
finite continued fraction.
\end{quote}

\subsubsection{Answer A}
\label{sec:org97917a4}
A note: the ``golden ratio'' this code estimates is exactly \texttt{1.0} less than the
golden ratio anyone else seems to be talking about.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (cont-frac n d k)
  (define (iter i result)
    (if (= i 0)
        result
        (iter (1- i) (/ (n i) (+ (d i) result)))))

  (iter (1- k) (/ (n k) (d k))))
\end{minted}

\subsubsection{Question B}
\label{sec:org254dc07}
Check your procedure by approximating \(1 / \varphi\) using

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           k)
\end{minted}

for successive values of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{k}. How large must you make \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{k} in
order to get an approximation that is accurate to 4 decimal places?

\subsubsection{Answer B}
\label{sec:org57828a4}
\begin{center}
\begin{tabular}{rr}
1 & -0.3819660112501051\\[0pt]
2 & 0.1180339887498949\\[0pt]
3 & -0.04863267791677173\\[0pt]
4 & 0.018033988749894814\\[0pt]
5 & -0.0069660112501050975\\[0pt]
6 & 0.0026493733652794837\\[0pt]
7 & -0.0010136302977241662\\[0pt]
8 & 0.00038692992636546464\\[0pt]
9 & -0.00014782943192326314\\[0pt]
10 & 5.6460660007306984e-05\\[0pt]
\end{tabular}
\end{center}


\begin{center}
\includegraphics[width=.9\linewidth]{1/fig/1-36-1.png}
\end{center}

\(k\) must be at least 10 to get precision of 4 decimal places.

\subsubsection{Question C}
\label{sec:org8b42815}
\begin{quote}
If your \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cont-frac} procedure generates a recursive process, write one
that generates an iterative process. If it generates an iterative process, write
one that generates a recursive process.
\end{quote}

\subsubsection{Answer C}
\label{sec:org74d27af}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (cont-frac-rec n d k)
  (define (rec i)
    (if (= i k)
        (/ (n i) (d i))
        (/ (n i) (+ (d i) (rec (1+ i))))))

  (rec 1))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<cont-frac>>
<<cont-frac-rec>>
(define (golden-ratio k)
  (cont-frac (lambda(i) 1.0)(lambda(i)1.0) k))
(define (golden-ratio-rec k)
  (cont-frac-rec (lambda(i) 1.0)(lambda(i)1.0) k))

(load "mattcheck.scm")
(mattcheck-equal "cont-frac iter and recursive equivalence"
           (golden-ratio-rec 15)
           (golden-ratio 15))
\end{minted}

\begin{verbatim}
SUCCEED at cont-frac iter and recursive equivalence
\end{verbatim}

\subsection{Exercise 1.38}
\label{sec:orgdd7d2a1}
\subsubsection{Question}
\label{sec:org0849820}
\begin{quote}
In 1737, the Swiss mathematician Leonhard Euler published a memoir \emph{De
Fractionibus Continuis}, which included a continued fraction expansion for \(e -
2\), where \(e\) is the base of the natural logarithms. In this fraction, the
\(N_i\) are all 1, and the \(D_i\) are successively 1, 2, 1, 1, 4, 1, 1, 6, 1,
1, 8, \(\dots\). Write a program that uses your \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cont-frac} procedure
from Exercise 1.37 to approximate \(e\), based on Euler's expansion.
\end{quote}

\subsubsection{Answer}
\label{sec:org859e7b0}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<cont-frac>>
(define (euler k)
  (+ 2
     (cont-frac (lambda(i) 1.0)
             (lambda(i) (let ((j (1+ i)))
                     (if (= 0 (modulo j 3))
                         (* 2 (/ j 3))
                         1)))
             k)))

(euler 100)
\end{minted}

\begin{verbatim}
2.7182818284590455
\end{verbatim}

\subsection{Exercise 1.39}
\label{sec:org7d94c6d}
\subsubsection{Question}
\label{sec:org1c2b5c4}
\begin{quote}
A continued fraction representation of the tangent function was published in
1770 by the German mathematician J.H. Lambert:

\[ {\tan x} = \cfrac{x}{1 - \cfrac{x^2}{3 - \cfrac{x^2}{5 - \dots}}} \]

where \(x\) is in radians. Define a procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(tan-cf x k)} that
computes an approximation to the tangent function based on Lambert's formula.
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{k} specifies the number of terms to compute, as in Exercise 1.37.
\end{quote}

\subsubsection{Answer}
\label{sec:org4fcc188}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<cont-frac>>
(define (tan-cf x k)
  (cont-frac (lambda(i) (if (= i 1)
                       x
                       (* x x -1.0)))
             (lambda(i) (if (= i 1)
                       1.0
                       (- (* i 2.0) 1.0)))
             k))

(tan-cf 55 101)
\end{minted}

\begin{verbatim}
-45.1830879105221
\end{verbatim}

\subsection{1.3.4 Procedures as Returned Values}
\label{sec:orgda8f430}
Procedures can return other procedures, which opens up new ways to express
processes.

\begin{quote}
Newton's Method: \(g(x)=0\) is a fixed point of the function \(x \mapsto f(x)\)
where \[f(x)=x-\frac{g(x)}{Dg(x)}\]

Where \(x \mapsto g(x)\) is a differentiable function and \(Dg(x)\) is the
derivative of \(g\) evaluated at \(x\).
\end{quote}

\subsection{Exercise 1.40}
\label{sec:org16a9da5}
\subsubsection{Text}
\label{sec:orgf9061a5}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (average-damp f)
  (lambda (x) (average x (f x))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define dx 0.00001)
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (deriv g)
  (lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (newton-transform g)
  (lambda (x) (- x (/ (g x) ((deriv g) x)))))
(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<average>>
<<average-damp>>
<<dx>>
<<deriv>>
<<newtons-method>>
\end{minted}

\subsubsection{Question}
\label{sec:org0240ef3}
\begin{quote}
Define a procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cubic} that can be used together with the
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{newtons-method} procedure in expressions of the form:
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(newtons-method (cubic a b c) 1)
\end{minted}

\begin{quote}
to approximate zeros of the cubic \(x^3 + ax^2 + bx + c\).
\end{quote}

\subsubsection{Answer}
\label{sec:orgb3db7cc}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (cubic a b c)
  (lambda (x)
    (+ (expt x 3)
       (* a (expt x 2))
       (* b x)
       c)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (cubic-zero a b c)
  (newtons-method (cubic a b c) 1))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<fixed-point-txt>>
<<newtons-method-txt>>
<<cubic>>
<<cubic-zero>>

(cubic-zero 2 3 4)
\end{minted}

\subsection{Exercise 1.41}
\label{sec:org98e4cca}
\subsubsection{Question}
\label{sec:orgde45a3d}
\begin{quote}
Define a procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{double} that takes a procedure of one argument as
argument and returns a procedure that applies the original procedure twice. For
example, if \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{inc} is a procedure that adds 1 to its argument, then
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(double inc)} should be a procedure that adds 2. What value is
returned by
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(((double (double double)) inc) 5)
\end{minted}

\subsubsection{Answer}
\label{sec:org8ff7d91}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (double f)
  (lambda (x)
    (f (f x))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define inc 1+)
<<double>>
<<Ex1-41>>
\end{minted}

\begin{verbatim}
21
\end{verbatim}

\subsection{Exercise 1.42}
\label{sec:org8e417cf}
\subsubsection{Question}
\label{sec:orgc91c619}
\begin{quote}
Let \(f\) and \(g\) be two one-argument functions. The composition \(f\) after
\(g\) is defined to be the function \(x \mapsto f(g(x))\). Define a procedure
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{compose} that implements composition.
\end{quote}

\subsubsection{Answer}
\label{sec:orgd403cce}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (compose f g)
  (lambda(x)
    (f (g x))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<compose>>
<<square>>
(define inc 1+)
((compose square inc) 6)
\end{minted}

\begin{verbatim}
49
\end{verbatim}

\subsection{Exercise 1.43}
\label{sec:orga4408f4}
\subsubsection{Question}
\label{sec:orgc6bb088}
\begin{quote}
If \(f\) is a numerical function
and \(n\) is a positive integer, then we can form the \(n^{\mathrm{th}}\) repeated
application of \(f\), which is defined to be the function whose value at \(x\)
is \(f(f(\dots (f(x))\dots ))\).  For example, if \(f\) is the
function \(x \mapsto x + 1\), then the \(n^{\mathrm{th}}\) repeated application of \(f\) is
the function \(x \mapsto x + n\).  If \(f\) is the operation of squaring a
number, then the \(n^{\mathrm{th}}\) repeated application of \(f\) is the function that
raises its argument to the \(2^n\)-th power.  Write a procedure that takes as
inputs a procedure that computes \(f\) and a positive integer \(n\) and returns
the procedure that computes the \(n^{\mathrm{th}}\) repeated application of \(f\).
\end{quote}

\subsubsection{Answer}
\label{sec:org827d481}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<compose>>
(define (repeated f n)
  (if (= n 1)
      f
      (repeated (compose f f)
                (- n 1))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
<<repeated>>
(if (= ((repeated square 2) 5) 625)
    "Success"
    "Fail")
\end{minted}

\begin{verbatim}
Success
\end{verbatim}

\subsection{Exercise 1.44}
\label{sec:org967b0ae}
\subsubsection{Question}
\label{sec:orgba6fee8}
\index{smoothing}
\begin{quote}
The idea of smoothing a function is an important concept in signal processing.
If \(f\) is a function and \(dx\) is some small number, then the smoothed
version of \(f\) is the function whose value at a point \(x\) is the average of
\(f(x - dx)\), \(f(x)\), and \(f(x + dx)\). Write a procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{smooth}
that takes as input a procedure that computes \(f\) and returns a procedure that
computes the smoothed \(f\). It is sometimes valuable to repeatedly smooth a
function (that is, smooth the smoothed function, and so on) to obtain the
\(n\)-fold smoothed function. Show how to generate the \(n\)-fold smoothed
function of any given function using \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{smooth} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{repeated}
from Exercise 1.43.
\end{quote}

\subsubsection{Answer}
\label{sec:org477ea38}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<average-varargs>>
(define (smooth f)
  (lambda(x)
    (average (f (- x dx))
             (f x)
             (f (+ x dx)))))
(define (smooth-n f n)
  ((repeated smooth n) f))
\end{minted}

\subsection{Exercise 1.45}
\label{sec:orga0d2834}
\subsubsection{Question}
\label{sec:org62de9cb}
\begin{quote}
We saw in 1.3.3 that attempting to compute square roots by naively finding a
fixed point of \(y \mapsto x / y\) does not converge, and that this can be fixed
by average damping. The same method works for finding cube roots as fixed points
of the average-damped \(y \mapsto x / y^2\). Unfortunately, the process does not
work for fourth roots---a single average damp is not enough to make a
fixed-point search for \(y \mapsto x / y^3\) converge. On the other hand, if we
average damp twice (i.e., use the average damp of the average damp of \(y
\mapsto x / y^3\)) the fixed-point search does converge. Do some experiments to
determine how many average damps are required to compute \(n^{\mathrm{th}}\)
roots as a fixed-point search based upon repeated average damping of \(y \mapsto
x / y^{n-1}\). Use this to implement a simple procedure for computing
\(n^{\mathrm{th}}\) roots using \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{fixed-point~, ~average-damp}, and the
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{repeated} procedure of Exercise 1.43. Assume that any arithmetic
operations you need are available as primitives.
\end{quote}

\subsubsection{Answer}
\label{sec:org7217128}
So this is strange. Back in my original workthrough of this book, I'd decided
that finding an \(n\)th root required \(\lfloor\sqrt{n}\rfloor\) dampings. With
a solution like this:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<fixed-point-txt>>
<<repeated>>
<<average-damp>>
(define (sqrt n)
  (fixed-point
   (average-damp
    (lambda (y)
      (/ x y)))
   1.0))
(define (nth-root x n)
  (fixed-point
   ((repeated average-damp (ceiling (sqrt n)))
    (lambda (y)
      (/ x (expt y (- n 1)))))
   1.0))
\end{minted}
While this solution appears to work fine, my experiments are suggesting that it
takes \emph{less} than \(\lfloor\sqrt{n}\rfloor\). For example, I originally thought
powers of 16 required four dampings, but this code isn't failing until it
reaches powers of 32.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; Version of "repeated" that can handle being asked to repeat zero times.
<<compose>>
<<identity>>
(define (repeated f n)
  (define (rec m)
  (if (= n 1)
      f
      (repeated (compose f f)
                (- n 1))))
  (if (= n 0)
      identity
      (rec n)))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; version of "fixed-point" that will give up after a certain number of guesses.
(define (limited-fixed-point f first-guess)
  (define limit 5000)
  (define tolerance 0.00000001)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) 
       tolerance))
  (define (try guess tries)
    (if (= tries limit)
        "LIMIT REACHED"
        (let ((next (f guess)))
          (if (close-enough? guess next)
              next
              (try next (+ 1 tries))))))
    (try first-guess 1))
\end{minted}
Let's automatically find how many dampings are necessary. We can make a program
that finds higher and higher \(n\)th roots, and adds another layer of damping
when it hits the error. It returns a list of \(n\)th roots along with how many
dampings were needed to find them.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<fixed-point-txt>>
<<limited-fixed-point>>
<<repeated>>
<<average-damp>>
<<average>>
<<print-table>>
(define (sqrt x)
  (fixed-point
   (average-damp
    (lambda (y) (/ x y)))
   1.0))
(define (nth-tester base n-max)
  (define (iter ll)
    (let ((n (+ 2 (length ll))))
      (define (try damps)
        (let ((x (limited-fixed-point
                  ((repeated average-damp damps)
                   (lambda (y)
                     (/ base (expt y (- n 1)))))
                  1.1)))
          (if (string? x)
              (try (1+ damps))
              (list base n x damps))))
      (if (> n n-max)
          ll
          (iter (cons (try 1) ll)))))

  (iter '()))
(let* ((t (reverse (nth-tester 3 65))))
  (cons '("root" "result" "damps needed" "floor(sqrt(root))" "floor(log2(root))")
        (map (lambda(x)
               (append x
                       (list (floor (sqrt (car x)))
                             (floor (/ (log (car x))(log 2))))))
             (map cdr t))))
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{1/fig/1-45-1.png}
\end{center}

I've spent too much time on this problem already but I have to wonder about
floating-point issues, given that they are the core of the
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{good-enough} procedure. I have to wonder whether a
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{fixed-point} version that replaces the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{tolerance} decision
making, and instead retains the last three guesses and checks for a loop. (TODO)

\subsection{Exercise 1.46}
\label{sec:org0dfffe9}
\subsubsection{Question}
\label{sec:org63defe2}
\begin{quote}
Several of the numerical methods described in this chapter are instances of an
extremely general computational strategy known as \emph{iterative improvement}.
Iterative improvement says that, to compute something, we start with an initial
guess for the answer, test if the guess is good enough, and otherwise improve
the guess and continue the process using the improved guess as the new guess.
Write a procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{iterative-improve} that takes two procedures as
arguments: a method for telling whether a guess is good enough and a method for
improving a guess. \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{iterative-improve} should return as its value a
procedure that takes a guess as argument and keeps improving the guess until it
is good enough. Rewrite the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{sqrt} procedure of 1.1.7 and the
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{fixed-point} procedure of 1.3.3 in terms of
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{iterative-improve}.
\end{quote}

\subsubsection{Answer}
\label{sec:org174cf94}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (iterative-improve good-enough? improve)
  (define (iter guess)
    (let ((next (improve guess)))
      (if (good-enough? guess next)
          next
          (iter next))))
  iter)
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<iterative-improve>>
(define tolerance 0.00001)

(define (fixed-point-improve f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) 
       tolerance))
  ((iterative-improve
    close-enough?
    f)
   first-guess))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
<<average>>
<<iterative-improve>>
(define (improve guess x)
  (average guess (/ x guess)))
(define (good-enough? next x)
  ;;   (= guess next)) ;; no longer works with this method
  (< (abs (- (square next) x)) 0.001))
(define (sqrt-improve x)
  ((iterative-improve
    (lambda(guess next)(good-enough? next x))
    (lambda(guess) (improve guess x)))
   1.0))
\end{minted}


\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<fixed-point-txt>>
<<fixed-point-improve>>
(mattcheck "fixed-point-improve still working"
                 (fixed-point (lambda(x)(+ 1 (/ 1 x))) 1.1)
                 (fixed-point-improve (lambda(x)(+ 1 (/ 1 x))) 1.1))
<<sqrt>>
<<sqrt-improve>>
(mattcheck "sqrt-improve still working"
                 (sqrt 5)
                 (sqrt-improve 5))
\end{minted}

\begin{verbatim}
SUCCEED at fixed-point-improve still working
SUCCEED at sqrt-improve still working
\end{verbatim}

\section{Chapter 2: Building Abstractions with Data}
\label{sec:org287e36a}
The basic representations of data we've used so far aren't enough to deal with
complex, real-world phenomena. We need to combine these representations to form
\textbf{compound data}.

The technique of isolating how data objects are \emph{represented} from how they are
\emph{used} is called \textbf{data abstraction}.

\subsection{2.1.1: Example: Arithmetic Operations for Rational Numbers}
\label{sec:orge5f5d58}
Lisp gives the procedures \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cons}, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{car}, and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cdr}
to create \textbf{pairs}. This is an easy system for representing rational numbers.

Note that the system proposed for representing and working with rational numbers
has \textbf{abstraction barriers} isolating different parts of the system. The parts
that use rational numbers don't know how the constructors and selectors for
rational numbers work, and the constructors and selectors use the underlying
Lisp interpreter's pair functions without caring how they work.

Note that these abstraction layers allow the developer to change the underlying
architecture without modifying the programs that depend on it.

\subsection{Exercise 2.1}
\label{sec:org69c5f0a}
\subsubsection{Text}
\label{sec:org1a2e1d0}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))

(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))

(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))

(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))

(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (make-rat n d) (cons n d))
(define (numer x) (car x))
(define (denom x) (cdr x))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define one-half (make-rat 1 2))
(define one-third (make-rat 1 3))
(print-rat one-half)
(print-rat
 (mul-rat one-half one-third))
\end{minted}
\begin{verbatim}
1/2
1/6
\end{verbatim}

\subsubsection{Question}
\label{sec:orgaaf3120}
\begin{quote}
Define a better version of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{make-rat} that handles both positive and
negative arguments. \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{make-rat} should normalize the sign so that if
the rational number is positive, both the numerator and denominator are
positive, and if the rational number is negative, only the numerator is
negative.
\end{quote}

\subsubsection{Answer}
\label{sec:orgc0ab05a}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<abs>>
(define (make-rat n d)
  (cond ((not (or (< n 0)
              (< d 0)))
         (cons n d))
        ((and (< n 0)
              (< d 0))
         (cons (- n) (- d)))
        (else
         (cons (- (abs n)) (abs d)))))
(define (numer x) (car x))
(define (denom x) (cdr x))

;; Bonus: an attempt to optimize
(define (make-rat-opt n d)
  (let ((nn (< n 0))
        (dn (< d 0)))
    (cond ((not (or nn dn))
           (cons n d))
          ((and nn dn)
           (cons (- n) (- d)))
          (else
           (cons (- (abs n)) (abs d))))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<make-rat>>
<<print-rat-txt>>
<<rat-ops-txt>>
(load "mattcheck2.scm")
(mattcheck "make-rat double negative"
           (cons 1 2)
           (make-rat -1 -2))
(mattcheck "make-rat numerator negative"
           (cons -1 2)
           (make-rat -1 2))
(mattcheck "make-rat denominator negative"
           (cons -1 2)
           (make-rat 1 -2))
(mattcheck "make-rat-opt double negative"
           (cons 1 2)
           (make-rat-opt -1 -2))
(mattcheck "make-rat-opt numerator negative"
           (cons -1 2)
           (make-rat-opt -1 2))
(mattcheck "make-rat-opt denominator negative"
           (cons -1 2)
           (make-rat-opt 1 -2))
\end{minted}

\begin{verbatim}
SUCCEED at make-rat double negative
SUCCEED at make-rat numerator negative
SUCCEED at make-rat denominator negative
SUCCEED at make-rat-opt double negative
SUCCEED at make-rat-opt numerator negative
SUCCEED at make-rat-opt denominator negative
\end{verbatim}

My ``optimized'' version shows no benefit at all:
\begin{verbatim}
unoptimized make-rat: ((1 . 2) 231.74267794)
optimized make-rat: ((1 . 2) 233.99087033)
\end{verbatim}

\subsection{Exercise 2.2}
\label{sec:orgf5336ba}
\subsubsection{Question}
\label{sec:org384d079}
\begin{quote}
Consider the problem of representing line segments in a plane. Each segment is
represented as a pair of points: a starting point and an ending point. Define a
constructor \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{make-segment} and selectors \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{start-segment} and
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{end-segment} that define the representation of segments in terms of
points. Furthermore, a point can be represented as a pair of numbers: the \(x\)
coordinate and the \(y\) coordinate. Accordingly, specify a constructor
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{make-point} and selectors \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{x-point} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{y-point}
that define this representation. Finally, using your selectors and constructors,
define a procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{midpoint-segment} that takes a line segment as
argument and returns its midpoint (the point whose coordinates are the average
of the coordinates of the endpoints). To try your procedures, you'll need a way
to print points:
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
\end{minted}

\subsubsection{Answer}
\label{sec:org71bb394}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<average>>
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))
(define (make-segment start end)
  (cons start end))
(define (start-segment seg)
  (car seg))
(define (end-segment seg)
  (cdr seg))
(define (midpoint-segment seg)
  (make-point (average (x-point (start-segment seg))
                       (x-point (end-segment seg)))
              (average (y-point (start-segment seg))
                       (y-point (end-segment seg)))))
(define (midpoint-segment-opt seg)
  (let ((ax (x-point (start-segment seg)))
        (bx (x-point (end-segment seg)))
        (ay (y-point (start-segment seg)))
        (by (y-point (end-segment seg))))
  (make-point (average ax
                       bx)
              (average ay
                       by))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<make-point>>
(load "mattcheck2.scm")
(mattcheck "make-point"
           (list 1 2)
           (let ((p (make-point 1 2)))
             (list (x-point p)
                   (y-point p))))
(let* ((p1 (make-point 1 2))
      (p2 (make-point -1 -2))
      (s (make-segment p1 p2)))
  (mattcheck "make-segment"
             (list p1 p2)
             (list (start-segment s)
                   (end-segment s)))
  (mattcheck "midpoint-segment"
              (make-point 0 0)
              (midpoint-segment s))
  (mattcheck "midpoint-segment-opt"
              (make-point 0 0)
              (midpoint-segment-opt s)))
\end{minted}

\begin{verbatim}
SUCCEED at make-point
SUCCEED at make-segment
SUCCEED at midpoint-segment
SUCCEED at midpoint-segment-opt
\end{verbatim}

And once again my bikeshedding is revealed:
\begin{verbatim}
unoptimized make-rat: ((0.0 . 0.0) 326.94653558)
optimized make-rat: ((0.0 . 0.0) 331.83410742)
\end{verbatim}

\subsection{Exercise 2.3}
\label{sec:org9f9129a}
\subsubsection{Question}
\label{sec:org1a538b1}
\begin{quote}
Implement a representation for rectangles in a plane. (Hint: You may want to
make use of Exercise 2.2.) In terms of your constructors and selectors, create
procedures that compute the perimeter and the area of a given rectangle. Now
implement a different representation for rectangles. Can you design your system
with suitable abstraction barriers, so that the same perimeter and area
procedures will work using either representation?
\end{quote}

\subsubsection{Answer 1}
\label{sec:org3a6f080}
I don't really like the ``wishful thinking'' process the book advocates but since
this question specifically regards abstraction, I'll start by writing the two
requested procedures first.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (rect-area R)
  (* (rect-height R)
     (rect-width R)))

(define (rect-peri R)
  (* 2
     (+ (rect-height R)
        (rect-width R))))
\end{minted}

So my ``wishlist'' is just for \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(rect-area R)} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(rect-width R)}.

So, my first implementation of a rectangle will be of a list of 3 points
\(\mathrm{ABC}\), with the fourth point \(\mathrm{D}\) being constructed from
the others. I haven't done geometry lessons in a while but logically I can
deduce that \(\mathrm{D}\) is as far from \(\mathrm{A}\) as \(\mathrm{B}\) is
from \(\mathrm{C}\), and as far from \(\mathrm{C}\) as \(\mathrm{A}\) is from
\(\mathrm{B}\). by experimentation I've figured out that
\(\mathrm{D}=\mathrm{A} + (\mathrm{C}-\mathrm{B})=\mathrm{C} +
(\mathrm{A}-\mathrm{B})\).

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;;   AB = width
;;(0,1) (1,1)
;; A-----B
;; |     | BC = height
;; D-----C
;;(0,0) (1,0)
;; could be rotated any direction
<<square>>
<<make-point>>
(define (make-rect a b c)
  (cons (cons a b) c))
(define (rect-a R)
  (caar R))
(define (rect-b R)
  (cdar R))
(define (rect-c R)
  (cdr R))
;(define (rect-d R)
;  (make-point (x-point (rect-a R))
;              (y-point (rect-c R))))
;; Wait, this won't work if the rectangle is angled.

(define (sub-points a b)
  (make-point (- (x-point a)
                 (x-point b))
              (- (y-point a)
                 (y-point b))))

(define (add-points a b)
  (make-point (+ (x-point a)
                 (x-point b))
              (+ (y-point a)
                 (y-point b))))

(define (rect-d R)
  (let ((a (rect-a R))
        (b (rect-b R))
        (c (rect-c R)))
    (add-points a
                (sub-points c b))))
(define (rect-d-alt R) ; should be mathematically identical.
  (let ((a (rect-a R))
        (b (rect-b R))
        (c (rect-c R)))
    (add-points c
                (sub-points a b))))

;; this is incorrect
;(define (length-points a b)
;  (let ((diffP (sub-points a b)))
;    (+ (abs (x-point diffP))
;       (abs (y-point diffP)))))
(define (length-points a b)
  (let ((ax (x-point a))
        (ay (y-point a))
        (bx (x-point b))
        (by (y-point b)))
    (sqrt (+ (square (- ax bx))
          (square (- ay by))))))

(define (rect-height R)
  (abs (length-points (rect-b R)
                 (rect-c R))))
(define (rect-width R)
  (abs (length-points (rect-b R)
                 (rect-a R))))

(define (length-segment seg)
  (abs (length-points (start-segment seg)
                 (end-segment seg))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")

<<rect-4pt>>
<<rect-area-peri>>

(let* ((a (make-point 13 14))
       (b (make-point 14 14))
       (c (make-point 14 13))
       (d (make-point 13 13))
       (ABC (make-rect a b c))
       (CDA (make-rect c d a))
       (w (make-point -2.0 -2.0))
       (x (make-point -0.5 -0.5))
       (y (make-point -1.5 0.5))
       (z (make-point -3.0 -1.0))
       (WXY (make-rect w x y)))
  (mattcheck "make-rect"
             ABC
             (cons (cons a b) c))
  (mattcheck "rect-d and rect-d-alt (ABCD)"
             (rect-d ABC)
             (rect-d-alt ABC)
             d)
  (mattcheck "rect-d and rect-d-alt (CDAB)"
             (rect-d CDA)
             (rect-d-alt CDA)
             b)
  (mattcheck "rect-d and rect-d-alt (WXYZ)"
             (rect-d WXY)
             (rect-d-alt WXY)
             z)
  (mattcheck "rect-d and rect-d-alt (XYZW)"
             (rect-d (make-rect x y z))
             w)
  (mattcheck "rect-height ABC"
             (rect-height ABC)
             1)
  (mattcheck "rect-width ABC"
             (rect-width ABC)
             1)
  (mattcheck "rect-height WXY"
             (rect-height WXY)
             1.4142135623730951)
  (mattcheck "rect-width WXY"
             (rect-width WXY)
             2.1213203435596424)
  (mattcheck "rect-area ABCD"
             (rect-area ABC)
             (rect-area CDA)
             1)
  (mattcheck "rect-area WXYZ"
             (rect-area WXY)
             3.0)
  (mattcheck "rect-peri ABCD"
             (rect-peri ABC)
             4)
  (mattcheck "rect-peri WXYZ"
             (rect-peri WXY)
             7.0710678118654755))
\end{minted}

\begin{verbatim}
SUCCEED at make-rect
SUCCEED at rect-d and rect-d-alt (ABCD)
SUCCEED at rect-d and rect-d-alt (CDAB)
SUCCEED at rect-d and rect-d-alt (WXYZ)
SUCCEED at rect-d and rect-d-alt (XYZW)
SUCCEED at rect-height ABC
SUCCEED at rect-width ABC
SUCCEED at rect-height WXY
SUCCEED at rect-width WXY
SUCCEED at rect-area ABCD
SUCCEED at rect-area WXYZ
SUCCEED at rect-peri ABCD
SUCCEED at rect-peri WXYZ
\end{verbatim}

\subsubsection{Answer 2}
\label{sec:org0642c9a}
My second implementation will be of a rectangle as an origin, height, width, and
angle. Basically, height and width are two vectors originating from origin, with
width going straight right and height offset \(90\deg\) from width. Angle is
added during conversion from Polar to Cartesian coordinates. In relation to my
1st implementation, point D is where the origin is.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<make-point>>
;; origin is a (make-point), hwa are floats
(define (make-rect origin height width angle)
  (cons (cons origin height)
        (cons width angle)))

(define (rect-origin R)
  (caar R))
(define rect-d rect-origin)
(define (rect-height R)
  (cdar R))
(define (rect-width R)
  (cadr R))
(define (rect-angle R)
  (cddr R))

;; I underestimated how much math this would take.
(define (add-points a b)
  (make-point (+ (x-point a)
                 (x-point b))
              (+ (y-point a)
                 (y-point b))))

(define pi (* 4 (atan 1.0)))
(define (radian deg)
  (* deg (/ pi 180.0)))
(define (vector-to-xy distance angle)
      ;; rect-c: (cos(Theta),sin(Theta)) * width
      (make-point (* (cos (radian angle))
                     distance)
                  (* (sin (radian angle))
                     distance)))
      ;; could also be rotated by 90 degrees just by using
      ;;   (-sin(Theta),cos(Theta)) * height
(define (rect-c R)
  (add-points
   (rect-origin R)
   (vector-to-xy (rect-width R) (rect-angle R))))
(define (rect-a R)
  (add-points
   (rect-origin R)
   (vector-to-xy (rect-height R)
                 (+ 90 (rect-angle R)))))
(define (rect-b R)
  (add-points
   (rect-origin R)
   (add-points
    (vector-to-xy (rect-width R) (rect-angle R))
    (vector-to-xy (rect-height R)
                  (+ 90 (rect-angle R))))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")

<<rect-ohwa>>
<<rect-area-peri>>

(let* ((a (make-point 13.0 14.0))
       (b (make-point 14.0 14.0))
       (c (make-point 14.0 13.0))
       (d (make-point 13.0 13.0))
       (ABC (make-rect d 1 1 0))
       (CDA (make-rect b 1 1 180))
       (w (make-point -2.0 -2.0))
       (x (make-point -2.5 1.5))
       (y (make-point -1.5 0.5))
       (z (make-point -3.0 -1.0))
       (wxy-height 1.4142135623730951)
       (wxy-width 2.1213203435596424)
       (WXY (make-rect z wxy-height wxy-width 45)))
  (mattcheck "make-rect"
             ABC
             (cons (cons d 1) (cons 1 0)))
  (mattcheck "rect-b (ABCD)"
             (rect-b ABC)
             b)
  (mattcheck "rect-b (CDAB)"
             (rect-b CDA)
             d)
  (mattcheck "rect-b (WXYZ)"
             (rect-b WXY)
             x)
  (mattcheck "rect-height"
             (rect-height WXY)
             wxy-height)
  (mattcheck "rect-width"
             (rect-width WXY)
             wxy-width)
  (mattcheck "rect-area ABCD"
             (rect-area ABC)
             (rect-area CDA)
             1)
  (mattcheck "rect-area WXYZ"
             (rect-area WXY)
             3.0)
  (mattcheck "rect-peri ABCD"
             (rect-peri ABC)
             4)
  (mattcheck "rect-peri WXYZ"
             (rect-peri WXY)
             7.0710678118654755))
\end{minted}

\begin{verbatim}
SUCCEED at make-rect
SUCCEED at rect-b (ABCD)
SUCCEED at rect-b (CDAB)
SUCCEED at rect-b (WXYZ)
SUCCEED at rect-height
SUCCEED at rect-width
SUCCEED at rect-area ABCD
SUCCEED at rect-area WXYZ
SUCCEED at rect-peri ABCD
SUCCEED at rect-peri WXYZ
\end{verbatim}

\subsection{2.1.3: What Is Meant by Data?}
\label{sec:org23bc88d}
We can consider data as being a collection of selectors and constructors,
together with specific conditions that these procedures must fulfill in order to
be a valid representation. For example, in the case of our rational number
implementation, for rational number \(x\) made with numerator \(n\) and
denominator \(d\), dividing the result of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(numer x)} over the result
of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(denom x)} should be equivalent to dividing \(n\) over \(d\).

\subsection{Exercise 2.4}
\label{sec:org2e1eb6d}
\subsubsection{Question}
\label{sec:org201ed6c}
\begin{quote}
Here is an alternative procedural representation of pairs. For this
representation, verify that \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(car (cons x y))} yields \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{x} for any
objects \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{x} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{y}.
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (cons x y)
  (lambda (m) (m x y)))
(define (car z)
  (z (lambda (p q) p)))
\end{minted}

\begin{quote}
What is the corresponding definition of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cdr}? (Hint: To verify that
this works, make use of the substitution model of 1.1.5.)
\end{quote}

\subsubsection{Answer}
\label{sec:orga7af9f5}
First, let's explain with the substitution model.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(cons 0 1)
(lambda (m) (m 0 1))

(car (lambda (m) (m 0 1)))
((lambda (m) (m 0 1)) (lambda (p q) p))
(lambda (0 1) 0)
0
(cdr (lambda (m) (m 0 1)))
((lambda (m) (m 0 1)) (lambda (p q) q))
(lambda (0 1) 1)
1
\end{minted}

Now for implementation.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<alt-pairs-txt>>
(define (cdr z)
  (z (lambda (p q) q)))

(let ((pair (cons 0 1)))
  (mattcheck "car"
             (car pair)
             0)
  (mattcheck "cdr"
             (cdr pair)
             1))
\end{minted}

\begin{verbatim}
| (0 . 0) | (0 . 1) | (0 . 2) | (0 . 3) | (0 . 4) | (0 . 5) | (0 . 6) |
| (1 . 0) | (1 . 1) | (1 . 2) | (1 . 3) | (1 . 4) | (1 . 5) | (1 . 6) |
| (2 . 0) | (2 . 1) | (2 . 2) | (2 . 3) | (2 . 4) | (2 . 5) | (2 . 6) |
| (3 . 0) | (3 . 1) | (3 . 2) | (3 . 3) | (3 . 4) | (3 . 5) | (3 . 6) |
| (4 . 0) | (4 . 1) | (4 . 2) | (4 . 3) | (4 . 4) | (4 . 5) | (4 . 6) |
| (5 . 0) | (5 . 1) | (5 . 2) | (5 . 3) | (5 . 4) | (5 . 5) | (5 . 6) |
| (6 . 0) | (6 . 1) | (6 . 2) | (6 . 3) | (6 . 4) | (6 . 5) | (6 . 6) |
\end{verbatim}

\subsection{Exercise 2.5\hfill{}\textsc{optional}}
\label{sec:orga5c35a2}
\subsubsection{Question}
\label{sec:orgccbf93c}
\begin{quote}
Show that we can represent pairs of nonnegative integers using only numbers and
arithmetic operations if we represent the pair \(a\) and \(b\) as the integer
that is the product \(2^a 3^b\). Give the corresponding definitions of the
procedures \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cons}, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{car}, and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cdr}.
\end{quote}

\subsubsection{Answer}
\label{sec:org0f3dcb7}
This one really blew my mind inside-out when I first did it. Basically, because
the two numbers are coprime, you can factor out the unwanted number and be left
with the desired one.

\begin{quote}
Where \(x\) is the scrambled number, \(p\) is the base we want to remove, \(q\)
is the base we want to retrieve from and \(y\) is the value exponentiating
\(p\), the original number is retrieved by dividing \(x\) by \(p\) for \(y\)
number of times, and then applying \(\log_{q}\) to the result.
\end{quote}

First, let's make \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cons}.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (cons-nnint a b)
  (* (expt 2 a) (expt 3 b)))
(define (cons-nnint-debug a b) ;; DEBUG
  (let* ((aa (expt 2 a))
         (bb (expt 3 b))
         (ab (* aa bb)))
    (display aa)
    (newline)
    (display bb)
    (newline)
    (display ab)
    (newline)
    ab))
\end{minted}

Also, Guile doesn't have a function for custom logs so let's define that now.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (logn b p)
  (/ (log p) (log b)))
\end{minted}

Let's do some analysis to see how these numbers are related.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<cons-nnint>>
(let*
    ((tablesize 7)
     (inputs (map (lambda(x)
                    (map (lambda(y)
                           (cons x y))
                         (iota tablesize)))
                  (iota tablesize)))
     (outputs (map (lambda(row)
                     (map (lambda(col)
                            (cons-nnint (car col) (cdr col)))
                          row))
                   inputs)))
  outputs)
\end{minted}

\begin{center}
\begin{tabular}{rrrrrrr}
1 & 3 & 9 & 27 & 81 & 243 & 729\\[0pt]
2 & 6 & 18 & 54 & 162 & 486 & 1458\\[0pt]
4 & 12 & 36 & 108 & 324 & 972 & 2916\\[0pt]
8 & 24 & 72 & 216 & 648 & 1944 & 5832\\[0pt]
16 & 48 & 144 & 432 & 1296 & 3888 & 11664\\[0pt]
32 & 96 & 288 & 864 & 2592 & 7776 & 23328\\[0pt]
64 & 192 & 576 & 1728 & 5184 & 15552 & 46656\\[0pt]
\end{tabular}
\end{center}

Here are our scrambled numbers. 

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; To find a number of some base in some column,
;; First divide by unwantedbase for targetcol number of times
<<repeated>>
(let ((targetcol 2)
      (unwantedbase 3))
  (map (lambda(row)
         (map (lambda(item)
                ((repeated (lambda(x) 
                             (/ x unwantedbase)) targetcol)
                 item))
                row))
       data))
\end{minted}

\begin{center}
\begin{tabular}{llrrrrr}
1/9 & 1/3 & 1 & 3 & 9 & 27 & 81\\[0pt]
2/9 & 2/3 & 2 & 6 & 18 & 54 & 162\\[0pt]
4/9 & 4/3 & 4 & 12 & 36 & 108 & 324\\[0pt]
8/9 & 8/3 & 8 & 24 & 72 & 216 & 648\\[0pt]
16/9 & 16/3 & 16 & 48 & 144 & 432 & 1296\\[0pt]
32/9 & 32/3 & 32 & 96 & 288 & 864 & 2592\\[0pt]
64/9 & 64/3 & 64 & 192 & 576 & 1728 & 5184\\[0pt]
\end{tabular}
\end{center}

The numbers from our target column onwards are integers, with the target column
being linearly exponentiated by 2 because the original numbers were linear.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<logn>>
(let ((wantedbase 2))
  (map (lambda(row)
         (map (lambda(item)
                (format #f "~6,3f" (logn 2 item)))
                row))
       data))
\end{minted}

\begin{center}
\begin{tabular}{rrrrrrr}
-3.170 & -1.585 & 0.000 & 1.585 & 3.170 & 4.755 & 6.340\\[0pt]
-2.170 & -0.585 & 1.000 & 2.585 & 4.170 & 5.755 & 7.340\\[0pt]
-1.170 & 0.415 & 2.000 & 3.585 & 5.170 & 6.755 & 8.340\\[0pt]
-0.170 & 1.415 & 3.000 & 4.585 & 6.170 & 7.755 & 9.340\\[0pt]
0.830 & 2.415 & 4.000 & 5.585 & 7.170 & 8.755 & 10.340\\[0pt]
1.830 & 3.415 & 5.000 & 6.585 & 8.170 & 9.755 & 11.340\\[0pt]
2.830 & 4.415 & 6.000 & 7.585 & 9.170 & 10.755 & 12.340\\[0pt]
\end{tabular}
\end{center}

Now the second column has recovered its original values. Although we didn't know
what the original integer values were, we can now tell which column has the
correct numbers by looking at which are integer values.

We can use this sign of a correct result in the proposed \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{car} and
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cdr} procedures.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<cons-nnint>>
<<logn>>
(use-srfis '(1))
(define (all-your-base ab unwanted wanted)
  (if (equal? (modulo ab unwanted) 0)
      (all-your-base (/ ab unwanted) unwanted wanted)
      (if (equal? (modulo ab wanted) 0)
          (round (logn wanted ab))
          "This number isn't a factor!")))
(define (car-nnint ab)
  (all-your-base ab 3 2))
(define (cdr-nnint ab)
  (all-your-base ab 2 3))

(let* ((initvalues '((2 3) (4 5) (7 2)))
       (conslist (map (lambda(x)
                        (apply cons-nnint x))
                      initvalues))
       (carlist (map (lambda(x)
                       (car-nnint x))
                     conslist))
       (cdrlist (map (lambda(x)
                       (cdr-nnint x))
                     conslist)))
  (map (lambda(x y) (cons x y))
       (list "pairs" "cons'd" "car" "cdr")
       (list initvalues conslist carlist cdrlist)))
\end{minted}

\begin{center}
\begin{tabular}{lrrr}
pairs & (2 3) & (4 5) & (7 2)\\[0pt]
\hline
cons'd & 108 & 3888 & 1152\\[0pt]
car & 2.0 & 4.0 & 7.0\\[0pt]
cdr & 3.0 & 5.0 & 2.0\\[0pt]
\end{tabular}
\end{center}

\subsection{Exercise 2.6\hfill{}\textsc{optional}}
\label{sec:org057e873}
\subsubsection{Question}
\label{sec:org9205d28}
\begin{quote}
In case representing pairs as procedures wasn't mind-boggling enough, consider
that, in a language that can manipulate procedures, we can get by without
numbers (at least insofar as nonnegative integers are concerned) by implementing
0 and the operation of adding 1 as
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
\end{minted}

\begin{quote}
This representation is known as \emph{Church numerals}, after its inventor, Alonzo
Church, the logician who invented the \(\lambda\)-calculus.

Define \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{one} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{two} directly (not in terms of
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{zero} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{add-1}). (Hint: Use substitution to evaluate
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(add-1 zero)}). Give a direct definition of the addition procedure
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{+} (not in terms of repeated application of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{add-1}).
\end{quote}

\subsubsection{Answer}
\label{sec:org8c3f16e}
First, let's check out \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(add-1 zero)}.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x)
           (f ((n f) x)))))

(add-1 zero)
((lambda (f) (lambda (x)
          (f ((zero f) x)))))
((lambda (f) (lambda (x)
          (f ((lambda (x) x) x)))))
((lambda (f) (lambda (x)
          (f x))))
\end{minted}

So from this I believe the correct definition of one and two are:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
(define one
  (lambda (f) (lambda (x)
           (f x))))
(define two
  (lambda (f) (lambda (x)
            (f (f x)))))

(mattcheck "1 = 1+0"
           1
           ((one 1+) 0))
(mattcheck "2 = 1+1+0"
           2
           ((two 1+) 0))

(define (add a b)
  (lambda (f) (lambda (x)
           ((a f) ((b f) x)))))

(mattcheck "3 = 1+2 = (1+0) + (1+1+0)"
           3
           (((add one two) 1+) 0))
\end{minted}

\begin{verbatim}
SUCCEED at 1 = 1+0
SUCCEED at 2 = 1+1+0
SUCCEED at 3 = 1+2 = (1+0) + (1+1+0)
\end{verbatim}

\subsection{Exercise 2.7}
\label{sec:org0bf5559}
\subsubsection{Text}
\label{sec:org072f14b}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))
(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
(define (div-interval x y)
  (mul-interval
   x
   (make-interval (/ 1.0 (upper-bound y))
                  (/ 1.0 (lower-bound y)))))
\end{minted}

\subsubsection{Question}
\label{sec:orgfd27d6f}
\begin{quote}
Alyssa's program is incomplete because she has not specified the implementation
of the interval abstraction. Here is a definition of the interval constructor:
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (make-interval a b) (cons a b))
\end{minted}

\begin{quote}
Define selectors \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{upper-bound} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{lower-bound} to complete
the implementation.
\end{quote}

\subsubsection{Answer}
\label{sec:org367c7f9}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<interval-txt>>

;; Makes more sense to me to test
;; order in the constructor than selector
(define (make-interval a b)
  (if (> a b)
      (cons a b)
      (cons b a)))

(define (upper-bound i)
  (car i))
(define (lower-bound i)
  (cdr i))
\end{minted}

\subsection{Exercise 2.8}
\label{sec:org703b972}
\subsubsection{Question}
\label{sec:org313040a}
\begin{quote}
Using reasoning analogous to Alyssa's, describe how the difference of two
intervals may be computed. Define a corresponding subtraction procedure, called
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{sub-interval}.
\end{quote}

\subsubsection{Answer}
\label{sec:orga61e776}
I would argue that with one interval subtracted from the other, the lowest
possible value is the lower of the first subtracted from the \emph{upper} of the
second, and the highest is the upper of the first subtracted from the lower of
the second.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (sub-interval x y)
  (make-interval (- (lower-bound x) (upper-bound y))
                 (- (upper-bound x) (lower-bound y))))
\end{minted}

\subsection{Exercise 2.9}
\label{sec:orgddc14d5}
\subsubsection{Question}
\label{sec:org43ca822}
\begin{quote}
The \emph{width} of an interval is half of the difference between its upper and lower
bounds. The width is a measure of the uncertainty of the number specified by the
interval. For some arithmetic operations the width of the result of combining
two intervals is a function only of the widths of the argument intervals,
whereas for others the width of the combination is not a function of the widths
of the argument intervals. Show that the width of the sum (or difference) of two
intervals is a function only of the widths of the intervals being added (or
subtracted). Give examples to show that this is not true for multiplication or
division.
\end{quote}

\subsubsection{Answer}
\label{sec:org0bdafe5}
My first interpretation of the question was that it asked whether width
operations are \emph{distributive}. For example, multiplication is distributive:

\[
  a(b+c) = (a \times b)+(a \times c)
\]

For this I wrote the following tests:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<make-interval>>
<<sub-interval>>

(define (halve x)
  (/ x 2))

(define (width-interval I)
  (halve (- (upper-bound I)
            (lower-bound I))))

(let* ((ia (make-interval 10.1 9.9))
       (ib (make-interval 5.2 4.8))
       (Aab (add-interval ia ib))
       (Sab (sub-interval ia ib))
       (Mab (mul-interval ia ib))
       (Dab (div-interval ia ib)))
  (mattcheck-float "ia width = roughly .1"
                   0.1
                   (width-interval ia))
  (mattcheck-float "ib width = roughly .2"
                   0.2
                   (width-interval ib))
  (mattcheck-float "width addition is distributive"
                   (width-interval Aab)
                   (+ (width-interval ia)
                      (width-interval ib)))
  (mattcheck-float "width subtraction is distributive"
                   (width-interval Sab)
                   (- (width-interval ia)
                      (width-interval ib)))
  (mattcheck-float "width multiplication is distributive"
                   (width-interval Mab)
                   (* (width-interval ia)
                      (width-interval ib)))
  (mattcheck-float "width division is distributive"
                   (width-interval Dab)
                   (/ (width-interval ia)
                      (width-interval ib))))
\end{minted}

\begin{verbatim}
SUCCEED at ia width = roughly .1
SUCCEED at ib width = roughly .2
SUCCEED at width addition is distributive
FAIL at width subtraction is distributive
expected: -0.10000000000000053
returned: 0.2999999999999998
FAIL at width multiplication is distributive
expected: 0.01999999999999995
returned: 2.5
FAIL at width division is distributive
expected: 0.4999999999999978
returned: 0.10016025641025639
\end{verbatim}

However upon rereading the question I see that it could be rephrased as ``in what
operations can you calculate the resulting interval's width with only the widths
of the argument intervals?''

Basically, for argument interval \(x\) and \(y\) and result interval \(z\):

\begin{quote}
\texttt{IF} \(z = x + y\) \\[0pt]
\texttt{THEN} \(z_{width} = x_{width} + y_{width}\) \\[0pt]
\texttt{IF} \(z = x - y\) \\[0pt]
\texttt{THEN} \(z_{width} = x_{width} + y_{width}\) \\[0pt]
Multiplied or divided widths cannot be determined from widths alone.
\end{quote}

So, let's try that again.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<make-interval>>
<<sub-interval>>

(define (halve x)
  (/ x 2))

(define (width-interval I)
  (halve (- (upper-bound I)
            (lower-bound I))))

(let* ((ia (make-interval 10.1 9.9))
       (ib (make-interval 5.2 4.8))
       (Aab (add-interval ia ib))
       (Sab (sub-interval ia ib)))
  (mattcheck-float "ia width = roughly .1"
                   0.1
                   (width-interval ia))
  (mattcheck-float "ib width = roughly .2"
                   0.2
                   (width-interval ib))
  (mattcheck-float "width(ia+ib) = width(ia) + width(ib)"
                   (width-interval Aab)
                   (+ (width-interval ia)
                      (width-interval ib)))
  (mattcheck-float "width(ia-ib) = width(ia) + width(ib)"
                   (width-interval Sab)
                   (+ (width-interval ia)
                      (width-interval ib))))
\end{minted}

\begin{verbatim}
SUCCEED at ia width = roughly .1
SUCCEED at ib width = roughly .2
SUCCEED at width(ia+ib) = width(ia) + width(ib)
SUCCEED at width(ia-ib) = width(ia) + width(ib)
\end{verbatim}

\subsection{Exercise 2.10}
\label{sec:orgdd2933f}
\subsubsection{Question}
\label{sec:org1021d56}
\begin{quote}
Ben Bitdiddle, an expert systems programmer, looks over Alyssa's shoulder and
comments that it is not clear what it means to divide by an interval that spans
zero. Modify Alyssa's code to check for this condition and to signal an error if
it occurs.
\end{quote}

\subsubsection{Answer}
\label{sec:org8489d7e}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (interval-spans-zero? I)
  (and (> upper-bound 0)
       (< lower-bound 0)))
(define (div-interval x y)
  (if (interval-spans-zero? y)
      "DIV-INTERVAL ERROR: denominator spans zero"
      (mul-interval
       x
       (make-interval (/ 1.0 (upper-bound y))
                      (/ 1.0 (lower-bound y))))))
\end{minted}

\subsection{Exercise 2.11}
\label{sec:org8efd39c}
\subsubsection{Question}
\label{sec:org892c8cc}
\begin{quote}
In passing, Ben also cryptically comments: ``By testing the signs of the
endpoints of the intervals, it is possible to break \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{mul-interval}
into nine cases, only one of which requires more than two multiplications.''
Rewrite this procedure using Ben's suggestion.
\end{quote}

\subsubsection{Answer}
\label{sec:org2343e3a}
This problem doesn't appear to have a beautiful, elegant answer.

Let's examine the nine cases.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-modules (ice-9 format))
(use-srfis '(1))
(load "mattcheck2.scm")
<<make-interval>>
<<sub-interval>>

(define (matt-examine-mult f)
  (let* ((pp (make-interval 3 2))
         (pn (make-interval 3 -5))
         (pn2 (make-interval 1 -0.5))
         (nn (make-interval -5 -7))
         (listofpairs (list
                       (list pp pp)
                       (list pp pn)
                       (list pp nn)
                       (list pn pp)
                       (list pn pn)
                       (list pn pn2) ;;<- edge case to catch incomplete
                       (list pn nn)  ;;   multiplication functions
                       (list nn pp)
                       (list nn pn)
                       (list nn nn)))
         (givesign (lambda(x)
                     (if (negative? x)
                         "-"
                         "+")))
         (print-sign (lambda(I)
                       (format #f "~a ~a"
                               (givesign (upper-bound I))
                               (givesign (lower-bound I)))))
         (print-int (lambda(I)
                      (format #f "~a/~a"
                              (upper-bound I)
                              (lower-bound I))))
         (print-ints (lambda(I J)
                       (format #f "~a times ~a"
                               (print-int I)
                               (print-int J))))
         (results (map (lambda(p)
                         (apply f p))
                       listofpairs)))
    (list
     (map (lambda(p)
            (apply print-ints p))
          listofpairs)
     (map print-int results)
     (map (lambda(I)
            (print-sign I))
          results)
     (map (lambda(p)
            (format #f "~a // ~a"
                    (print-sign (car p))
                    (print-sign (cadr p))))
          listofpairs))))
(cons
 (list "problem" "result" "signs" "problem signs")
 (apply zip 
        (matt-examine-mult mul-interval)))
\end{minted}

\begin{center}
\begin{tabular}{llll}
problem & result & signs & problem signs\\[0pt]
\hline
3/2 times 3/2 & 9/4 & + + & + + // + +\\[0pt]
3/2 times 3/-5 & 9/-15 & + - & + + // + -\\[0pt]
3/2 times -5/-7 & -10/-21 & - - & + + // - -\\[0pt]
3/-5 times 3/2 & 9/-15 & + - & + - // + +\\[0pt]
3/-5 times 3/-5 & 25/-15 & + - & + - // + -\\[0pt]
3/-5 times 1/-0.5 & 3.0/-5.0 & + - & + - // + -\\[0pt]
3/-5 times -5/-7 & 35/-21 & + - & + - // - -\\[0pt]
-5/-7 times 3/2 & -10/-21 & - - & - - // + +\\[0pt]
-5/-7 times 3/-5 & 35/-21 & + - & - - // + -\\[0pt]
-5/-7 times -5/-7 & 49/25 & + + & - - // - -\\[0pt]
\end{tabular}
\end{center}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (mul-interval-opt x y)
  (let ((xu (upper-bound x))
        (xl (lower-bound x))
        (yu (upper-bound y))
        (yl (lower-bound y)))
    (define p? positive?)
    (define n? negative?)
    (define (check-signs? a b x y) ;; pass functions
      (and (a xu)
           (b xl)
           (x yu)
           (y yl)))
    (define (same-signs?)
      (or (check-signs? p? p? p? p?)
          (check-signs? n? n? n? n?)))
    (define (alt-signs?)
      (or (check-signs? p? p? n? n?)
          (check-signs? n? n? p? p?)))
    (cond ((same-signs?)
           (make-interval (* xu yu)
                          (* xl yl)))
          ((alt-signs?)
           (make-interval (* xl yu)
                          (* xu yl)))
          ((check-signs? p? p? p? n?)
           (make-interval (* xu yu)
                          (* xu yl)))
          ((check-signs? p? n? p? p?)
           (make-interval (* xu yu)
                          (* xl yu)))
          ((check-signs? p? n? p? n?)
           (let ((p1 (* xu yu))
                 (p2 (* xu yl))
                 (p3 (* xl yu))
                 (p4 (* xl yl)))
             (make-interval (max p1 p2 p3 p4)
                            (min p1 p2 p3 p4))))
          ((check-signs? p? n? n? n?)
           (make-interval (* xl yl)
                          (* xu yl)))
          ((check-signs? n? n? p? n?)
           (make-interval (* xl yl)
                          (* xl yu))))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-modules (ice-9 format))
(use-srfis '(1))
(load "mattcheck2.scm")
<<make-interval>>
<<sub-interval>>
<<mul-interval-opt>>

(define (matt-mult-consistency f1 f2)
  (let* ((pp (make-interval 3 2))
         (pn (make-interval 3 -5))
         (pn2 (make-interval 1 -0.5))
         (nn (make-interval -5 -7))
         (listofpairs (list
                       (list "pp*nn" pp pp)
                       (list "pp*pn" pp pn)
                       (list "pp*nn" pp nn)
                       (list "pn*pp" pn pp)
                       (list "pn*pn" pn pn)
                       (list "pn*pn2" pn pn2) ;;<- edge case to catch incomplete
                       (list "pn*nn" pn nn)  ;;   multiplication functions
                       (list "nn*pp" nn pp)
                       (list "nn*pn" nn pn)
                       (list "nn*nn" nn nn))))
    (map (lambda(l)
           (mattcheck (car l)
                      (apply f1 (cdr l))
                      (apply f2 (cdr l))))
         listofpairs)))

(matt-mult-consistency mul-interval mul-interval-opt)
\end{minted}

\begin{verbatim}
SUCCEED at pp*nn
SUCCEED at pp*pn
SUCCEED at pp*nn
SUCCEED at pn*pp
SUCCEED at pn*pn
SUCCEED at pn*pn2
SUCCEED at pn*nn
SUCCEED at nn*pp
SUCCEED at nn*pn
SUCCEED at nn*nn
\end{verbatim}

\begin{verbatim}
Unoptimized mul-interval: (5231.8421225)
Optimized mul-interval: (2526.5896437)
\end{verbatim}

So as expected, about twice as fast!

\subsection{Exercise 2.12}
\label{sec:orgeb573f5}
\subsubsection{Question}
\label{sec:orgac71672}
After debugging her program, Alyssa shows it to a potential user, who complains
that her program solves the wrong problem. He wants a program that can deal with
numbers represented as a center value and an additive tolerance; for example, he
wants to work with intervals such as \(3.5 \pm 0.15\) rather than [3.35, 3.65].
Alyssa returns to her desk and fixes this problem by supplying an alternate
constructor and alternate selectors:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))
(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))
(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))
\end{minted}

Unfortunately, most of Alyssa's users are engineers. Real engineering situations
usually involve measurements with only a small uncertainty, measured as the
ratio of the width of the interval to the midpoint of the interval. Engineers
usually specify percentage tolerances on the parameters of devices, as in the
resistor specifications given earlier.

Define a constructor \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{make-center-percent} that takes a center and a
percentage tolerance and produces the desired interval. You must also define a
selector \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{percent} that produces the percentage tolerance for a given
interval. The \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{center} selector is the same as the one shown above.

\subsubsection{Answer}
\label{sec:orgc7c5cd7}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (reciprocal x)
  (/ 1 x))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<reciprocal>>
<<make-interval>>
<<sub-interval>>
<<interval-center-width>>

(define (make-center-percent c pt)
  (let ((pp (* c
               (* pt 0.01))))
    (make-interval (- c pp) (+ c pp))))
(define (percent I)
  (* 100.0
     (/ (width I)
        (center I))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<interval-percent>>
(load "mattcheck2.scm")
  (define (roughly-eq? a b)
    ;; error size varies with magnitude of fp
    ;; so dx must vary too.
    (define dx (* a 0.000001))
    (and (> a (- b dx))
         (< a (+ b dx))))
(define (interval-roughly-eq? I J)
  (and (roughly-eq? (upper-bound I) (upper-bound J))
       (roughly-eq? (lower-bound I) (lower-bound J))))

(let* ((i1 (make-interval 105.0 95.0))
      (i2 (make-center-width 100.0 5))
      (i3 (make-center-percent 100.0 5))
      (i1a (upper-bound i1)))
  (mattcheck "make-center-width"
             i1
             i2)
  (mattcheck "make-center-percent"
             i1
             i3)
  (mattcheck "percent"
             (percent i1)
             (percent i3)
             5.0)
  (mattcheck+ "make-center-percent is consistent"
              (list i1 i3)
              #:eql? interval-roughly-eq?))
\end{minted}

\begin{verbatim}
SUCCEED at make-center-width
SUCCEED at make-center-percent
SUCCEED at percent
SUCCEED at make-center-percent is consistent
\end{verbatim}

\subsection{Exercise 2.13\hfill{}\textsc{optional}}
\label{sec:org1df933f}
\subsubsection{Question}
\label{sec:org47b8ce2}
\begin{quote}
Show that under the assumption of small percentage tolerances there is a simple
formula for the approximate percentage tolerance of the product of two intervals
in terms of the tolerances of the factors. You may simplify the problem by
assuming that all numbers are positive.
\end{quote}

\subsubsection{Answer}
\label{sec:orgb912ea1}
I should've written this function a while ago.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-modules (ice-9 format))
(define (stringit . args)
  (string-append
   (apply string-append
    (map (lambda(x)
          (format #f "~:a " x))
        args))))
(define (echo . args)
  (format #t "~&~:a~%" (apply stringit args)))
\end{minted}

Now, let's examine how interval percents relate to each other.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<echo>>
<<interval-percent>>
<<mul-interval-opt>>

(let* ((i1 (make-center-width 100 5))
       (i2 (make-center-width 200 5))
       (M12 (mul-interval-opt i1 i2)))
  (echo "intervals 1 and 2:" i1 i2)
  (echo "width of 1 and 2:" (width i1) (width i2))
  (echo "percent of 1 and 2:" (percent i1) (percent i2))
  (echo "i1*i2 = " M12)
  (echo "width M12:" (width M12))
  (echo "percent M12:" (percent M12)))
\end{minted}

\begin{verbatim}
intervals 1 and 2: (105 . 95) (205 . 195) 
width of 1 and 2: 5 5 
percent of 1 and 2: 5.0 2.5 
i1*i2 =  (21525 . 18525) 
width M12 1500 
percent M12 7.490636704119851 
\end{verbatim}

Perhaps percent\((A\times B) =\)percent\((A)+\)percent\((B)\)?

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<echo>>
<<interval-percent>>
<<mul-interval-opt>>

(let* ((i1 (make-center-percent 40 0.1))
       (i2 (make-center-percent 200 0.4))
       (M12 (mul-interval-opt i1 i2)))
  (echo "percent of 1 and 2:" (percent i1) (percent i2))
  (echo "percent M12:" (percent M12)))
\end{minted}

\begin{verbatim}
percent of 1 and 2: 0.09999999999999788 0.40000000000000563 
percent M12: 0.499998000008 
\end{verbatim}

\subsection{Exercise 2.14}
\label{sec:org5c46ebc}
\subsubsection{Question}
\label{sec:orgb0cb543}
\begin{quote}
After considerable work, Alyssa P. Hacker delivers her finished system. Several
years later, after she has forgotten all about it, she gets a frenzied call from
an irate user, Lem E. Tweakit. It seems that Lem has noticed that the formula
for parallel resistors can be written in two algebraically equivalent ways:

\[
\frac{R_1 R_2}{R_1 + R_2}
\]

and

\[
\frac{1}{\frac{1}{R_1} + \frac{1}{R_2}}
\]

He has written the following two programs, each of which computes the
parallel-resistors formula differently:
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))

(define (par2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval
     one (add-interval (div-interval one r1)
                       (div-interval one r2)))))
\end{minted}

\begin{quote}
Lem complains that Alyssa's program gives different answers for the two ways of
computing. This is a serious complaint.

Demonstrate that Lem is right. Investigate the behavior of the system on a
variety of arithmetic expressions. Make some intervals \(A\) and \(B\), and use
them in computing the expressions \(A / A\) and \(A / B\). You will get the most
insight by using intervals whose width is a small percentage of the center
value. Examine the results of the computation in center-percent form (see
Exercise 2.12).
\end{quote}

\subsubsection{Answer}
\label{sec:orgdfa2126}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<echo>>
<<interval-percent>>
<<mul-interval-opt>>
<<par-resistors>>

(let* ((A (make-center-percent 10 1))
       (B (make-center-percent 10 0.01))
       (p1 (par1 A B))
       (p2 (par2 A B)))
  (echo "A,B:" A B)
  (echo "par1(A,B):" p1)
  (echo "par2(A,B):" p2)
  (echo "percent(par1):" (percent p1))
  (echo "percent(par2):" (percent p2))
  (echo "center(par1):" (center p1))
  (echo "center(par2):" (center p2)))

(echo "So these two have inconsistent effects on the width.")
(newline)
(echo "It should also be noted that floating-point errors accumulate.")
(echo "Take a look at the error on these (correct answer is 1)")

(let* ((A (make-center-percent 10 1))
       (p1 (div-interval
            (div-interval
             (mul-interval A A)
             A)
            A))
       (p2 (div-interval
            (div-interval
             (div-interval
              (mul-interval
               (mul-interval A A)
               A)
              A)
             A)
            A)))
  (echo "p1:" (center p1))
  (echo "p2:" (center p2)))
\end{minted}

\begin{verbatim}
A,B: (10.1 . 9.9) (10.001 . 9.999) 
par1(A,B): (5.076139504497713 . 4.924635590269141) 
par2(A,B): (5.025128103079449 . 4.974626865671642) 
percent(par1): 1.5149217214958663 
percent(par2): 0.5050247487625606 
center(par1): 5.000387547383427 
center(par2): 4.999877484375546 
So these two have inconsistent effects on the width. 

It should also be noted that floating-point errors accumulate. 
Take a look at the error on these (correct answer is 1) 
p1: 1.0008001600240033 
p2: 1.0018006601460259 
\end{verbatim}

\subsection{Exercise 2.15}
\label{sec:org3fc1210}
\subsubsection{Question}
\label{sec:org184baa5}
\begin{quote}
Eva Lu Ator, another user, has also noticed the different intervals computed by
different but algebraically equivalent expressions. She says that a formula to
compute with intervals using Alyssa's system will produce tighter error bounds
if it can be written in such a form that no variable that represents an
uncertain number is repeated. Thus, she says, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{par2} is a ``better''
program for parallel resistances than \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{par1}. Is she right? Why?
\end{quote}

\subsubsection{Answer}
\label{sec:orged277f5}
If I am correct in understanding that ``uncertain number'' means ``a number with an
error tolerance'', than \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{par2} \emph{is} better -- it only uses two
instances of variables with error tolerance, while \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{par1} uses four.

It should be noted that this system does not directly translate to algebraic
expressions. For example, take these expressions:

\[A + A = 2A\]
\[A - A = 0\]
\[A / A = 1\]

Note that these do not hold up in practice with uncertain numbers:


\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<echo>>
<<interval-percent>>
<<mul-interval-opt>>

(define A (make-center-percent 10 1))
(echo "A+A = 2A !=" (add-interval A A))
(echo "A-A = 0 !=" (sub-interval A A))
(echo "A/A = 1 !=" (div-interval A A))
\end{minted}

\begin{verbatim}
A+A = 2A != (20.2 . 19.8) 
A-A = 0 != (0.1999999999999993 . -0.1999999999999993) 
A/A = 1 != (1.02020202020202 . 0.9801980198019803) 
\end{verbatim}

\subsection{Exercise 2.16\hfill{}\textsc{optional}}
\label{sec:org191cd6a}
\subsubsection{Question}
\label{sec:org5093162}
\begin{quote}
Explain, in general, why equivalent algebraic expressions may lead to different
answers. Can you devise an interval-arithmetic package that does not have this
shortcoming, or is this task impossible? (Warning: This problem is very
difficult.)
\end{quote}

\subsubsection{Answer}
\label{sec:org5db961f}
It is \emph{indeed} very difficult, because from what I'm seeing online, no interval
system without these issues exists. To avoid these issues, interval mathematics
would need to satisfy the conditions for a \textbf{field} -- and failing that, needs to
only use each variable once, which becomes impossible as soon as you encounter
an expression as simple as \(x^2\).

GitHub user ``\texttt{diiq}'' has an incredible analysis of this, which can be found here:
\url{https://gist.github.com/diiq/1f39df0e54b2137bb07e7e04b11cb075}

\subsection{2.2: Hierarchical Data and the Closure Property}
\label{sec:org3f0990f}
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cons} pairs can be used to construct more complex data-types.

\begin{center}
\includegraphics[width=.9\linewidth]{2/cons-cells.jpeg}
\end{center}

The ability to combine things using an operation, then combine those results
using the same operation, can be called the \textbf{closure property}. \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cons} can
create pairs whose elements are pairs, which satisfies the closure property.
This property enables you to create hierarchical structures. We've already
regularly used the closure property in creating procedures composed of other
procedures.

\begin{quote}
\textbf{Definitions of ``closure''}

The use of the word ``closure'' here comes from abstract algebra, where a set of
elements is said to be closed under an operation if applying the operation to
elements in the set produces an element that is again an element of the set.
The Lisp community also (unfortunately) uses the word ``closure'' to describe a
totally unrelated concept: A closure is an implementation technique for
representing procedures with free variables. We do not use the word ``closure''
in this second sense in this book.
\end{quote}

\subsection{2.2.1: Representing Sequences}
\label{sec:org91e559d}
\begin{description}
\item[{\textbf{sequence}}] An ordered collection of data objects.
\item[{\textbf{list}}] A sequence of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cons} pairs.
\end{description}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(cons 1
      (cons 2
            (cons 3
                  (cons 4 nil))))
(list 1 2 3 4)
;; both evaluate to '(1 2 3 4)
\end{minted}


An aside: many parts of this book have covered ways to solve problems by
splitting problems into simple recursive solutions. I may be getting ahead of
myself, but I wanted to note how the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cons} pair system goes
hand-in-hand with this. For example, when going over a list \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{l} with
function \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{f}:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (map f l)
  (if (null? l)
      #nil
      (cons (f (car l))
            (map f (cdr l)))))

(map (lambda(x)(* x 2))
     (list 1 2 3 4))
\end{minted}

\begin{verbatim}
| 2 | 4 | 6 | 8 |
\end{verbatim}

\subsection{Exercise 2.17}
\label{sec:org093b910}
\subsubsection{Question}
\label{sec:org63b839a}
\begin{quote}
Define a procedure
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{last-pair} that returns the list that contains only the last element of a
given (nonempty) list:
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(last-pair (list 23 72 149 34))
;; (34)
\end{minted}

\subsubsection{Answer}
\label{sec:org8aef1be}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (last-pair l)
  (let ((a (car l))
        (d (cdr l)))
    (if (= 1 (length d))
        d
        (last-pair d))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<last-pair>>
(last-pair (list 23 72 149 34))
\end{minted}

\begin{verbatim}
| 34 |
\end{verbatim}

\subsection{Exercise 2.18}
\label{sec:orge363a9f}
\subsubsection{Question}
\label{sec:org03bca6e}
\begin{quote}
Define a procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{reverse} that takes a list as argument and returns
a list of the same elements in reverse order:
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(reverse (list 1 4 9 16 25))
;; (25 16 9 4 1)
\end{minted}

\subsubsection{Answer}
\label{sec:org6fff066}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (reverse l)
  (define len (length l))
  (define (iter i result)
    (if (< (1- len) i)
        result
        (iter (+ i 1)
              (cons (list-ref l i)
                    result))))
  (iter 0 '()))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<reverse>>
(reverse (list 23 72 149 34))
\end{minted}

\begin{center}
\begin{tabular}{rrrr}
34 & 149 & 72 & 23\\[0pt]
\end{tabular}
\end{center}

\subsection{Exercise 2.19}
\label{sec:org1a45b8b}
\subsubsection{Question}
\label{sec:org45b07d2}
\begin{quote}
Consider the change-counting program of 1.2.2. It would be nice to be able to
easily change the currency used by the program, so that we could compute the
number of ways to change a British pound, for example. As the program is
written, the knowledge of the currency is distributed partly into the procedure
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{first-denomination} and partly into the procedure
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{count-change} (which knows that there are five kinds of U.S. coins).
It would be nicer to be able to supply a list of coins to be used for making
change.

We want to rewrite the procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cc} so that its second argument is a
list of the values of the coins to use rather than an integer specifying which
coins to use. We could then have lists that defined each kind of currency:
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
\end{minted}

\begin{quote}
We could then call \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cc} as follows:
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(cc 100 us-coins)
; 292
\end{minted}

\begin{quote}
To do this will require changing the program \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cc} somewhat. It will
still have the same form, but it will access its second argument differently, as
follows:
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination
                 coin-values))
            (cc (- amount
                   (first-denomination
                    coin-values))
                coin-values)))))
\end{minted}

\begin{quote}
Define the procedures \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{first-denomination},
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{except-first-denomination}, and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{no-more?} in terms of
primitive operations on list structures. Does the order of the list
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{coin-values} affect the answer produced by \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cc}? Why or why
not?
\end{quote}

\subsubsection{Answer}
\label{sec:org3a00a8e}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<cc-lists>>

(define us-coins 
  (list 50 25 10 5 1))
(define uk-coins 
  (list 100 50 20 10 5 2 1 0.5))

(define first-denomination car)
(define except-first-denomination cdr)
(define no-more? null?)
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<Ex-2-19>>
(list
 (cc 100 us-coins)
 (cc 100 (reverse us-coins))
 (cc 100 (list 50 10 25 5 1)))
\end{minted}

\begin{verbatim}
| 292 | 292 | 292 |
\end{verbatim}

Apparently, the order of the list does \emph{not} affect the value. However, it does effect the execution time, with small-to-large coin lists taking more time than large-to-small.

\begin{verbatim}
decreasing values: (357503.80704)
increasing values: (823460.64376)
\end{verbatim}

\subsection{Exercise 2.20}
\label{sec:orgf962b6f}
\subsubsection{Question}
\label{sec:org23d5ec2}
\begin{quote}
Use \texttt{[dotted-pair]} notation to write a procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{same-parity} that takes one or
more integers and returns a list of all the arguments that have the same
even-odd parity as the first argument.  For example,
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(same-parity 1 2 3 4 5 6 7)
; (1 3 5 7)
(same-parity 2 3 4 5 6 7)
; (2 4 6)
\end{minted}

\subsubsection{Answer}
\label{sec:org39474d5}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (same-parity . rest)
  (define same?
    (if (even? (car rest))
        even?
        odd?))
  (define (iter l results)
    (if (null? l)
         results
        (let ((a (car l)))
          (iter (cdr l)
                (if (same? a)
                    (cons a results)
                    results)))))
  (iter (reverse rest) '()))

;; Attempting to remove the reversing
(define (same-parity2 . args)
  (define first (car args))
  (define same?
    (if (even? first)
        even?
        odd?))
  (define (iter l results)
    (if (null? l)
        results
        (let ((a (car l))
              (d (cdr l)))
          (if (same? a)
              (iter d (append results
                              (cons a #nil)))
              (iter d results)))))
  (iter (cdr args) (cons first #nil)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<same-parity>>
(list
 (same-parity 1 2 3 4 5 6 7)
 (same-parity2 2 3 4 5 6 7))
\end{minted}

\begin{verbatim}
| 1 | 3 | 5 | 7 |
| 2 | 4 | 6 |   |
\end{verbatim}

\begin{verbatim}
same-parity: (10003.483436)
same-parity2: (56007.042334)
\end{verbatim}

Once again, my attempts to optimize are a complete failure. I'm guessing that
the act of traversing the whole list in the call to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{append} is the
problem.

\subsection{Exercise 2.21}
\label{sec:orgd9e7e21}
\subsubsection{Question}
\label{sec:orgd3665d4}
\begin{quote}
The procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{square-list} takes a list of numbers as argument and
returns a list of the squares of those numbers.
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(square-list (list 1 2 3 4))
;; (1 4 9 16)
\end{minted}

\begin{quote}
Here are two different definitions of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{square-list}. Complete both of
them by filling in the missing expressions:
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (square-list items)
  (if (null? items)
      nil
      (cons <??> <??>)))
(define (square-list items)
  (map <??> <??>))
\end{minted}

\subsubsection{Answer}
\label{sec:org956fecf}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
(define (square-list-manual items)
  (if (null? items)
      #nil
      (cons (square (car items))
            (square-list-manual (cdr items)))))
(define (square-list items)
  (map square items))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square-list>>
(let ((l (list 2 3 4 5 6)))
  (list l
        (square-list-manual l)
        (square-list l)))
\end{minted}

\begin{verbatim}
| 2 | 3 |  4 |  5 |  6 |
| 4 | 9 | 16 | 25 | 36 |
| 4 | 9 | 16 | 25 | 36 |
\end{verbatim}

\subsection{Exercise 2.22}
\label{sec:orgb35af65}
\subsubsection{Questions}
\label{sec:orga7b9fe7}
\begin{quote}
Louis Reasoner tries to rewrite the first \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{square-list} procedure of
Exercise 2.21 so that it evolves an iterative process:
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items nil))
\end{minted}

\begin{quote}
Unfortunately, defining \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{square-list} this way produces the answer
list in the reverse order of the one desired. Why?

Louis then tries to fix his bug by interchanging the arguments to
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cons}:
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square (car things))))))
  (iter items nil))
\end{minted}

\begin{quote}
This doesn't work either.  Explain.
\end{quote}

\subsubsection{Answer}
\label{sec:org1827073}
I'm positive I've made this exact mistake before, though this is likely not
recorded.

The first form of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{square-list} produces a correct list in reverse order:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(square-list (iota 6))
(25 16 9 4 1 0)
\end{minted}

This is because he is prepending to the list every iteration.

While the second produces a broken list, which is literally backwards:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(square-list (iota 6))
((((((#nil . 0) . 1) . 4) . 9) . 16) . 25)
;; Equivalent to:
(cons (cons (cons (cons (cons (cons #nil
                                    0)
                              1)
                        4)
                  9)
            16)
      25)
\end{minted}

Since Lisp was designed with the \texttt{cons pair} structure of list-building, it
needed to define a ``correct'' direction for the pairs to go. Since the Western
world thinks left-to-right, they made it so that the left (first) cell is for
content, and the right is for the pointer to the next pair. However, this means
that you can't append to a list without first traveling its length and changing
the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{nil} marking the end to a pointer to your new pair. Since that is
a lot of list traveling, it makes more sense to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cons} your list
together in reverse and then calling \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{reverse} only once at the end of
the procedure.

\subsection{Exercise 2.23}
\label{sec:org501d2f3}
\subsubsection{Question}
\label{sec:orgeff816e}
\begin{quote}
The procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{for-each} is similar to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{map}. It takes as
arguments a procedure and a list of elements. However, rather than forming a
list of the results, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{for-each} just applies the procedure to each of
the elements in turn, from left to right. The values returned by applying the
procedure to the elements are not used at all---\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{for-each} is used
with procedures that perform an action, such as printing. For example,
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(for-each (lambda (x)
            (newline)
            (display x))
          (list 57 321 88))
;; 57
;; 321
;; 88
\end{minted}

\begin{quote}
The value returned by the call to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{for-each} (not illustrated above)
can be something arbitrary, such as true. Give an implementation of
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{for-each}.
\end{quote}

\subsubsection{Answer}
\label{sec:orgf90d1de}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (for-each-mine proc items)
  (define (iter l)
    (if (null? l)
        #t
        (begin (proc (car l))
               (iter (cdr l)))))
  (iter items))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<for-each-mine>>
(for-each-mine (lambda(x)(display x)(display " ")) (list "all" "your" "base"))
(for-each (lambda(x)(display x)(display " ")) (list "are" "belong" "to" "us"))
\end{minted}

\begin{verbatim}
all your base are belong to us 
\end{verbatim}

\subsection{Exercise 2.24}
\label{sec:orgdbde60a}
\subsubsection{Text Definitions}
\label{sec:orgda05f87}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (count-leaves x)
  (cond ((null? x) 0)
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x))
                 (count-leaves (cdr x))))))
\end{minted}

\subsubsection{Question}
\label{sec:orge2a7f73}
\begin{quote}
Suppose we evaluate the expression \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(list 1 (list 2 (list 3 4)))}.
Give the result printed by the interpreter, the corresponding box-and-pointer
structure, and the interpretation of this as a tree (as in Figure 2.6).
\end{quote}

\subsubsection{Answer}
\label{sec:orgab164a4}
This is sort of a trick question -- on first reading, I read it like a series of
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cons} statements. Looking again, though, I can see that the correct
formulation is as follows:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<echo>>
(let ((l1 (list 1 (list 2 (list 3 4))))
      (l2 (cons 1
                (cons
                 (cons 2
                       (cons
                        (cons 3
                              (cons 4
                                    #nil))
                        #nil))
                 #nil))))
  (echo "textbook version:" l1)
  (echo "cons'd version:" l2))
\end{minted}

\begin{verbatim}
textbook version: (1 (2 (3 4))) 
cons'd version: (1 (2 (3 4))) 
\end{verbatim}

Dot and box version:
\begin{center}
\includegraphics[width=.9\linewidth]{2/fig/24-dotandbox.png}
\end{center}

Tree version:
\begin{center}
\includegraphics[width=.9\linewidth]{2/fig/24-tree.png}
\end{center}

\subsection{Exercise 2.25}
\label{sec:org59d54d6}
\subsubsection{Question}
\label{sec:org9e29ca1}
\begin{quote}
Give combinations of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{car}s and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cdr}s that will pick 7 from
each of the following lists:
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(1 3 (5 7) 9)
((7))
(1 (2 (3 (4 (5 (6 7))))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<echo>>
(let ((l1 (list 1 3 (list 5 7) 9))
      (l2 (list (list 7)))
      (l3 (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7))))))))
  (echo (car (cdaddr l1))
        (caar l2)
        (cadadr (cadadr (cadadr l3)))))
\end{minted}

\begin{verbatim}
7 7 7 
\end{verbatim}

\subsection{Exercise 2.26}
\label{sec:orgc831dcc}
\subsubsection{Question}
\label{sec:org3be5c6a}
\begin{quote}
Suppose we define \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{x} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{y} to be two lists:
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define x (list 1 2 3))
(define y (list 4 5 6))
\end{minted}

\begin{quote}
What result is printed by the interpreter in response to evaluating each of the
following expressions:
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(append x y)
(cons x y)
(list x y)
\end{minted}

\subsubsection{Answer}
\label{sec:orgb2d08c9}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<echo>>
(let* ((x (list 1 2 3))
      (y (list 4 5 6))
      (e1 (append x y))
      (e2 (cons x y))
      (e3 (list x y)))
  (echo "(append x y):" e1)
  (echo "(cons x y):" e2)
  (echo "(list x y):" e3))
\end{minted}

\begin{verbatim}
(append x y): (1 2 3 4 5 6) 
(cons x y): ((1 2 3) 4 5 6) 
(list x y): ((1 2 3) (4 5 6)) 
\end{verbatim}

\subsection{Exercise 2.27}
\label{sec:org62f9a04}
\subsubsection{Question}
\label{sec:org02c5a22}
Modify your \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{reverse} procedure of Exercise 2.18 to produce a
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{deep-reverse} procedure that takes a list as argument and returns as
its value the list with its elements reversed and with all sublists
deep-reversed as well. For example,

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define x (list (list 1 2) (list 3 4)))
x
;; ((1 2) (3 4))
(reverse x)
;; ((3 4) (1 2))
(deep-reverse x)
;; ((4 3) (2 1))
\end{minted}

\subsubsection{Answer}
\label{sec:org750cbf4}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (deep-reverse l)
  (define len (length l))
  (define (iter i result)
    (if (< (1- len) i)
        result
        (iter (+ i 1)
              (cons (let ((here (list-ref l i)))
                      (if (pair? here)
                          (deep-reverse here)
                          here))
                    result))))
  (iter 0 '()))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<deep-reverse>>
(deep-reverse (list (list 1 2) (list 3 4)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
((4 3) (2 1))
\end{minted}

\subsection{Exercise 2.28}
\label{sec:org8abaea4}
\subsubsection{Question}
\label{sec:org57487f3}
Write a procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{fringe} that takes as argument a tree (represented
as a list) and returns a list whose elements are all the leaves of the tree
arranged in left-to-right order. For example,

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define x (list (list 1 2) (list 3 4)))
(fringe x)
;; (1 2 3 4)
(fringe (list x x))
;; (1 2 3 4 1 2 3 4)
\end{minted}

\subsubsection{Answer}
\label{sec:org627b443}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (fringe l)
  (if (null? l)
      #nil
      (let ((a (car l))
            (d (cdr l)))
        (append (if (pair? a)
                    (fringe a)
                    (list a))
                (fringe d)))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<fringe>>
(fringe (list (list 1 (list 2 3)) (list 4 5)))
\end{minted}

\begin{verbatim}
(1 2 3 4 5)
\end{verbatim}

\subsection{Exercise 2.29: Binary Mobiles}
\label{sec:orged53546}
\subsubsection{Text Definitions}
\label{sec:orgf37201c}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (make-mobile left right)
  (list left right))

(define (make-branch length structure)
  (list length structure))
\end{minted}

\subsubsection{Question A: Selectors}
\label{sec:org30e3129}
\begin{quote}
Write the corresponding selectors \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{left-branch} and
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{right-branch}, which return the branches of a mobile, and
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{branch-length} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{branch-structure}, which return the
components of a branch.
\end{quote}

\subsubsection{Answer A}
\label{sec:orge81126e}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<mobile-constructors-list>>
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (cadr mobile))
(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (cadr branch))
\end{minted}

\subsubsection{Question B: total-weight}
\label{sec:orgdc1fd12}
\begin{quote}
Using your selectors, define a procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{total-weight} that returns
the total weight of a mobile.
\end{quote}

\subsubsection{Answer B}
\label{sec:org9b74eea}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (total-weight mobile)
  (let ((leftS (branch-structure (left-branch mobile)))
        (rightS (branch-structure (right-branch mobile))))
    (+ (if (number? leftS)
           leftS
           (total-weight leftS))
       (if (number? rightS)
           rightS
           (total-weight rightS)))))
\end{minted}


\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<mobile-selectors-list>>
<<mobile-total-weight>>

(let ((M1 (make-mobile
           (make-branch 5 5)
           (make-branch 1
                        (make-mobile (make-branch 2 2)
                                     (make-branch 2 3)))))
      (M2 (make-mobile
           (make-branch 2
                        (make-mobile
                         (make-branch 2 2)
                         (make-branch 2 2)))
           (make-branch 2
                        (make-mobile
                         (make-branch 2 2)
                         (make-branch 2 2))))))
  (list (total-weight M1)
        (total-weight M2)))
\end{minted}

\begin{verbatim}
| 10 | 8 |
\end{verbatim}

\subsubsection{Question C: Balancing}
\label{sec:org55ddb35}
A mobile is said to be \textbf{balanced} if the torque applied by its top-left branch is
equal to that applied by its top-right branch (that is, if the length of the
left rod multiplied by the weight hanging from that rod is equal to the
corresponding product for the right side) and if each of the submobiles hanging
off its branches is balanced. Design a predicate that tests whether a binary
mobile is balanced.

\subsubsection{Answer C}
\label{sec:org28bf786}
I can imagine a ton of ways I could shoot myself in the foot by starting with
optimization, so let's just try to nail down exactly what needs to happen.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (total-torque branch)
  (let ((len (branch-length branch))
        (struct (branch-structure branch)))
    (* len
       (if (number? struct)
           struct
           (let ((lbs (branch-structure (left-branch struct)))
                 (rbs (branch-structure (right-branch struct))))
             (+ (total-weight lbs)
                (total-weight rbs)))))))
(define (balanced? mobile)
  (let* ((l (left-branch mobile))
         (ls (branch-structure l))
         (r (right-branch mobile))
         (rs (branch-structure r))
         (l-balanced (if (number? ls)
                         #t
                         (balanced? ls)))
         (r-balanced (if (number? rs)
                         #t ;; Fixed: accidentally used ls again.
                         (balanced? rs))))
    (if (and l-balanced r-balanced)
        (= (total-torque l)
           (total-torque r))
        #f)))
\end{minted}

I'll also need a modified \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{total-weight} that can notice when its
argument is a non-mobile and just return the value.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (total-weight mobile)
  (if (number? mobile)
      mobile ;; this is a weight, just return it
      (let ((leftS (branch-structure (left-branch mobile)))
            (rightS (branch-structure (right-branch mobile))))
        (+ (if (number? leftS)
               leftS
               (total-weight leftS))
           (if (number? rightS)
               rightS
               (total-weight rightS))))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<echo>>
<<mobile-selectors-list>>
<<mobile-total-weight-2>>
<<mobile-balanced-dumb>>
(define M1 ;; all segments unbalanced
  (make-mobile
   (make-branch 5 5) ;; torque 25 = 5*5
   (make-branch 1 ;; torque 5 = (2 + 3) * 1
                (make-mobile (make-branch 2 2)
                             (make-branch 2 3)))))
(define M2 ;; all segments balanced as they are duplicates
  (make-mobile
   (make-branch 2 ;; torque 8 = 2*(2+2)
                (make-mobile
                 (make-branch 2 2)
                 (make-branch 2 2)))
   (make-branch 2
                (make-mobile
                 (make-branch 2 2)
                 (make-branch 2 2)))))
(define M3 ;; equal torque, but one segment is unbalanced.
  (make-mobile
   (make-branch 2 ;; torque 12 = 2*(4+2)
                (make-mobile
                 (make-branch 2 4) ;; torque 8 = 2*4
                 (make-branch 4 2))) ;torque 8 = 4*2
   (make-branch 3 ;; torque 12 = 3*(1+3)
                (make-mobile
                 (make-branch 1 1) ;; torque 1
                 (make-branch 1 3))))) ;; torque 3
(define M4 ;; equal torque
  (make-mobile
   (make-branch 2 ;; torque 12 = 2*(4+2)
                (make-mobile
                 (make-branch 2 4) ;; torque 8 = 2*4
                 (make-branch 4 2))) ;torque 8 = 4*2
   (make-branch 3 ;; torque 12 = 3*(1+3)
                (make-mobile
                 (make-branch 3 1) ;; torque 3
                 (make-branch 1 3))))) ;; torque 3
(define (isbalanced? Name Status)
  (define Success "is balanced!")
  (define Failure "is not balanced!")
  (if (eq? Status #t)
      (echo Name Success)
      (echo Name Failure)))
(isbalanced? "M1" (balanced? M1))
(isbalanced? "M2" (balanced? M2))
(isbalanced? "M3" (balanced? M3))
(isbalanced? "M4" (balanced? M4))
\end{minted}

\begin{verbatim}
M1 is not balanced! 
M2 is balanced! 
M3 is not balanced! 
M4 is balanced! 
\end{verbatim}

This one took quite some fiddling. First I struggled to figure out exactly how I
should juggle of torque, weight, and balance. For example, a mobile is balanced
if the torques of its branches are equal, and if every submobile is also
balanced, with torque being defined as length\(\times\)weight. Note that it's
the \emph{weight}, not its submobile's \emph{torque}.

TODO: I'd like to come back and make an optimized version that doesn't have to
crawl the tree multiple times. Maybe getting torque/weight/balanced status at
the same time?

\subsubsection{Question D: Implementation shakeup}
\label{sec:org2982493}
\begin{quote}
Suppose we change the representation of mobiles so that the constructors are
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (make-mobile left right)
  (cons left right))

(define (make-branch length structure)
  (cons length structure))
\end{minted}

\begin{quote}
How much do you need to change your programs to convert to the new representation?
\end{quote}

\subsubsection{Answer D}
\label{sec:org57e6611}
Ideally I should only need to change the selectors, like this:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<mobile-constructors-cons>>
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (cdr mobile))
(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (cdr branch))
\end{minted}

Now, if I run the same code, I should get the same result:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<echo>>
<<mobile-selectors-cons>>
<<mobile-total-weight-2>>
<<mobile-balanced-dumb>>
(define M1 ;; all segments unbalanced
  (make-mobile
   (make-branch 5 5) ;; torque 25 = 5*5
   (make-branch 1 ;; torque 5 = (2 + 3) * 1
                (make-mobile (make-branch 2 2)
                             (make-branch 2 3)))))
(define M2 ;; all segments balanced as they are duplicates
  (make-mobile
   (make-branch 2 ;; torque 8 = 2*(2+2)
                (make-mobile
                 (make-branch 2 2)
                 (make-branch 2 2)))
   (make-branch 2
                (make-mobile
                 (make-branch 2 2)
                 (make-branch 2 2)))))
(define M3 ;; equal torque, but one segment is unbalanced.
  (make-mobile
   (make-branch 2 ;; torque 12 = 2*(4+2)
                (make-mobile
                 (make-branch 2 4) ;; torque 8 = 2*4
                 (make-branch 4 2))) ;torque 8 = 4*2
   (make-branch 3 ;; torque 12 = 3*(1+3)
                (make-mobile
                 (make-branch 1 1) ;; torque 1
                 (make-branch 1 3))))) ;; torque 3
(define M4 ;; equal torque
  (make-mobile
   (make-branch 2 ;; torque 12 = 2*(4+2)
                (make-mobile
                 (make-branch 2 4) ;; torque 8 = 2*4
                 (make-branch 4 2))) ;torque 8 = 4*2
   (make-branch 3 ;; torque 12 = 3*(1+3)
                (make-mobile
                 (make-branch 3 1) ;; torque 3
                 (make-branch 1 3))))) ;; torque 3
(define (isbalanced? Name Status)
  (define Success "is balanced!")
  (define Failure "is not balanced!")
  (if (eq? Status #t)
      (echo Name Success)
      (echo Name Failure)))
(isbalanced? "M1" (balanced? M1))
(isbalanced? "M2" (balanced? M2))
(isbalanced? "M3" (balanced? M3))
(isbalanced? "M4" (balanced? M4))
\end{minted}

\begin{verbatim}
M1 is not balanced! 
M2 is balanced! 
M3 is not balanced! 
M4 is balanced! 
\end{verbatim}

\subsection{Exercise 2.30}
\label{sec:org4469e80}
\subsubsection{Question}
\label{sec:org8b3d580}
Define a procedure
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{square-tree} analogous to the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{square-@/list} procedure of
\ref{sec:orgd9e7e21}.  That is, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{square-tree} should behave as follows:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
;; (1 (4 (9 16) 25) (36 49))
\end{minted}

Define \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{square-tree} both directly (i.e., without using any higher-order
procedures) and also by using \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{map} and recursion.

\subsubsection{Answer}
\label{sec:orgc75841b}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<square>>
(define (square-tree-discrete tree)
  (cond ((null? tree) '())
        ((not (pair? tree)) (square tree))
        (else (cons (square-tree-discrete (car tree))
                    (square-tree-discrete (cdr tree))))))

(define (square-tree-map tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (square-tree-map sub-tree)
             (square sub-tree)))
       tree))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<square-tree>>
(let ((testlist
       (list 1
             (list 2 (list 3 4) 5)
             (list 6 7)))
      (answer
       (list 1
             (list 4 (list 9 16) 25)
             (list 36 49))))
  (mattcheck "square-tree-discrete"
             (square-tree-discrete testlist)
             answer)
  (mattcheck "square-tree-map"
             (square-tree-map testlist)
             answer))
\end{minted}

\begin{verbatim}
SUCCEED at square-tree-discrete
SUCCEED at square-tree-map
\end{verbatim}

While writing that, I ran headfirst into a lesson I've had to repeatedly learn: default Guile functions end their lists with \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{'()} which does not match equality with lists ended with \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{#nil}.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(let ((parens-list (cons 1 (cons 2 (cons 3 '()))))
      (nil-list (cons 1 (cons 2 (cons 3 #nil)))))
  (display parens-list)(display " <== ends with '()")
  (newline)
  (display nil-list)(display " <== ends with #nil")
  (newline)
  (display "Are these two lists equal? > ")
  (display (equal? parens-list nil-list))
  (newline)
  (display "Does Guile consider #nil and '() equal? > ")
  (display (equal? #nil '()))
  (newline)
  (display "What about #nil and #f? > ")
  (display (equal? #nil #f)))
\end{minted}

\begin{verbatim}
(1 2 3) <== ends with '()
(1 2 3) <== ends with #nil
Are these two lists equal? > #f
Does Guile consider #nil and '() equal? > #f
What about #nil and #f? > #f
\end{verbatim}

\subsection{Exercise 2.31}
\label{sec:orgb50ca73}
\subsubsection{Question}
\label{sec:orgd6dfde4}
\begin{quote}
Abstract your answer to \ref{sec:org4469e80} to produce a procedure
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{tree-map} with the property that \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{square-tree} could be
defined as
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (square-tree tree) (tree-map square tree))
\end{minted}

\subsubsection{Answer}
\label{sec:org72d5d3e}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (tree-map f tree)
  (cond ((null? tree) '())
        ((not (pair? tree)) (f tree))
        (else (cons (tree-map f (car tree))
                    (tree-map f (cdr tree))))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<tree-map>>
<<square>>
(define (square-tree-tm tree)
  (tree-map square tree))
(let ((testlist
       (list 1
             (list 2 (list 3 4) 5)
             (list 6 7)))
      (answer
       (list 1
             (list 4 (list 9 16) 25)
             (list 36 49))))
  (mattcheck "square-tree-tm"
             (square-tree-tm testlist)
             answer))
\end{minted}

\begin{verbatim}
SUCCEED at square-tree-tm
\end{verbatim}

\subsection{Exercise 2.32}
\label{sec:org4026b21}
\subsubsection{Question}
\label{sec:org0cd19ad}
\begin{quote}
We can represent a set as a list of distinct elements, and we can represent the
set of all subsets of the set as a list of lists. For example, if the set is
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(1 2 3)}, then the set of all subsets is \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))}. Complete the following definition of a procedure that
generates the set of subsets of a set and give a clear explanation of why it
works:
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map <??> rest)))))
\end{minted}

\subsubsection{Answer}
\label{sec:org434e30e}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (subsets s)
  (if (null? s)
      (list '())
      (let ((rest (subsets (cdr s))))
        (append rest (map (lambda(x)
                            (cons (car s) x))
                          rest)))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<subsets>>
(load "mattcheck2.scm")
(let ((answer
       (list '()
             (list 3)
             (list 2) (list 2 3)
             (list 1) (list 1 3)
             (list 1 2) (list 1 2 3))))
  (mattcheck "subsets"
             (subsets (list 1 2 3))
             answer))
\end{minted}

\begin{verbatim}
SUCCEED at subsets
\end{verbatim}

Essentially, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{subsets} is rotating through members of the list in a
similar way that a counter incrementing rotates through all numbers in its base.
For a list with items \(1\) to \(n\), \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{subsets} makes a list with the
last item, \([n]\), then lists \([n-1]\) and \([n-1, n]\), then lists
\([n-2][n-2, n-1][n-2,n]\), then \([n-3][n-3,n-2][n-3,n-1][n-3,n]\) and so on.

I'd like to try adding some debugging statements to subsets and see if it might
help clarify the operation.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<echo>>
(define (doit f x)
  (f x) ;; this probably has a formal lambda calculus name
  x)    ;; but I don't know what it is
(define (echo-return x)
  (doit echo x))
(define (echo-y-return-x x . y)
  (apply echo y)
  x)
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<subsets>>
<<echo-return>>
(define (subsets-debug s)
  (echo "Enter with" s "{")
  (let ((a1
         (if (null? s)
             (echo-return (list '()))
             (let ((rest (subsets-debug (cdr s))))
               (echo "[ iter" (car s) "over" rest "]")
               (append rest (map (lambda(x)
                                   (let ((y (cons (car s) x)))
                                     (format #t "~a " y)
                                     y))
                                 rest))))))
    (echo "} end" s)
    a1))
(let ((answer
       (list '()
             (list 3)
             (list 2) (list 2 3)
             (list 1) (list 1 3)
             (list 1 2) (list 1 2 3))))
  (subsets-debug (list 1 2 3))
  answer)
\end{minted}

\begin{verbatim}
Enter with (1 2 3) { 
Enter with (2 3) { 
Enter with (3) { 
Enter with () { 
(()) 
} end () 
[ iter 3 over (()) ] 
(3) 
} end (3) 
[ iter 2 over (() (3)) ] 
(2) (2 3) 
} end (2 3) 
[ iter 1 over (() (3) (2) (2 3)) ] 
(1) (1 3) (1 2) (1 2 3) 
} end (1 2 3) 
\end{verbatim}

\subsection{2.2.3: Sequences as Conventional Interfaces}
\label{sec:orgee3e28c}
Abstractions are an important part of making code clearer and more easy to
understand. One beneficial manner of abstraction is making available
conventional interfaces for working with compound data, such as
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{filter} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{map}.

This allows for easily making ``signal-flow'' conceptions of processes:

\begin{center}
\includegraphics[width=0.3\linewidth]{2/fig/t_2-2-3.png}
\end{center}

\subsection{Exercise 2.33: The flexibility of \texttt{accumulate}}
\label{sec:orgaa4512a}
\subsubsection{Text Definitions}
\label{sec:orgf2ae8b6}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op 
                      initial 
                      (cdr sequence)))))
\end{minted}

\subsubsection{Question}
\label{sec:org29b4bbe}
\begin{quote}
Fill in the missing expressions to complete the following definitions of some basic list-manipulation operations as accumulations.
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (map p sequence)
  (accumulate (lambda (x y) <??>) nil sequence))
(define (append seq1 seq2)
  (accumulate cons <??> <??>))
(define (length sequence)
  (accumulate <??> 0 sequence))
\end{minted}

\subsubsection{Answer}
\label{sec:orga37c31d}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (map-acc p sequence)
  (accumulate (lambda (x y)
                (cons (p x) y))
              '() sequence))
(define (append-acc seq1 seq2)
  (accumulate cons seq2 seq1))
(define (length-acc sequence)
  (accumulate (lambda(x y)
                (1+ y))
              0 sequence))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<accumulate>>
<<accumulate-forms>>
<<square>>
(let ((l (list 1 2 3 4)))
  (mattcheck "map"
             (map square l)
             (map-acc square l))
  (mattcheck "append"
             (append l l)
             (append-acc l l))
  (mattcheck "length"
             (length l)
             (length-acc l)))
\end{minted}

\begin{verbatim}
SUCCEED at map
SUCCEED at append
SUCCEED at length
\end{verbatim}

\subsection{Exercise 2.34}
\label{sec:orga75d8ab}
\subsubsection{Question}
\label{sec:orgbdd2768}
\begin{quote}
Evaluating a polynomial in \(x\) at a given value of \(x\) can be formulated as
an accumulation. We evaluate the polynomial

\[ a_n x^n + a_{n-1} x^{n-1} + \dots + a_1 x + a_0 \]

using a well-known algorithm called \emph{Horner's rule}, which structures the
computation as

\[ (\dots (a_n x + a_{n-1}) x + \dots + a_1) x + a_0. \]

In other words, we start with \(a_n\), multiply by \(x\), add \(a_{n-1}\),
multiply by \(x\), and so on, until we reach \(a_0\).

Fill in the following template to produce a procedure that evaluates a
polynomial using Horner's rule. Assume that the coefficients of the polynomial
are arranged in a sequence, from \(a_0\) through \(a_n\).
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) <??>)
              0
              coefficient-sequence))
\end{minted}

\begin{quote}
For example, to compute \(1 + 3x + 5x^3 + x^5\) at \(x = 2\) you
would evaluate
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(horner-eval 2 (list 1 3 0 5 0 1))
\end{minted}

\subsubsection{Answer}
\label{sec:org1e515b3}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms)
                (+ this-coeff
                   (* higher-terms x)))
              0
              coefficient-sequence))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<accumulate>>
<<horner-eval>>
(mattcheck "horner-eval"
           (horner-eval 2 (list 1 3 0 5 0 1))
           79)
\end{minted}

\begin{verbatim}
SUCCEED at horner-eval
\end{verbatim}

This one was very satisfying. It essentially ``delays'' the exponentiation, carrying it out per stage, by rewriting this:

\(1 + 3 \times 2 + 5 \times 2^3 + 2^5\)

Into this operation, left to right:

\[ 0+1*2+0*2+0*2+3*2+1 \]


\subsection{Exercise 2.35}
\label{sec:orga5f328f}
\subsubsection{Question}
\label{sec:org04569c7}
\begin{quote}
Redefine \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{count-leaves} from
2.2.2 as an accumulation:
\end{quote}

\subsubsection{Answer}
\label{sec:org5166be9}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (count-leaves-acc t)
  (accumulate (lambda(i total)
                (+ i total))
              0 (map (lambda(x)
                       (if (pair? x)
                           (count-leaves-acc x)
                           1))
                     t)))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<accumulate>>
<<count-leaves>>
<<count-leaves-acc>>
(let ((l (list (list (list 1 2 3) 4) (list 5 (list 6 7) 8))))
  (mattcheck "count-leaves-acc"
              (count-leaves l)
              (count-leaves-acc l)))
\end{minted}

\begin{verbatim}
SUCCEED at count-leaves-acc
\end{verbatim}

\subsection{Exercise 2.36: Accumulate across multiple lists}
\label{sec:org798a794}
\subsubsection{Question}
\label{sec:org4773293}
\begin{quote}
The procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{accumulate-n} is similar to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{accumulate}
except that it takes as its third argument a sequence of sequences, which are
all assumed to have the same number of elements. It applies the designated
accumulation procedure to combine all the first elements of the sequences, all
the second elements of the sequences, and so on, and returns a sequence of the
results. For instance, if \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{s} is a sequence containing four sequences,
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{((1 2 3) (4 5 6) (7 8 9) (10 11 12))}, then the value of
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(accumulate-n + 0 s)} should be the sequence \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(22 26 30)}.
Fill in the missing expressions in the following definition of
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{accumulate-n}:
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init <??>)
            (accumulate-n op init <??>))))
\end{minted}

\subsubsection{Answers}
\label{sec:org0b363c0}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      '()
      (cons (accumulate op init
                        (map car seqs))
            (accumulate-n op init
                          (map cdr seqs)))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<accumulate>>
<<accumulate-n>>
(let ((s (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12))))
  (mattcheck "accumulate-n"
             (accumulate-n + 0 s)
             (list 22 26 30)))
\end{minted}

\begin{verbatim}
SUCCEED at accumulate-n
\end{verbatim}

\subsection{Exercise 2.37: Enter the matrices}
\label{sec:org342d0fa}
\subsubsection{Question}
\label{sec:org6539407}
\emph{See full quote in book.}

Suppose we represent vectors as lists, and matrices as lists of vectors. For example:

\left(
\begin{array}{cccc}
  1 & 2 & 3 & 4 \\
  4 & 5 & 6 & 6 \\
  6 & 7 & 8 & 9
\end{array}
\right)

\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{'((1 2 3 4) (4 5 6 6) (6 7 8 9))}

Define these operations:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
(define (matrix-*-vector m v)
  (map <??> m))
(define (transpose mat)
  (accumulate-n <??> <??> mat))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map <??> m)))
\end{minted}
\subsubsection{Answer}
\label{sec:org0c49417}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
(define (matrix-*-vector m v)
  (map (lambda(row)
         (dot-product v row))
       m))
(define (transpose mat)
  (accumulate-n cons '() mat))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda(row)
           (map (lambda(col)
                  (dot-product row col))
                cols))
           m)))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<echo>>
<<accumulate>>
<<accumulate-n>>
<<matrix-ops>>
(let* ((v1 (list 1 2 3 4))
      (v2 (list 5 6 7 8))
      (m1 (list v1 v2))
      (m1t (list (list 1 5)
                (list 2 6)
                (list 3 7)
                (list 4 8)))
      (m1-*-m1t (list (list 30 70)
                      (list 70 174))))
  (mattcheck "transpose"
             (transpose m1)
             m1t)
  (mattcheck "dot-product"
             (dot-product v1 v2)
             70)
  (mattcheck "matrix-*-vector"
             (matrix-*-vector m1 v1)
             (list 30 70))
  (mattcheck "matrix-*-matrix"
             (matrix-*-matrix m1 m1t)
             m1-*-m1t))
\end{minted}

\begin{verbatim}
SUCCEED at transpose
SUCCEED at dot-product
SUCCEED at matrix-*-vector
SUCCEED at matrix-*-matrix
\end{verbatim}

I struggled a lot with what order things should be processed and applied in.
Some of that came from never having done matrix multiplication before now. I
would probably still not understand it if I hadn't found \href{https://youtu.be/MfN1lqArwAg}{Herb Gross' lecture
regarding matrix operations}\footnote{\url{https://youtu.be/MfN1lqArwAg}}.

The other issue is nested map operations. I find it easy to read Python-ish
code like this:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{python}
# Pseudocode
for row in m1:
    for column in m2t:
        for a,b in row,column:
            answer[i:j] += a*b
\end{minted}

But much harder to comprehend Lisp code like this:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(map (lambda(row)
       (map (lambda(col)
              (dot-product row col))
            m1t))
     m1)
\end{minted}

I must have a mental block in the way I think about map operations.

\subsection{Exercise 2.38: fold-right}
\label{sec:org7ac7cf4}
\subsubsection{Question A}
\label{sec:org031cffb}
\begin{quote}
The \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{accumulate} procedure
is also known as \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{fold-right}, because it combines the first element of
the sequence with the result of combining all the elements to the right.  There
is also a \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{fold-left}, which is similar to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{fold-right}, except that
it combines elements working in the opposite direction:
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
\end{minted}

\begin{quote}
What are the values of
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(fold-right / 1 (list 1 2 3))
(fold-left / 1 (list 1 2 3))
(fold-right list nil (list 1 2 3))
(fold-left list nil (list 1 2 3))
\end{minted}

\subsubsection{Answer A}
\label{sec:org0c99b85}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<accumulate>>
(define fold-right accumulate)
<<fold-left>>
<<echo>>
(echo "(fold-right / 1 (list 1 2 3)):" (fold-right / 1 (list 1 2 3)))
(echo "(fold-left / 1 (list 1 2 3)):" (fold-left / 1 (list 1 2 3)))
(echo "(fold-right list nil (list 1 2 3))" (fold-right list '() (list 1 2 3)))
(echo "(fold-left list nil (list 1 2 3))" (fold-left list '() (list 1 2 3)))
\end{minted}

\begin{verbatim}
(fold-right / 1 (list 1 2 3)): 3/2 
(fold-left / 1 (list 1 2 3)): 1/6 
(fold-right list nil (list 1 2 3)) (1 (2 (3 ()))) 
(fold-left list nil (list 1 2 3)) (((() 1) 2) 3) 
\end{verbatim}

\subsubsection{Question B}
\label{sec:orgd9e86be}
\begin{quote}
Give a property that \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{op} should satisfy to guarantee that
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{fold-right} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{fold-left} will produce the same values
for any sequence.
\end{quote}

\subsubsection{Answer B}
\label{sec:org14c4c98}
They would need to be commutative, like addition and multiplication.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<accumulate>>
(define fold-right accumulate)
<<fold-left>>
<<echo>>

(let* ((l (list 1 2 3 4 5))
      (lr (reverse l)))
  (mattcheck "commutative addition"
             (fold-right + 0 l)
             (fold-right + 0 lr)
             (fold-left + 0 l)
             (fold-left + 0 lr))
  (mattcheck "commutative multiplication"
             (fold-right * 1 l)
             (fold-right * 1 lr)
             (fold-left * 1 l)
             (fold-left * 1 lr)))
\end{minted}

\begin{verbatim}
SUCCEED at commutative addition
SUCCEED at commutative multiplication
\end{verbatim}

\subsection{Exercise 2.39: reverse via fold}
\label{sec:org4f8b0af}
\subsubsection{Question}
\label{sec:org08032bf}
\begin{quote}
Complete the following
definitions of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{reverse} (Exercise 2.18) in terms of
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{fold-right} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{fold-left} from Exercise 2.38:
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (reverse sequence)
  (fold-right (lambda (x y) <??>) nil sequence))
(define (reverse sequence)
  (fold-left (lambda (x y) <??>) nil sequence))
\end{minted}

\subsubsection{Answer}
\label{sec:orgb3644f9}
First, I'd like to start using the SRFI folds instead. This is my little ``compatibility module''.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; SICP compat
(use-srfis '(1))
(define accumulate fold-right)
(define fold-left fold)
\end{minted}

Now to the problem.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<fold-compat>>
(define (reverse-fr sequence)
  (fold-right (lambda (x y)
                (append  y (list x)))
              '() sequence))
(define (reverse-fl sequence)
  (fold-left (lambda (x y)
               (append (list x) y))
             '() sequence))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<reverse-fold>>
(let ((l (iota 5))
      (lr (reverse (iota 5))))
  (mattcheck "reverse-fr"
             (reverse-fr l)
             lr)
  (mattcheck "reverse-fl"
             (reverse-fl l)
             lr))
\end{minted}

\begin{verbatim}
SUCCEED at reverse-fr
SUCCEED at reverse-fl
\end{verbatim}

\subsection{Exercise 2.40: \texttt{unique-pairs}}
\label{sec:orge458f4c}
\subsubsection{Text Definitions}
\label{sec:org84b049d}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (enumerate-interval low high)
  (if (> low high)
      '()
      (cons low 
            (enumerate-interval 
             (+ low 1) 
             high))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<fold-compat>>
(define (flatmap proc seq)
  (accumulate append '() (map proc seq)))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<flatmap>>
<<enumerate-interval>>
<<prime-smallest-divisor>>
(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))
(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum? (flatmap
                           (lambda (i)
                             (map (lambda (j) (list i j))
                                  (enumerate-interval 1 (- i 1))))
                           (enumerate-interval 1 n)))))
\end{minted}

\subsubsection{Question}
\label{sec:org6fd91e3}
\begin{quote}
Define a procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{unique-pairs} that, given an integer \(n\),
generates the sequence of pairs \((i, j)\) with \(1 \le j < i \le n\). Use
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{unique-pairs} to simplify the definition of
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{prime-sum-pairs} given above.
\end{quote}

\subsubsection{Answer}
\label{sec:org710cf95}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<fold-compat>>
<<enumerate-interval>>
<<flatmap>>
(define (unique-pairs n)
  (flatmap
   (lambda (i)
     (map (lambda (j) (list i j))
          (enumerate-interval 1 (- i 1))))
   (enumerate-interval 1 n)))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<unique-pairs>>
(let ((target 5)
      (answer (list (list 2 1)(list 3 1)(list 3 2)(list 4 1)
                    (list 4 2)(list 4 3)(list 5 1)(list 5 2)
                    (list 5 3)(list 5 4))))
  (mattcheck "unique-pairs"
             (unique-pairs target)
             answer))
<<echo>>
<<prime-sum-txt>>
(define (prime-sum-pairs-mine n)
  (map make-pair-sum
       (filter prime-sum?
               (unique-pairs n))))
(let ((answer (list (list 2 1 3) (list 3 2 5)
                    (list 4 1 5) (list 4 3 7)
                    (list 5 2 7)) ))
  (mattcheck "prime-sum-pairs with unique-pairs"
             (prime-sum-pairs-mine 5)
             answer))
\end{minted}

\begin{verbatim}
SUCCEED at unique-pairs
SUCCEED at prime-sum-pairs with unique-pairs
\end{verbatim}

\subsection{Exercise 2.41: Ordered triples of positive integers}
\label{sec:orga807a89}
\subsubsection{Question}
\label{sec:org185dfab}
\begin{quote}
Write a procedure to find all ordered triples of distinct positive integers
\(i\), \(j\), and \(k\) less than or equal to a given integer \(n\) that sum to
a given integer \(s\).
\end{quote}

\subsubsection{Answer}
\label{sec:org9df28f1}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<fold-compat>>
<<enumerate-interval>>
<<flatmap>>
(define (unique-triplets n)
  (flatmap (lambda(i)
             (flatmap (lambda(j)
                        (map (lambda(k) (list i j k))
                             (enumerate-interval 1 (- j 1))))
                      (enumerate-interval 1 (- i 1))))
           (enumerate-interval 1 n)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (triplets-sum n s)
  (filter (lambda(triplet)
            (= s (fold + 0 triplet)))
          (unique-triplets n)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<unique-triplets>>
<<triplets-sum>>
(let ((answer-a
       (list (list 3 2 1) (list 4 2 1)
             (list 4 3 1) (list 4 3 2)
             (list 5 2 1) (list 5 3 1)
             (list 5 3 2) (list 5 4 1)
             (list 5 4 2) (list 5 4 3)))
      (answer-b
       (list (list 5 3 2) (list 5 4 1)
             (list 6 3 1) (list 7 2 1))))
  (mattcheck "unique-triplets"
             (unique-triplets 5)
             answer-a)
  (mattcheck "triplets-sum"
             (triplets-sum 7 10)
             answer-b))
\end{minted}

\begin{verbatim}
SUCCEED at unique-triplets
SUCCEED at triplets-sum
\end{verbatim}

\subsection{Exercise 2.42: Eight Queens}
\label{sec:org1578366}
\subsubsection{Question}
\label{sec:org660a9ea}
\begin{quote}
The ``eight-queens puzzle'' asks how to place eight queens on a chessboard so
that no queen is in check from any other.
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<flatmap>>
<<enumerate-interval>>
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position
                    new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
\end{minted}

\begin{quote}
Complete the program by writing the following:
\begin{itemize}
\item representation for sets of board positions, including:
\begin{itemize}
\item \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{adjoin-position}, which adjoins a new row-column position to a
set of positions
\item \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{empty-board}, which represents an empty set of positions.
\end{itemize}
\item \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{safe?}, which determines for a set of positions, whether the queen
in the \(k^{\mathrm{th}}\) column is safe with respect to the others. (Note
that we need only check whether the new queen is safe---the other queens are
already guaranteed safe with respect to each other.)
\end{itemize}
\end{quote}

\subsubsection{Answer}
\label{sec:orgc959aa3}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define empty-board '())
(define (adjoin-position new-row column rest-of-queens)
  (cons (list new-row column) rest-of-queens))
(define (newer-position board)
  (car board))
(define (older-positions board)
  (cdr board))
(define (get-row position)
  (car position))
(define (get-column position)
  (cadr position))
(define (safe? k board)
  (define (same-row? a b)
    (= (get-row a) (get-row b)))
  (define (diagonal? a b)
    (let ((row-diff (abs (- (get-row a) (get-row b))))
          (col-diff (abs (- (get-column a) (get-column b)))))
      (= row-diff col-diff)))
  (let* ((new (newer-position board))
         (compare (older-positions board)))
    (and-map (lambda(pos)
               (not (or (same-row? new pos)
                   (diagonal? new pos))))
             compare)))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<queens-txt>>
<<queens-mine>>
(load "mattcheck2.scm")
(let ((q4 '(((3 4) (1 3) (4 2) (2 1))
            ((2 4) (4 3) (1 2) (3 1))))
       (q11l 2680))
  (mattcheck "queens"
             (list (queens 4)
                   (length (queens 11)))
             (list q4 q11l)))
\end{minted}

\begin{verbatim}
SUCCEED at queens
\end{verbatim}

\subsection{Exercise 2.43: Louis' \texttt{queens}}
\label{sec:org3f2d925}
\subsubsection{Question}
\label{sec:org262738c}
\begin{quote}
Louis Reasoner is having a terrible time doing Exercise 2.42. His
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{queens} procedure seems to work, but it runs extremely slowly. (Louis
never does manage to wait long enough for it to solve even the \(6\times6\)
case.) When Louis asks Eva Lu Ator for help, she points out that he has
interchanged the order of the nested mappings in the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{flatmap},
writing it as
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(flatmap
 (lambda (new-row)
   (map (lambda (rest-of-queens)
          (adjoin-position new-row k rest-of-queens))
        (queen-cols (- k 1))))
 (enumerate-interval 1 board-size))
\end{minted}

\begin{quote}
Explain why this interchange makes the program run slowly. Estimate how long it
will take Louis's program to solve the eight-queens puzzle, assuming that the
program in Exercise 2.42 solves the puzzle in time \(T\).
\end{quote}

\subsubsection{Answer}
\label{sec:org103ce02}
The biggest contributor to the slowdown is likely the location of the
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{queen-cols} recursive call. This call being inside of the loop means
it is being called \(k\) more times, all returning the same answer. But my math reasoning skills limit me from going further .Let's check
with benchmarks.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<queens-txt>>
<<queens-mine>>
(load "../mattbench.scm")

(define (queens-louis board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (new-row)
            (map (lambda (rest-of-queens)
                   (adjoin-position new-row k rest-of-queens))
                 (queen-cols (- k 1))))
          (enumerate-interval 1 board-size)))))
  (queen-cols board-size))

(define (test size)
  (format #t "~&normal queens x~a: ~a" size
          (mattbench (lambda()(queens size)) 10000))
  (format #t "~&swapped queens x~a: ~a" size
          (mattbench (lambda()(queens-louis size)) 1000)))

(map (lambda(n)
       (test n))
     (enumerate-interval 5 8))
\end{minted}

\begin{verbatim}
normal queens x5: 135424.6151
swapped queens x5: 5487381.643
normal queens x6: 538798.604
swapped queens x6: 85704466.218
normal queens x7: 2210394.5659
swapped queens x7: 1255288880.717
normal queens x8: 8067290.5992
swapped queens x8: 25384464494.259
\end{verbatim}

\begin{center}
\includegraphics[width=.9\linewidth]{2/fig/2-43.png}
\end{center}

So that's 40 times worse at 5x5, 159 times worse at 6x6, 568 times worse at 7x7,
and 3146 times at 8x8.

after checking online with posts like this one \footnote{\url{https://wernerdegroot.wordpress.com/2015/08/01/sicp-exercise-2-43/}} It looks
like the big-O notation could be considered \(\Theta((N^N)*T)\) at its simplest.
I don't have a good grasp on how to reason out the time complexity of a
non-trivial algorithm. I aim to eventually do ``How to Solve It'' and ``How to
Prove It'' and possibly that will fill in the missing gaps before trying more
serious comp-sci literature.

\subsection{2.2.4: Example: A Picture Language}
\label{sec:orgf73c0f6}
Authors describe a possible implementation of a ``picture language'' that tiles,
patterns, and warps images according to a specification. This language consists
of:

\begin{itemize}
\item a \textbf{painter} which makes an image within a specified parallelogram shaped
frame. This is the most primitive element.
\item \textbf{Operations} which make new painters from other painters. For example:
\begin{itemize}
\item \emph{beside} takes two painters, producing a new painter that puts one in the
left half and one in the right half.
\item \emph{flip-horiz} takes one painter and produces another to draw its image
right-to-left reversed. These are defined as Scheme procedures and therefore
have all the properties of Scheme procedures.
\end{itemize}
\end{itemize}

I'm going to have to get a little messy in order to make the picture language a
reality. First I need a support library called \href{https://git.elephly.net/gitweb.cgi?p=software/guile-picture-language.git;a=blob;f=pict.scm;h=54f0ce09f4ac33c3ecc3340f038d4c9da5f4a443;hb=HEAD}{guile-picture-language}\footnote{\url{https://git.elephly.net/gitweb.cgi?p=software/guile-picture-language.git;a=blob;f=pict.scm;h=54f0ce09f4ac33c3ecc3340f038d4c9da5f4a443;hb=HEAD}} I
installed Guix on my system and ran \mintinline[breaklines=true,breakanywhere=true,linenos=true]{bash}{guix shell guile-picture-language guile}. Now the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{pict} module is availale to me.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-modules (pict))
(pict->file (triangle 50 70)
           "2/pict/test.svg")
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{2/pict/test.png}
\end{center}

So that works.

How about this?

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-modules (pict))
(let* ((p (pict-from-file "2/pict/Potato.png"))
       (pr (rotate p 180)))
(pict->file
 (scale (ht-append (vl-append pr p) pr p (vc-append pr p))
        0.5)
 "2/pict/Rotato.svg")) ;; must be SVG
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{2/pict/Rotato.png}
\end{center}

And I just realized there's no flip/mirror function in this library. Racket's
picture language is more complete, but it won't integrate with org-mode how I
need. Maybe I can mock up a text-based version, similar to the binary mobile,
and simultaneously check my work with Racket.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; tilting at windmills trying to make a text-only picture language
;; TODO, probably won't finish
(define pl-defaultsize 32)
(define (make-painter orientation height width)
  (cons orientation (cons a b)))
(define (p-orientation p)
  (car p))
(define (p-height p)
  (cadr p))
(define (p-width p)
  (cddr p))
(define (opposite orientation)
  (cond ((eq? orientation 'down) 'up)
        ((eq? orientation 'up ) 'down)
        ((eq? orientation 'left) 'right)
        ((eq? orientation 'right) 'left)))
(define (flip-p p)
  (make-painter (opposite (p-orientation p))))
(define (below a b)
  (make-painter 'down a b))
(define (beside a b)
  (make-painter 'right a b))
(define (flip-vert p)
  (if (pair? p)
      (make-painter ))
(define (paint pict)
  (define (rect p x y)
    (cond ((string? p)
           )))
  (rec p pl-defaultsize pl-defaultsize))
(define (beside a b)
  (hc-append a b))
(define (below a b)
  (vc-append a b))
\end{minted}


\subsection{Exercise 2.44: \texttt{up-split}}
\label{sec:orgcb65651}
\subsubsection{Text Definitions}
\label{sec:orgdc463f7}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (right-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (right-split painter 
                                  (- n 1))))
        (beside painter 
                (below smaller smaller)))))
\end{minted}

\subsubsection{Question}
\label{sec:org060f3af}
\begin{quote}
Define the procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{up-split} used by \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{corner-split}. It
is similar to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{right-split}, except that it switches the roles of
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{below} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{beside}.
\end{quote}

\subsubsection{Answer}
\label{sec:org69f5b86}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (up-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (up-split painter 
                               (- n 1))))
        (below painter 
               (beside smaller smaller)))))
\end{minted}

\subsection{Exercise 2.45: Generalized splitting}
\label{sec:orgd32ea38}
\subsubsection{Question}
\label{sec:org1984ba6}
\begin{quote}
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{right-split} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{up-split} can be expressed as instances
of a general splitting operation. Define a procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{split} with the
property that evaluating
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define right-split (split beside below))
(define up-split (split below beside))
\end{minted}

\begin{quote}
produces procedures \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{right-split} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{up-split} with the
same behaviors as the ones already defined.
\end{quote}

\subsubsection{Answer}
\label{sec:org9f99e2e}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (split f1 f2)
  (define (rec painter n)
    (if (= n 0)
        painter
        (let ((smaller (rec painter 
                            (- n 1))))
          (f1 painter 
              (f2 smaller smaller)))))
  rec)
(define right-split (split beside below))
;; This one goes down for some reason?
;(define up-split (split below beside))
(define (up-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (up-split painter 
                               (- n 1))))
        (below painter 
               (beside smaller smaller)))))
\end{minted}

\subsection{Exercise 2.46: Defining vectors}
\label{sec:orge0f7c1b}
\subsubsection{Question}
\label{sec:org7db1c7f}
\begin{quote}
A two-dimensional vector \(\hbox{\bf v}\) running from the origin to a point can
be represented as a pair consisting of an \(x\)-coordinate and a
\(y\)-coordinate. Implement a data abstraction for vectors by giving a
constructor \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{make-vect} and corresponding selectors
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{xcor-vect} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{ycor-vect}. In terms of your selectors and
constructor, implement procedures \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{add-vect}, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{sub-vect},
and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{scale-vect} that perform the operations vector addition, vector
subtraction, and multiplying a vector by a scalar:

$\backslash$[
\begin{array}{r@{{}={}}l}
	(x_1, y_1) + (x_2, y_2) 	& (x_1 + x_2, y_1 + y_2), \\
	(x_1, y_1) - (x_2, y_2) 	& (x_1 - x_2, y_1 - y_2), \\
	s \cdot (x, y) 			& (sx, sy).
\end{array}
$\backslash$]
\end{quote}

\subsubsection{Answer}
\label{sec:org9a5bfa7}
This is pretty close to the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{make-point} work done in Exercise 2.2, as well as my 2nd implementation of a rectangle in Exercise 2.3. Let's start there. Also, \emph{aren't these points and not vectors since they don't have direction??}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; Guarentee x is a float
(define (float x)
  (if (inexact? x)
      x
      (exact->inexact x)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<force-float>>
(define (make-vect x y)
  (cons (float x)
        (float y))) ;; make-point
(define (xcor-vect v)
  (car v)) ;; x-point
(define (ycor-vect v)
  (cdr v)) ;; y-point
(define (add-vect v w)
  (make-vect (+ (xcor-vect v)
                (xcor-vect w))
             (+ (ycor-vect v)
                (ycor-vect w))))
(define (sub-vect v w)
  (make-vect (- (xcor-vect v)
                (xcor-vect w))
             (- (ycor-vect v)
                (ycor-vect w))))
(define (scale-vect s v)
  (make-vect (* s (xcor-vect v))
             (* s (ycor-vect v))))
\end{minted}

I originally got the definition for \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{scale-vect} wrong by making it
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(scale v s)}, then modified \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{frame-coord-map} when that
broke. I realized my mistake once I went to write \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{beside}.

\subsection{Exercise 2.47: Defining frames}
\label{sec:orga001085}
\subsubsection{Question}
\label{sec:org58b136f}
\begin{quote}
Here are two possible
constructors for frames:
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))
(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
\end{minted}

\begin{quote}
For each constructor supply the appropriate selectors to produce an
implementation for frames.
\end{quote}

\subsubsection{Answer}
\label{sec:org801ebde}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))
(define (origin-frame F)
  (car F))
(define (edge1-frame F)
  (cadr F))
(define (edge2-frame F)
  (caddr F))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
(define (origin-frame F)
  (car F))
(define (edge1-frame F)
  (cadr F))
(define (edge2-frame F)
  (cddr F))
\end{minted}

\subsection{Exercise 2.48: Line segments}
\label{sec:org9765d28}
\subsubsection{Question}
\label{sec:orge443a4b}
\begin{quote}
A directed line segment in the plane can be represented as a pair of
vectors---the vector running from the origin to the start-point of the segment,
and the vector running from the origin to the end-point of the segment. Use your
vector representation from Exercise 2.46 to define a
representation for segments with a constructor \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{make-segment} and
selectors \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{start-segment} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{end-segment}.
\end{quote}

\subsubsection{Answer}
\label{sec:org0b9ef1f}
Again reminding me of Exercise 2.2.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (make-segment start end)
  (cons start end))
(define (start-segment seg)
  (car seg))
(define (end-segment seg)
  (cdr seg))
\end{minted}

\subsection{Exercise 2.49: Primitive painters}
\label{sec:org453431f}
\subsubsection{Text Definitions}
\label{sec:org992b9a1}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (frame-coord-map frame)
  (lambda (v)
    (add-vect
     (origin-frame frame)
     (add-vect 
      (scale-vect (xcor-vect v)
                  (edge1-frame frame))
      (scale-vect (ycor-vect v)
                  (edge2-frame frame))))))
(define (segments->painter segment-list)
  (lambda (frame)
    (for-each
     (lambda (segment)
       (draw-line
        ((frame-coord-map frame)
         (start-segment segment))
        ((frame-coord-map frame)
         (end-segment segment))))
     segment-list)))
\end{minted}

\subsubsection{Question}
\label{sec:org50b1946}
\begin{quote}
Use \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{segments->painter}
to define the following primitive painters:

\begin{enumerate}
\item The painter that draws the outline of the designated frame.
\item The painter that draws an \texttt{X} by connecting opposite corners of the frame.
\item The painter that draws a diamond shape by connecting the midpoints of the
sides of the frame.
\item The \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{wave} painter.
\end{enumerate}
\end{quote}

\subsubsection{Answer}
\label{sec:org31df6d9}
In the past I would need to constantly execute my code to ``see'' what I'm doing.
But I'm starting to think in larger chunks and need the feedback less.


\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<continuous-lines>>
(define outline
  (segments->painter (list
   (make-segment (make-vect 0 0)
                 (make-vect 0 1))
   (make-segment (make-vect 0 1)
                 (make-vect 1 1))
   (make-segment (make-vect 1 1)
                 (make-vect 1 0))
   (make-segment (make-vect 1 0)
                 (make-vect 0 0)))))
(define frame-X
  (segments->painter (list
   (make-segment (make-vect 0 0)
                 (make-vect 1 1))
   (make-segment (make-vect 0 1)
                 (make-vect 1 0)))))
(define diamond
  (segments->painter (list
   (make-segment (make-vect 0.5 0)
                 (make-vect 1 0.5))
   (make-segment (make-vect 1 0.5)
                 (make-vect 0.5 1))
   (make-segment (make-vect 0.5 1)
                 (make-vect 0 0.5))
   (make-segment (make-vect 0 0.5)
                 (make-vect 0.5 0)))))
\end{minted}

I'll make the wave painter once I have some graph paper in front of me.

Ok, how can I verify this? I guess I could rewrite \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{segments->painter}
for \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{pict}. Since this isn't a drawing system with imperative
procedures, I should make it return a list of lines to be superimposed.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-modules (pict))
<<make-frame>>
<<make-vect>>
<<make-segment>>
(define (frame-coord-map frame)
  ;; Returns a function for adjusting a frame by a vector
  (lambda (v)
    (add-vect
     (origin-frame frame)
     (add-vect 
      (scale-vect (xcor-vect v)
                  (edge1-frame frame))
      (scale-vect (ycor-vect v)
                  (edge2-frame frame))))))
(define (draw-line start end)
  ;; take two vectors, returns a line SVG object for pict
  (line (xcor-vect start)
        (ycor-vect start)
        (xcor-vect end)
        (ycor-vect end)))
(define (segments->painter segment-list)
  ;; takes a list of segments, returns a "painter" lambda, which applies a frame
  ;; to those segments and then maps over the result with draw-line to make a
  ;; list of SVG line objects which pict can combine.
  (lambda (frame)
    (map
     (lambda (segment)
       (draw-line
        ((frame-coord-map frame)
         (start-segment segment))
        ((frame-coord-map frame)
         (end-segment segment))))
     segment-list)))
;; NOTE: in the text, draw-line is a function which triggers an action in
;; some graphics driver, and returns nothing. Because of this, (map) was
;; originally (for-each). Thus the final result would have been thrown away.

<<painters>>

(define (paint-lines painter)
  ;; use pict to compile an SVG with the elements described by painter
  (let ((Frame (make-frame (make-vect 0 0)
                           (make-vect 500 0)
                           (make-vect 0 500))))
    (apply lt-superimpose
           (painter Frame))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<linepainter-pict>>
(pict->file (paint-lines diamond)
            "2/pict/testline.svg")
; #:maxw 100 #:maxh 100) <- FIXME: This procedure should take these arguments
; but I can't get it to work.
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{2/pict/testline.png}
\end{center}

Holy moly it actually works.

\subsection{Exercise 2.50: Transforming painters}
\label{sec:orgceb6fd8}
\subsubsection{Text Definitions}
\label{sec:org0001320}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (transform-painter 
         painter origin corner1 corner2)
  (lambda (frame)
    (let ((m (frame-coord-map frame)))
      (let ((new-origin (m origin)))
        (painter (make-frame new-origin
                             (sub-vect (m corner1) 
                                       new-origin)
                             (sub-vect (m corner2)
                                       new-origin)))))))

(define (flip-vert painter)
  (transform-painter 
   painter
   (make-vect 0.0 1.0)   ; new origin
   (make-vect 1.0 1.0)   ; new end of edge1
   (make-vect 0.0 0.0))) ; new end of edge2

(define (rotate90 painter)
  (transform-painter painter
                     (make-vect 1.0 0.0)
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 0.0)))

(define (squash-inwards painter)
  (transform-painter painter
                     (make-vect 0.0 0.0)
                     (make-vect 0.65 0.35)
                     (make-vect 0.35 0.65)))
(define (beside painter1 painter2)
  (let ((split-point (make-vect 0.5 0.0)))
    (let ((paint-left  (transform-painter 
                        painter1
                        (make-vect 0.0 0.0)
                        split-point
                        (make-vect 0.0 1.0)))
          (paint-right (transform-painter
                        painter2
                        split-point
                        (make-vect 1.0 0.0)
                        (make-vect 0.5 1.0))))
      (lambda (frame)
        (append
         (paint-left frame)
         (paint-right frame))))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<linepainter-pict>>
<<frame-transforms-txt>>
(define topleft-tri
  (segments->painter (list
                      (make-segment (make-vect 0 0)
                                    (make-vect 0 0.4))
                      (make-segment (make-vect 0 0.4)
                                    (make-vect 0.4 0))
                      (make-segment (make-vect 0.4 0)
                                    (make-vect 0 0)))))
(let ((picture (beside (beside topleft-tri
                               topleft-tri)
                       (rotate90 topleft-tri))))
(pict->file (paint-lines picture)
            "2/pict/rotatetest.svg"))
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{2/pict/rotatetest.png}
\end{center}

\subsubsection{Question}
\label{sec:orgaf6d31b}
\begin{quote}
Define the transformation \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{flip-horiz}, which flips painters
horizontally, and transformations that rotate painters counterclockwise by 180
degrees and 270 degrees.
\end{quote}

\subsubsection{Answer}
\label{sec:orgda44021}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (flip-horiz painter)
  (transform-painter 
   painter
   (make-vect 1.0 0.0)   ; new origin
   (make-vect 0.0 0.0)   ; new end of edge1
   (make-vect 1.0 1.0))) ; new end of edge2

(define (rotate180 painter)
  (transform-painter painter
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 1.0)
                     (make-vect 1.0 0.0)))
(define (rotate270 painter)
  (transform-painter painter
                     (make-vect 0.0 1.0)
                     (make-vect 0.0 0.0)
                     (make-vect 1.0 1.0)))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<linepainter-pict>>
<<frame-transforms-txt>>
<<flip-rotate2>>
(define topleft-tri
  (segments->painter (list
                      (make-segment (make-vect 0 0)
                                    (make-vect 0 0.4))
                      (make-segment (make-vect 0 0.4)
                                    (make-vect 0.8 0))
                      (make-segment (make-vect 0.8 0)
                                    (make-vect 0 0)))))
(let ((picture (beside (beside
                        (flip-vert topleft-tri)
                        (rotate90 topleft-tri))
                       (beside
                        (rotate180 topleft-tri)
                        (rotate270 topleft-tri)))))
  (pict->file (paint-lines picture)
              "2/pict/rotate2.svg"))
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{2/pict/rotate2.png}
\end{center}

\subsection{Exercise 2.51}
\label{sec:org105b3b4}
\subsubsection{Question}
\label{sec:org8b1990f}
\begin{quote}
Define the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{below} operation
for painters.  \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{below} takes two painters as arguments.  The resulting
painter, given a frame, draws with the first painter in the bottom of the frame
and with the second painter in the top.  Define \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{below} in two different
ways---first by writing a procedure that is analogous to the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{beside}
procedure given above, and again in terms of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{beside} and suitable
rotation operations (from @ref\{Exercise 2.50\}).
\end{quote}

\subsubsection{Answer}
\label{sec:orgb02e269}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (below painter1 painter2)
  (let ((split-point (make-vect 0.0 0.5)))
    (let ((paint-left  (transform-painter 
                        painter1
                        (make-vect 0.0 0.0)
                        (make-vect 1.0 0.0)
                        split-point))
          (paint-right (transform-painter
                        painter2
                        split-point
                        (make-vect 1.0 0.5)
                        (make-vect 0.0 1.0))))
      (lambda (frame)
        (append
         (paint-left frame)
         (paint-right frame))))))
(define (below-rotate painter1 painter2)
  (rotate270 (beside
              (rotate90 painter2)
              (rotate90 painter1))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<linepainter-pict>>
<<frame-transforms-txt>>
<<flip-rotate2>>
<<below>>
(define topleft-tri
  (segments->painter (list
                      (make-segment (make-vect 0 0)
                                    (make-vect 0 0.4))
                      (make-segment (make-vect 0 0.4)
                                    (make-vect 0.8 0))
                      (make-segment (make-vect 0.8 0)
                                    (make-vect 0 0)))))
(let ((p1 (below (beside
                        topleft-tri
                        (rotate90 topleft-tri))
                       (beside
                        (rotate180 topleft-tri)
                        (rotate270 topleft-tri))))
      (p2 (below-rotate (beside
                        topleft-tri
                        (rotate90 topleft-tri))
                       (beside
                        (rotate180 topleft-tri)
                        (rotate270 topleft-tri)))))
  (pict->file (paint-lines (beside p1 p2))
              "2/pict/rotate3.svg"))
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{2/pict/rotate3.png}
\end{center}

An aside: I'm beginning to see what makes Lisp-style programming different from
C style. In C, the pictures would be described with separate data structures
specified up front, but in Lisp you can use the code to create the data
structure. Off the top of my head, the biggest players here would be first-level
functions, and how statements evaluate to specific values rather than being
imperative commands that cause something to happen elsewhere.

\subsection{2.2.4 continued}
\label{sec:org70a2605}
\begin{description}
\item[{stratified design}] is the notion that complex systems should be structured
as a sequence of levels with a sequence of languages. See how electronic
components are described in EE terms, the binary gates they form are described
in digital logic terms, the programs they run described in programming
language terms, the networks of programs described in network architecture
terms, etc.
\end{description}

This stratified design can be seen in our picture language. We use lines and
points to specify painters, use painters to make arrangements with beside/below,
arrange these arrangements into higher-level arrangements like
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{up-split}.

\subsection{Exercise 2.52}
\label{sec:org72bb53b}
\subsubsection{Question A}
\label{sec:org143bc16}
Make changes to the square limit of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{wave} shown in Figure 2.9 by
working at each of the levels described above. In particular:

\begin{itemize}
\item Add some segments to the primitive \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{wave} painter of Exercise 2.49 (to add a smile, for example).
\end{itemize}

\subsubsection{Answer A}
\label{sec:org04ec683}
I need to do what I've been slacking off on: actually making the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{wave} painter.
First, I want a helper function to make inputting shapes easier.


\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (unwrap-if-needed args)
  ;; commonly needed in vararg functions
  (if (and (= 1 (length args))
           (list? (car args)))
      (car args) ; assume we were passed a list, unwrap it
      args))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<unwrap-if-needed>>
(define (continuous-lines . vectors)
  ;; Given a list of vectors, return a series of line segments
  ;; that continuously follow the vectors until there are no more,
  ;; at which point connect the last vector to the first.
  (define (iter vecs lines)
    (if (> 2 (length vecs))
        lines
        (let* ((first (car vecs))
               (rest (cdr vecs))
               (second (car rest))
               (new-line (make-segment first second)))
          (iter rest (cons new-line lines)))))
  (let ((input (unwrap-if-needed vectors)))
    (iter (append input (list (car input))) ;; Connect to start
          '())))
(define (numbers-to-vectors . numbers)
  (define (iter input output)
    (if (> 2 (length input))
        output
        (let* ((first (car input))
              (d (cdr input))
              (second (car d))
              (dd (cdr d)))
          (iter dd
                (cons (make-vect first second)
                      output)))))
  (reverse (iter numbers '())))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<linepainter-pict>>
<<frame-transforms-txt>>
<<flip-rotate2>>
<<below>>
<<continuous-lines>>
(define topleft-tri
  (segments->painter (list
                      (make-segment (make-vect 0 0)
                                    (make-vect 0 0.4))
                      (make-segment (make-vect 0 0.4)
                                    (make-vect 0.8 0))
                      (make-segment (make-vect 0.8 0)
                                    (make-vect 0 0)))))
(define topleft-tri2
  (segments->painter (continuous-lines
                      (make-vect 0 0)
                      (make-vect 0 0.4)
                      (make-vect 0.8 0))))
(define topleft-tri3
  (segments->painter (continuous-lines
                      (numbers-to-vectors
                       0 0
                       0 0.4
                       0.8 0))))
(let ((p1 (below (beside topleft-tri topleft-tri2)
                 (beside topleft-tri topleft-tri3))))
  (pict->file (paint-lines p1)
              "2/pict/cl-test.svg"))
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{2/pict/cl-test.png}
\end{center}

Now, let's write the wave painter.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<continuous-lines>>
;; Should be raising their left hand and
;; lowering their right. (I screwed up the axes)
(define wave
  (segments->painter
   (continuous-lines
    (numbers-to-vectors
    0.55 0
    0.5 0.15 ;; center-left side of head
    0.55 0.3
    0.45 0.275
    0.25 0.35
    0 0.25
    0 0.3
    0.25 0.45
    0.45 0.35
    0.5 0.65
    0.4 1
    0.45 1
    0.6 0.7
    0.75 1
    0.8 1
    0.7 0.65
    0.75 0.35
    1 0.675
    1 0.6
    0.75 0.275
    0.65 0.3
    0.7 0.15 ;; center-right side of head
    0.65 0))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<linepainter-pict>>
<<frame-transforms-txt>>
<<flip-rotate2>>
<<below>>
<<continuous-lines>>
<<wave-painter>>
(let ((p1 (beside wave (flip-vert wave))))
  (pict->file (paint-lines p1)
              "2/pict/wave-test.svg"))
\end{minted}

The question needs me to overlay something new. So I need some way to add more
segments to a painter after it's already been written.

\begin{center}
\includegraphics[width=.9\linewidth]{2/pict/wave-test.png}
\end{center}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<unwrap-if-needed>>
(define (append-painters-rec . args)
  (lambda (frame)
    (define (rec painters)
      (if (null? painters)
          '()
          (append ((car painters) frame)
                  (rec (cdr painters)))))
    (rec (unwrap-if-needed args))))
(define (append-painters . args)
  (lambda (frame)
    (define (iter segments to-paint)
      (if (null? to-paint)
          segments
          (iter (append ((car to-paint) frame)
                      segments)
                      (cdr to-paint))))
    (iter '()
          (unwrap-if-needed args))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<linepainter-pict>>
<<frame-transforms-txt>>
<<flip-rotate2>>
<<below>>
<<continuous-lines>>
<<painters>>
<<wave-painter>>
<<append-painters>>
(let ((p1 (append-painters
           (beside wave (flip-vert wave))
           frame-X
           outline)))
  (pict->file (paint-lines p1)
              "2/pict/append-test.svg"))
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{2/pict/append-test.png}
\end{center}

Now let's (try to) add a smile.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<wave-painter>>
<<append-painters>>
(define wave-smile
  (append-painters
   wave
   (segments->painter
    (continuous-lines
     (numbers-to-vectors
      0.55 0.2
      0.6 0.225
      0.65 0.2)))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<linepainter-pict>>
<<frame-transforms-txt>>
<<flip-rotate2>>
<<below>>
<<continuous-lines>>
<<wave-smile>>
(pict->file (paint-lines wave-smile)
            "2/pict/wave-smile-test.svg")
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{2/pict/wave-smile-test.png}
\end{center}

\subsubsection{Question B}
\label{sec:org1f1b851}
Change the pattern constructed by \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{corner-split} (for example, by
using only one copy of the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{up-split} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{right-split}
images instead of two).

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter 
                                (- n 1))))
        (let ((top-left (beside up up))
              (bottom-right (below right 
                                   right))
              (corner (corner-split painter 
                                    (- n 1))))
          (beside (below painter top-left)
                  (below bottom-right 
                         corner))))))

(define (corner-split-mine painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter 
                                (- n 1))))
        (let ((top-left up)
              (bottom-right right)
              (corner (corner-split-mine painter 
                                    (- n 1))))
          (beside (below painter top-left)
                  (below bottom-right 
                         corner))))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<linepainter-pict>>
<<frame-transforms-txt>>
<<flip-rotate2>>
<<below>>
<<continuous-lines>>
<<painters>>
<<wave-smile>>
<<append-painters>>
<<splits-generalized>>
<<corner-split>>
(let ((p1 (beside (flip-horiz (corner-split wave-smile 5))
                  (corner-split-mine wave-smile 5))))
;(let ((p1 (up-split frame-X 5)))
  (pict->file (paint-lines p1)
              "2/pict/corner-splits.svg"))
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{2/pict/corner-splits.png}
\end{center}

So my modified version doesn't split at the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{corner-split} level, as
predicted. However \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{up-split} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{right-split} do, so the
effect is only delayed by one level. But more importantly:

\emph{Why does it go down instead of up? I don't get it.}

\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{corner-split} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{up-split} are even the same code as
every answer online. Could my \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{paint-lines} procedure be what's
causing issues?

\subsubsection{Question C}
\label{sec:org35a5164}
\begin{quote}
Modify the version of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{square-limit} that uses \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{square-of-four} so as
to assemble the corners in a different pattern.  (For example, you might make
the big Mr. Rogers look outward from each corner of the square.)
\end{quote}

\subsubsection{Textbook Definitions}
\label{sec:org5b7f757}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (square-of-four tl tr bl br)
  (lambda (painter)
    (let ((top (beside (tl painter) 
                       (tr painter)))
          (bottom (beside (bl painter) 
                          (br painter))))
      (below bottom top))))
(define (square-limit painter n)
  (let ((combine4 
         (square-of-four flip-horiz 
                         identity
                         rotate180 
                         flip-vert)))
    (combine4 (corner-split painter n))))
\end{minted}

\subsubsection{Answer C}
\label{sec:org3eef080}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (square-limit-mine painter n)
  (let ((combine4 
         (square-of-four identity
                         flip-horiz
                         flip-vert 
                         rotate180)))
    (combine4 (corner-split painter n))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<linepainter-pict>>
<<frame-transforms-txt>>
<<flip-rotate2>>
<<below>>
<<continuous-lines>>
<<wave-smile>>
<<splits-generalized>>
<<corner-split>>
<<square-of-four-txt>>
<<square-limit-mine>>
(pict->file (paint-lines (beside (square-limit wave-smile 5)
                                 (square-limit-mine wave-smile 5)))
            "2/pict/square-limits.svg")
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{2/pict/square-limits.png}
\end{center}

Ok, I'm confused. Shouldn't the shape of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{square-limit} be the same
regardless of the operators passed to it? It looks like the operators effect
each chunk separately.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<linepainter-pict>>
<<frame-transforms-txt>>
<<flip-rotate2>>
<<below>>
<<continuous-lines>>
<<wave-smile>>
<<splits-generalized>>
<<corner-split>>
<<square-of-four-txt>>
(define (square-limit-mine painter n)
  (let ((combine4 
         (square-of-four identity
                         identity
                         identity
                         identity)))
    (combine4 (corner-split painter n))))
(pict->file (paint-lines (square-limit-mine wave-smile 5))
            "2/pict/square-limit-identity.svg")
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{2/pict/square-limit-identity.png}
\end{center}

I expected the operators would change the \emph{image orientation}, not the
\emph{structure}. Maybe this is because my \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{draw-lines} makes recursively
nested stacks of painter objects, rather than imperative calls to drawing
procedures? Looking on the internet I see \href{http://pipecode.blogspot.com/2013/04/sicp-exercise-252.html}{someone else having the same
results.}\footnote{\url{http://pipecode.blogspot.com/2013/04/sicp-exercise-252.html}}

\subsection{2.3.1: Quotation}
\label{sec:org83bb707}
Syntactic vs semantic use in Lisp:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define dog 123)
(+ dog dog) ;; semantic usage
(quote dog) ;; syntactic usage
\end{minted}

This was introduced by famous LISP scientists, Abbott and Costello.

\subsection{Exercise 2.53}
\label{sec:orgf728fd5}
\subsubsection{Question}
\label{sec:org05645d3}
\begin{quote}
What would the interpreter print
in response to evaluating each of the following expressions?
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(list 'a 'b 'c)
(list (list 'george))
(cdr '((x1 x2) (y1 y2)))
(cadr '((x1 x2) (y1 y2)))
(pair? (car '(a short list)))
(memq 'red '((red shoes) (blue socks)))
(memq 'red '(red shoes blue socks))
\end{minted}

\subsubsection{Answer}
\label{sec:orgc2e97ad}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(list 'a 'b 'c) ;; (a b c)
(list (list 'george)) ;; ((george))
(cdr '((x1 x2) (y1 y2))) ;; ((y1 y2))
(cadr '((x1 x2) (y1 y2))) ;; (y1 y2)
(pair? (car '(a short list))) ;; false
(memq 'red '((red shoes) (blue socks))) ;; false
(memq 'red '(red shoes blue socks)) ;; (red shoes blue socks)
\end{minted}

\subsection{Exercise 2.54}
\label{sec:orgc4afccb}
\begin{quote}
Two lists are said to be \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{equal?} if they contain equal elements
arranged in the same order. For example,
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(equal? '(this is a list) '(this is a list))
\end{minted}

\begin{quote}
is true, but
\end{quote}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(equal? '(this is a list) '(this (is a) list))
\end{minted}

\begin{quote}
is false. To be more precise, we can define \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{equal?} recursively in
terms of the basic \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{eq?} equality of symbols by saying that
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{a} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{b} are \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{equal?} if they are both symbols
and the symbols are \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{eq?}, or if they are both lists such that
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(car a)} is \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{equal?} to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(car b)} and
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(cdr a)} is \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{equal?} to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(cdr b)}. Using this
idea, implement \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{equal?} as a procedure.
\end{quote}

\subsubsection{Answer}
\label{sec:org87af4d7}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (equal? a b)
  (cond ((and (symbol? a)
              (symbol? b))
         (eq? a b))
        ((and (list? a)
              (list? b))
         (and (equal? (car a) (car b))
              (equal? (cdr a) (cdr b))))
        (else #f)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
(let ((a '(this is a list))
      (aa '(this is a list))
      (b '(this (quote is a) list)))
  (mattcheck "equal? true"
             (equal? a a))
  (mattcheck "equal? trick question"
             (equal? a a))
  (mattcheck "equal? false"
             (equal? a b)
             #f))
\end{minted}

\begin{verbatim}
SUCCEED at equal? true
SUCCEED at equal? trick question
SUCCEED at equal? false
\end{verbatim}

\subsection{Exercise 2.55}
\label{sec:orgf953830}
\subsubsection{Question}
\label{sec:org995a8ad}
Eva Lu Ator types to the interpreter the expression

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(car ''abracadabra)
\end{minted}

To her surprise, the interpreter prints back \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{quote}. Explain.

\subsubsection{Answer}
\label{sec:org41a1fb8}
You're quoting quote, silly! Who's on first?

\subsection{2.3.2: Example: Symbolic differentiator}
\label{sec:orgd597c64}
I needed to get some help, but I think I have some understanding now.

The \textbf{derivative} of an expression \(E\), relative to the variable \(x\),
describes the rate of change (or \(\delta\) \textbf{delta}) of that expression with
relation to \(x\). Mathematicians symbolize it like this:

\[\frac{dE}{dx}\]

Two stumbling blocks about this notation:
\begin{enumerate}
\item This is not division. I understand why this notation would make sense to an
experienced mathematician, since you factor out things by dividing an
expression. For example:
\[\frac{3x}{x} = 3\]
\[\frac{3x}{3} = x\]
But it's still confusing.
\item \(dx\) is not some variable \(d\) times some variable \(x\).
\(\frac{d(x+3)}{dx}\) means ``the derivative of \(x+3\) with respect to
\(x\).''
\end{enumerate}

The process of finding the derivative is called \textbf{differentiation}.

The rules the book puts forward, rephrased in plain English, are these:

\begin{itemize}
\item If the expression is a constant, the derivative must be 0.
\item If the expression is \(x\), the derivative must be 1.
\item If the expression is \(u + v\), the derivative is the sum of two
derivatives:
\begin{enumerate}
\item The derivative of \(u\) with respect to \(x\).
\item The derivative of \(v\) with respect to \(x\).
\end{enumerate}
\item If the expression is \(u \times v\), the derivative is the sum of:
\begin{enumerate}
\item \(u\) times the derivative of \(v\) with respect to \(x\)
\item \(v\) times the derivative of \(u\) with respect to \(x\)
\end{enumerate}
\end{itemize}

Later:
\begin{itemize}
\item If the expression is \(u^0\), the result is 1, which is a constant, so the
rate of change is 0.
\item If the expression is \(u^1\), the result is u, so the rate of change is 1.
\item Else, if the expression is \(u^n\), the derivative is the product of these:
\begin{enumerate}
\item \(n\)
\item \(u\) to the power of \(n-1\)
\item The derivative of \(u\) with respect to \(x\).
\end{enumerate}
\end{itemize}

\subsection{Exercise 2.56: Differentiating exponentiation}
\label{sec:org30ff1f7}
\subsubsection{Text definitions}
\label{sec:org628e007}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (sum? x) (and (pair? x) (eq? (car x) '+)))
(define (addend s) (cadr s))
(define (augend s) (caddr s))
(define (product? x) (and (pair? x) (eq? (car x) '*)))
(define (multiplier p) (cadr p))
(define (multiplicand p) (caddr p))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2))
         (+ a1 a2))
        (else (list '+ a1 a2))))
(define (=number? exp num)
  (and (number? exp) (= exp num)))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp) (make-sum (deriv (addend exp) var)
                              (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        (else
         (error "unknown expression type: DERIV" exp))))
\end{minted}

\subsubsection{Question}
\label{sec:org7169c4b}
\begin{quote}
Show how to extend the basic differentiator to handle more kinds of expressions.
For instance, implement the differentiation rule

\[ \frac{\it d\,(u^n\,)}{\it dx} = nu^{n-1} \frac{\it du}{\it dx} \]

by adding a new clause to the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{deriv} program and defining appropriate
procedures \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{exponentiation?}, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{base}, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{exponent},
and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{make-exponentiation}. (You may use the symbol \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{**} to
denote exponentiation.) Build in the rules that anything raised to the power 0
is 1 and anything raised to the power 1 is the thing itself.
\end{quote}

\subsubsection{Answer}
\label{sec:orgac51c59}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (exponentiation? x) (and (pair? x) (eq? (car x) '**)))
(define (base e) (cadr e))
(define (exponent e) (caddr e))
(define (make-exponentiation b e)
  (cond ((=number? b 1) 1)
        ((=number? e 0) 1)
        ((=number? e 1) b)
        ((and (number? b) (number? e)) (expt b e))
        (else (list '** b e))))
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp) (make-sum (deriv (addend exp) var)
                              (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        ((exponentiation? exp)
         (make-product  
          (make-product  
           (exponent exp) 
           (make-exponentiation (base exp) 
                                (make-sum (exponent exp) -1)))                                                                                               
          (deriv (base exp) var)))
        (else
         (error "unknown expression type: DERIV" exp))))
\end{minted}

First I'll make sure the textbook examples work as expected.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<deriv-basic-txt>>
<<deriv-exp>>
(load "mattcheck2.scm")
(mattcheck "deriv: basic addition"
           (deriv '(+ x 3) 'x)
           1)
(mattcheck "deriv: basic multiplication"
           (deriv '(* x y) 'x)
           'y)
(mattcheck "deriv: bad simplification"
           (deriv '(* (* x y) (+ x 3)) 'x)
           '(+ (* x y) (* y (+ x 3))))
;; Now, did I do my job right?
;; Checking against this guy's results:
;;   http://jots-jottings.blogspot.com/2011/11/sicp-exercise-256-differentiating.html
(mattcheck "make-exponentiation 1"
           (make-exponentiation 1 12)
           1)
(mattcheck "make-exponentiation 2"
           (make-exponentiation 2 12)
           4096)
(mattcheck "make-exponentiation 3"
           (make-exponentiation 'x 12)
           '(** x 12))
(mattcheck "deriv: exponentiation 1"
           (deriv (make-exponentiation 'a 5) 'a)
           '(* 5 (** a 4)))
(mattcheck "deriv: exponentiation 2"
           (deriv (make-exponentiation 'a 'b) 'a)
           '(* b (** a (+ b -1))))
\end{minted}

\begin{verbatim}
SUCCEED at deriv: basic addition
SUCCEED at deriv: basic multiplication
SUCCEED at deriv: bad simplification
SUCCEED at make-exponentiation 1
SUCCEED at make-exponentiation 2
SUCCEED at make-exponentiation 3
SUCCEED at deriv: exponentiation 1
SUCCEED at deriv: exponentiation 2
\end{verbatim}

\subsection{Exercise 2.57: Differentiating arbitrary-length expressions}
\label{sec:org1bcf129}
\subsubsection{Question}
\label{sec:org807dc0e}
Extend the differentiation program to handle sums and products of arbitrary
numbers of (two or more) terms. Then the last example above could be expressed
as

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(deriv '(* x y (+ x 3)) 'x)
\end{minted}

Try to do this by changing only the representation for sums and products,
without changing the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{deriv} procedure at all. For example, the
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{addend} of a sum would be the first term, and the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{augend}
would be the sum of the rest of the terms.

\subsubsection{Answer}
\label{sec:org7a1f890}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (sum? x) (and (pair? x) (eq? (car x) '+)))
(define (addend s) (cadr s))
(define (augend s)
  (let ((rest (cddr s)))
    (if (null? (cdr rest))
        (car rest)
;        (make-sum (addend rest)
;                  (augend (cons '+ rest))))))
        (cons '+ rest))))
(define (product? x) (and (pair? x) (eq? (car x) '*)))
(define (multiplier p) (cadr p))
(define (multiplicand p)
  (let ((rest (cddr p)))
    (if (null? (cdr rest))
        (car rest)
;        (make-product (multiplier rest)
;                      (multiplicand (cons '* rest))))))
        (cons '* rest))))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2))
         (+ a1 a2))
        (else (list '+ a1 a2))))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2))
         (* m1 m2))
        (else (list '* m1 m2))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<deriv-basic-txt>>
<<deriv-exp>>
<<deriv-longer>>
(load "mattcheck2.scm")
(mattcheck "deriv: longer addition"
           (deriv '(+ x 3 6 z) 'x)
           1)
(mattcheck "deriv: longer multiplication"
           (deriv '(* x y (+ x 3)) 'x)
           '(+ (* x y) (* y (+ x 3))))
\end{minted}

\begin{verbatim}
SUCCEED at deriv: longer addition
SUCCEED at deriv: longer multiplication
\end{verbatim}

I had to look up the solution for this one. The commented sections in
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{augend} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{multiplicand} were the answers I was trying to
make work:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (augend s)
  (let ((rest (cddr s)))
    (if (null? (cdr rest))
        (car rest)
;        (make-sum (addend rest)
;                  (augend (cons '+ rest))))))
        (cons '+ rest))))
\end{minted}

It's taking a bunch of steps that weren't ultimately helping, but it didn't
occur to me that the solution was to go simpler rather than more complicated.
I'll have to keep watch for problem-solving dead-ends like this.

\subsection{Exercise 2.58: Processing expressions with infix notation}
\label{sec:org3821004}
\subsubsection{Question}
\label{sec:org40a215f}
Suppose we want to modify the differentiation program so that it works with
ordinary mathematical notation, in which \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{+} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{*} are
infix rather than prefix operators. Since the differentiation program is defined
in terms of abstract data, we can modify it to work with different
representations of expressions solely by changing the predicates, selectors, and
constructors that define the representation of the algebraic expressions on
which the differentiator is to operate.

\subsubsection{Part 1}
\label{sec:orgb73ad4c}
Show how to do this in order to differentiate algebraic expressions presented
in infix form, such as \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(x + (3 * (x + (y + 2))))}.  To simplify the task,
assume that \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{+} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{*} always take two arguments and that
expressions are fully parenthesized.

\subsubsection{Answer 1}
\label{sec:org02eac60}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (sum? x) (and (pair? x) (eq? (cadr x) '+)))
(define (addend s) (car s))
(define (augend s) (caddr s))
(define (product? x) (and (pair? x) (eq? (cadr x) '*)))
(define (multiplier p) (car p))
(define (multiplicand p) (caddr p))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2))
         (+ a1 a2))
        (else (list a1 '+ a2))))
(define (=number? exp num)
  (and (number? exp) (= exp num)))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list m1 '* m2))))
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp) (make-sum (deriv (addend exp) var)
                              (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        (else
         (error "unknown expression type: DERIV" exp))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<deriv-infix>>
(load "mattcheck2.scm")
(mattcheck "deriv: basic addition"
           (deriv '(x + 3) 'x)
           1)
(mattcheck "deriv: basic multiplication"
           (deriv '(x * y) 'x)
           'y)
(mattcheck "deriv: bad simplification"
           (deriv '((x * y) * (x + 3)) 'x)
           '((x * y) + (y * (x + 3))))
\end{minted}

\begin{verbatim}
SUCCEED at deriv: basic addition
SUCCEED at deriv: basic multiplication
SUCCEED at deriv: bad simplification
\end{verbatim}

\subsubsection{Part 2}
\label{sec:orgaae3ac5}
The problem becomes substantially harder if we allow standard algebraic
notation, such as \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(x + 3 * (x + y + 2))}, which drops unnecessary
parentheses and assumes that multiplication is done before addition. Can you
design appropriate predicates, selectors, and constructors for this notation
such that our derivative program still works?

\subsubsection{Answer 2}
\label{sec:org24b9b31}
Ok, I think I can do the long-form list objective, since that would be a
combination of two earlier exercises. But as I write I feel clueless how to
make multiplication happen before addition -- my first impulse is that this
would mean I would need to either:
\begin{enumerate}
\item Change how Lisp's evaluation works (obviously overkill)
\item Make statements be evaluated twice, once for multiplication and then once for
addition. And I think that would require modifications to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{deriv}.
\end{enumerate}

I'll just start working on the long-form feature and see if I can think of
anything.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (sum? x) (and (pair? x) (eq? (cadr x) '+)))
(define (addend s) (car s))
(define (augend s)
  (let ((rest (cddr s)))
    (if (null? (cdr rest))
        (car rest)
        rest)))
(define (product? x) (and (pair? x) (eq? (cadr x) '*)))
(define (multiplier p) (car p))
(define (multiplicand p)
  (let ((rest (cddr p)))
    (if (null? (cdr rest))
        (car rest)
        rest)))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2))
         (+ a1 a2))
        ((product? a2)
         (list a1 '+ ;; cross your fingers!
               (make-product (multiplier a2)
                             (multiplicand a2))))
        (else (list a1 '+ a2))))
(define (=number? exp num)
  (and (number? exp) (= exp num)))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list m1 '* m2))))
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp) (make-sum (deriv (addend exp) var)
                              (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        (else
         (error "unknown expression type: DERIV" exp))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<deriv-algebraic>>
(load "mattcheck2.scm")
(mattcheck "deriv: basic addition"
           (deriv '(x + 3) 'x)
           1)
(mattcheck "deriv: basic multiplication"
           (deriv '(x * y) 'x)
           'y)
(mattcheck "deriv: bad simplification"
           (deriv '((x * y) * (x + 3)) 'x)
           '((x * y) + (y * (x + 3))))
(mattcheck "deriv: longer addition"
           (deriv '(x + 3 + 6 + z) 'x)
           1)
(mattcheck "deriv: longer multiplication"
           (deriv '(x * y * (x + 3)) 'x)
           '((x * y) + (y * (x + 3))))

;; Test cases from:
;; http://community.schemewiki.org/?sicp-ex-2.58
(mattcheck "deriv: mult prioritization 1"
           (deriv '(x + 3 * (x + y + 2)) 'x)
           4)
(mattcheck "deriv: mult prioritization 2"
           (deriv '(x * (y * (x + 3))) 'x)
           '((x * y) + (y * (x + 3))))
(mattcheck "deriv: mult prioritization 3"
           (deriv '((x * y) * (x + 3)) 'x)
           '((x * y) + (y * (x + 3))))
;; Checks from "future Matt"
(mattcheck "deriv: mult prioritization 4a"
           (deriv '(x + 3 + x + y * 2) 'x)
           2)
(mattcheck "deriv: mult prioritization 4b"
           (deriv '(y * 2 + x + 3 + x) 'x)
           2)
\end{minted}

\begin{verbatim}
<unknown-location>: warning: possibly unbound variable `mattcheck'
SUCCEED at deriv: basic addition
SUCCEED at deriv: basic multiplication
SUCCEED at deriv: bad simplification
SUCCEED at deriv: longer addition
SUCCEED at deriv: longer multiplication
SUCCEED at deriv: mult prioritization 1
SUCCEED at deriv: mult prioritization 2
SUCCEED at deriv: mult prioritization 3
SUCCEED at deriv: mult prioritization 4a
FAIL at deriv: mult prioritization 4b
expected: 2
returned: (y * 2)
\end{verbatim}

Above is my first solution. I modified \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{make-sum} to
check the operator after the current one, see if it was a multiplication, and
if so to evaluate it with \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{make-product} before doing the current
addition. The ``immutable variable'' ways of problem solving makes this pretty
easy:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; I want to do f to the first item of x, unless some-condition? in the second
;; item, in which case do g to the 2nd item before x to the first
(define (foo x)
  (if (some-condition? (cdr x))
      (f (cons (car x)
               (g (cdr x))))
      (f x)))
\end{minted}

If I were doing this with mutable variables, where I needed to perform these
modifications in-place in one data structure, I might not have the tools to
solve that problem.

However, I came back to this problem after continuing on ahead so far as \hyperref[sec:orgda8f430]{Exercise 2.91: division of polynomials}, when someone on the
Discord asked for help. Upon re-examination I realized that this first solution
does \emph{not} solve the problem in an algebraically equivalent way, as you can see
by the last two tests I added above. I had assumed that because addition and
multiplication were commutative, that I only needed to account for immediately
adjacent operations. This was not the case. I must solve the higher-priority
operations in a list first before starting any of the lower ones.

TODO:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define func-list '(product? sum?))
(define priority-list '(* +))
(define (solve-in-order exp func-list)
  (if (< (length exp) 3)
      '()
      (cons (list-index (lambda(i)(eqv? i (cadr exp)))
                        priority-list)
            (find-solution-order (cddr exp)))))
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (sum? x) (and (pair? x) (eq? (cadr x) '+)))
(define (addend s) (car s))
(define (augend s)
  (let ((rest (cddr s)))
    (if (null? (cdr rest))
        (car rest)
        rest)))
(define (product? x) (and (pair? x) (eq? (cadr x) '*)))
(define (multiplier p) (car p))
(define (multiplicand p)
  (let ((rest (cddr p)))
    (if (null? (cdr rest))
        (car rest)
        rest)))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2))
         (+ a1 a2))
        ((product? a2)
         (list a1 '+ ;; cross your fingers!
               (make-product (multiplier a2)
                             (multiplicand a2))))
        (else (list a1 '+ a2))))
(define (=number? exp num)
  (and (number? exp) (= exp num)))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list m1 '* m2))))
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp) (make-sum (deriv (addend exp) var)
                              (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        (else
         (error "unknown expression type: DERIV" exp))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<deriv-algebraic-fixed>>
(load "mattcheck2.scm")
(mattcheck "deriv: basic addition"
           (deriv '(x + 3) 'x)
           1)
(mattcheck "deriv: basic multiplication"
           (deriv '(x * y) 'x)
           'y)
(mattcheck "deriv: bad simplification"
           (deriv '((x * y) * (x + 3)) 'x)
           '((x * y) + (y * (x + 3))))
(mattcheck "deriv: longer addition"
           (deriv '(x + 3 + 6 + z) 'x)
           1)
(mattcheck "deriv: longer multiplication"
           (deriv '(x * y * (x + 3)) 'x)
           '((x * y) + (y * (x + 3))))

;; Test cases from:
;; http://community.schemewiki.org/?sicp-ex-2.58
(mattcheck "deriv: mult prioritization 1"
           (deriv '(x + 3 * (x + y + 2)) 'x)
           4)
(mattcheck "deriv: mult prioritization 2"
           (deriv '(x * (y * (x + 3))) 'x)
           '((x * y) + (y * (x + 3))))
(mattcheck "deriv: mult prioritization 3"
           (deriv '((x * y) * (x + 3)) 'x)
           '((x * y) + (y * (x + 3))))
;; Checks from "future Matt"
(mattcheck "deriv: mult prioritization 4a"
           (deriv '(x + 3 + x + y * 2) 'x)
           2)
(mattcheck "deriv: mult prioritization 4b"
           (deriv '(y * 2 + x + 3 + x) 'x)
           2)
\end{minted}

\subsection{Exercise 2.59: Representing sets}
\label{sec:org6345454}
\subsubsection{Text definitions}
\label{sec:orgf2c96c0}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (element-of-set?-manual x set)
  (cond ((null? set) #f)
        ((equal? x (car set)) #t)
        (else (element-of-set? x (cdr set)))))
(define element-of-set? member) ; builtins are faster :)

(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))

(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) 
         '())
        ((element-of-set? (car set1) set2)
         (cons (car set1)
               (intersection-set (cdr set1) 
                                 set2)))
        (else (intersection-set (cdr set1) 
                                set2))))
\end{minted}

\subsubsection{Question}
\label{sec:org68cb619}
Implement the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{union-set} operation for the unordered-list representation of sets.

\subsubsection{Answer}
\label{sec:org73aa03d}
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{union-set} at a first glance looks like the opposite of
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{intersection-set}, since the logic looks like ``merge two sets, and if
an element exists in both than don't include it''. However it's actually just
avoiding putting a symbol in twice.


\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (union-set-rec set1 set2)
  (cond ((or (null? set1) (null? set2))
         set2)
        ((element-of-set? (car set1) set2)
         (union-set-rec (cdr set1)
                        set2))
        (else (cons (car set1)
                    (union-set-rec (cdr set1)
                                   set2)))))
(define (union-set set1 set2)
    (define (iter s result)
      (cond ((null? s)
             (reverse result))
            ((element-of-set? (car s) set2)
             (iter (cdr s) result))
            (else
             (iter (cdr s)
                   (cons (car s)
                         result)))))
    (append (iter set1 '())
            set2))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<sets-txt>>
<<union-set>>
(load "mattcheck2.scm")
(let ((set1 (list 1 2 3 4 5 6))
      (set2 (list 4 5 6 7 8 9))
      (set-union (list 1 2 3 4 5 6 7 8 9)))
  (mattcheck "union-set-rec"
             (union-set-rec set1 set2)
             set-union)
  (mattcheck "union-set"
             (union-set set1 set2)
             set-union))
\end{minted}

\begin{verbatim}
SUCCEED at union-set-rec
SUCCEED at union-set
\end{verbatim}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<enumerate-interval>>
<<sets-txt>>
<<union-set>>
(load "../mattbench.scm")

(let ((set1 (enumerate-interval 1 1000))
      (set2 (enumerate-interval 500 1500)))
  (define (test)
    (format #t "~&recursive union-sets: ~a"
            (cadr (mattbench2 (lambda()(union-set-rec set1 set2)) 10000)))
    (format #t "~&iterative union-sets: ~a"
            (cadr (mattbench2 (lambda()(union-set set1 set2)) 10000))))

  (test))
\end{minted}

\begin{verbatim}
recursive union-sets: 4704343.6974
iterative union-sets: 4755592.2304
\end{verbatim}

Man, my ``optimized'' versions never work. I would blame it on the Scheme compiler
but I'm a new programmer so it's probably a skill issue.

\subsection{Exercise 2.59: Sets with duplicates}
\label{sec:org4d5185c}
\subsubsection{Question}
\label{sec:org9eff840}
We specified that a set would be represented as a list with no duplicates. Now
suppose we allow duplicates. For instance, the set \(\{1, 2, 3\}\) could be
represented as the list \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(2 3 2 1 3 2 2)}. Design procedures
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{element-of-set?}, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{adjoin-set}, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{union-set}, and
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{intersection-set} that operate on this representation. How does the
efficiency of each compare with the corresponding procedure for the
non-duplicate representation? Are there applications for which you would use
this representation in preference to the non-duplicate one?

\subsubsection{Answer}
\label{sec:org55db441}
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{element-of-set} can be left unchanged. The others are a matter of
getting sloppy: \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{adjoin-set} can just be a \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cons}, and
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{union-set} can be an append. Now the remaining question is, how to
make \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{intersection-set} keep the duplicates?

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (adjoin-set-dupes x set)
  (cons x set))

(define (union-set-dupes set1 set2)
  (append set1 set2))

(define (intersection-set-dupes set1 set2)
  (let ((inter (intersection-set set1 set2)) ;; yes, we're calling the non-duplicate version
        (union (union-set-dupes set1 set2)))
    (filter (lambda(x) (element-of-set? x inter))
            union)))
(define (intersection-set-dupes2 set1 set2)
  (let ((inter (intersection-set set1 set2)) ;; yes, we're calling the non-duplicate version
        (inter2 (intersection-set set2 set1)))
    (append inter inter2)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<sets-txt>>
<<union-set>>
<<set-dupes>>
(load "mattcheck2.scm")
(let ((set1 (list 1 2 3 4 5 6))
      (set2 (list 4 5 6 7 8 9))
      (set-union (list 1 2 3 4 5 6 7 8 9))
      (set-union-dupes
       (list 1 2 3 4 5 6 4 5 6 7 8 9))
      (set-intersection (list 4 5 6))
      (set-intersection-dupes
       (list 4 5 6 4 5 6)))
  (mattcheck "union-set-dupes"
             (union-set-dupes set1 set2)
             set-union-dupes)
  (mattcheck "union-set"
             (union-set set1 set2)
             set-union)
  (mattcheck "intersection-set"
             (intersection-set set1 set2)
             set-intersection)
  (mattcheck "intersection-set-dupes"
             (intersection-set-dupes set1 set2)
             set-intersection-dupes)
  (mattcheck "intersection-set-dupes2"
             (intersection-set-dupes2 set1 set2)
             set-intersection-dupes))
\end{minted}

\begin{verbatim}
SUCCEED at union-set-dupes
SUCCEED at union-set
SUCCEED at intersection-set
SUCCEED at intersection-set-dupes
SUCCEED at intersection-set-dupes2
\end{verbatim}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<enumerate-interval>>
<<sets-txt>>
<<union-set>>
<<set-dupes>>
(use-modules (ice-9 format))
(load "../mattbench.scm")

(let ((set1 (enumerate-interval 1 1000))
      (set2 (enumerate-interval 500 1500)))
  (define (test)
    (format #t "~&union-sets: ~a"
            (cadr (mattbench2 (lambda()(union-set set1 set2)) 10000)))
    (format #t "~&union-sets-dupes: ~a"
            (cadr (mattbench2 (lambda()(union-set-dupes set1 set2)) 10000)))
    (format #t "~&intersection-set: ~a"
            (cadr (mattbench2 (lambda()(intersection-set set1 set2)) 10000)))
    (format #t "~&intersection-set-dupes: ~a"
            (cadr (mattbench2 (lambda()(intersection-set-dupes set1 set2)) 10000)))
    (format #t "~&intersection-set-dupes2: ~a"
            (cadr (mattbench2 (lambda()(intersection-set-dupes2 set1 set2)) 10000)))
    )

  (test))
\end{minted}

\begin{verbatim}
union-sets: 4734892.3798
union-sets-dupes: 40132.52
intersection-set: 4673425.9196
intersection-set-dupes: 10325053.8432
intersection-set-dupes2: 10872996.2555
\end{verbatim}

So for \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{union-sets} a significant speedup, while in algorithms that
need to check for duplicates like \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{intersection-set} it's much more
time. Also, in a no-duplicate implementation \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{element-of-set}, it
wouldn't be wasting time checking duplicates.

\subsection{Exercise 2.61: Ordered sets}
\label{sec:org860db92}
\subsubsection{Question}
\label{sec:org2dd2978}
Give an implementation of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{adjoin-set} using the ordered
representation. By analogy with \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{element-of-set?} show how to take
advantage of the ordering to produce a procedure that requires on the average
about half as many steps as with the unordered representation.

\subsubsection{Answer}
\label{sec:orgbc53879}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (element-of-set?-ordered x set)
  (cond ((null? set) #f)
        ((= x (car set)) #t)
        ((< x (car set)) #f)
        (else (element-of-set?-ordered x (cdr set)))))

(define (adjoin-set-ordered x set)
  (define (iter checked rest)
    (cond ((null? rest)
           (append checked (list x)))
          ((= x (car rest)) set)
          ((> x (car rest))
           (iter (cons (car rest)
                       checked)
                 (cdr rest)))
          (else (append (reverse checked)
                        (cons x rest)))))
  (iter '() set))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<sets-txt>>
<<union-set>>
<<set-ordered>>
(load "mattcheck2.scm")
(let ((set (list 1 2 4 5 6 7 8 9))
      (answer (list 1 2 3 4 5 6 7 8 9)))
  (mattcheck "adjoin-set-ordered"
             (adjoin-set-ordered 3 set)
             answer))
\end{minted}

\begin{verbatim}
SUCCEED at adjoin-set-ordered
\end{verbatim}

\subsection{Exercise 2.62: \texttt{union-set} ordered}
\label{sec:org7162e98}
\subsubsection{Question}
\label{sec:org1b6e6f5}
Give a \(\Theta(n)\) implementation of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{union-set} for sets
represented as ordered lists.

\subsubsection{Answer}
\label{sec:org671123e}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (union-set-ordered set1 set2)
  (define (iter s1 s2 result)
    (cond ((null? s1)
           (append (reverse result) s2))
          ((null? s2)
           (append (reverse result) s1))
          (else
           (let ((s1a (car s1))
                 (s2a (car s2)))
             (cond ((= s1a s2a)
                    (iter (cdr s1) (cdr s2)
                          (cons s1a result)))
                   ((< s1a s2a)
                    (iter (cdr s1) s2
                          (cons s1a result)))
                   ((> s1a s2a)
                    (iter s1 (cdr s2)
                          (cons s2a result))))))))
  (iter set1 set2 '()))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<sets-txt>>
<<union-set>>
<<set-ordered>>
<<union-set-ordered>>
(load "mattcheck2.scm")
(let ((set1 (list 1 2 3 4 5))
      (set2 (list 4 5 6 7 8 9))
      (answer (list 1 2 3 4 5 6 7 8 9)))
  (mattcheck "union-set-ordered"
             (union-set-ordered set1 set2)
             answer))
\end{minted}

\begin{verbatim}
SUCCEED at union-set-ordered
\end{verbatim}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<enumerate-interval>>
<<sets-txt>>
<<union-set>>
<<union-set-ordered>>
(use-modules (ice-9 format))
(load "../mattbench.scm")

;; http://community.schemewiki.org/?sicp-ex-2.62
(define (union-set-alt set1 set2) 
  (cond  ((null? set1) set2) 
         ((null? set2) set1) 
         (else  
          (let ((x1 (car set1)) 
                (x2 (car set2))) 
            (cond ((= x1 x2) (cons x1 (union-set-alt (cdr set1) (cdr set2)))) 
                  ((< x1 x2) (cons x1 (union-set-alt (cdr set1) set2))) 
                  (else (cons x2 (union-set-alt set1 (cdr set2)))))))))
(define (union-set-alt2 set1 set2) 
  (cond ((null? set1) set2) 
        ((null? set2) set1) 
        (else 
         (let ((x1 (car set1)) 
               (x2 (car set2))) 
           (cons (min x1 x2) 
                 (union-set-alt2 (if (> x1 x2) 
                                     set1 
                                     (cdr set1)) 
                                 (if (> x2 x1) 
                                     set2 
                                     (cdr set2))))))))

(let ((set1 (enumerate-interval 1 1000))
      (set2 (enumerate-interval 500 1500)))
  (define (test)
    (format #t "~&union-set: ~a"
            (cadr (mattbench2 (lambda()(union-set set1 set2)) 10000)))
    (format #t "~&union-set-ordered: ~a"
            (cadr (mattbench2 (lambda()(union-set-ordered set1 set2)) 50000)))
    (format #t "~&union-set-alt: ~a"
            (cadr (mattbench2 (lambda()(union-set-alt set1 set2)) 500000)))
    (format #t "~&union-set-alt2: ~a"
            (cadr (mattbench2 (lambda()(union-set-alt2 set1 set2)) 500000)))
    )

  (test))
\end{minted}

\begin{verbatim}
union-set: 4758999.4984
union-set-ordered: 107784.3673
union-set-alt: 45441.7717
union-set-alt2: 66262.4295
\end{verbatim}

\subsection{Exercise 2.63: binary trees}
\label{sec:orgeffc652}
\subsubsection{Text definitions}
\label{sec:org520c597}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))
\end{minted}

\subsubsection{Question A}
\label{sec:org9b59e53}
Each of the following two
procedures converts a binary tree to a list.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<make-tree>>
(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree)
                    (tree->list-1
                      (right-branch tree))))))
(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list
                              (right-branch tree)
                              result-list)))))
  (copy-to-list tree '()))
\end{minted}

\begin{enumerate}
\item Do the two procedures produce the same result for every tree? If not, how do
the results differ? What lists do the two procedures produce for the trees in
Figure 2.16?
\end{enumerate}

\subsubsection{Answer A}
\label{sec:orgf3d5723}
First let's check whether the arrangement of the input tree impacts the output
list. I'd like a couple functions for generating lists.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (rightward-tree list)
  (if (null? list)
      '()
      (make-tree (car list) '()
                 (rightward-tree (cdr list)))))
(define (leftward-tree list)
  (define (rec list)
    (if (null? list)
        '()
        (make-tree (car list) (rec (cdr list))
                   '())))
  (rec list))
(define (nested-tree list)
  (define (rec list)
    (cond ((= 1 (length list))
           (make-tree (car list) '() '()))
          ((= 2 (length list))
           (make-tree (cadr list)
                      (make-tree (car list) '() '())
                      '()))
          (else
           (let ((halfway (truncate/ (length list)
                                     2)))
                 (make-tree (list-ref list halfway)
                            (rec (list-head list halfway))
                            (rec (list-tail list (1+ halfway))))))))
  (rec list))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<echo>>
<<tree-to-list>>
<<tree-makers>>

(let* ((nil '())
       (1-to-4 (list 1 2 3 4))
       (tree-right
        (rightward-tree 1-to-4))
       (tree-left
        (leftward-tree 1-to-4))
       (tree-middle
        (nested-tree (iota 10))))
  (echo "tree-right:" tree-right)
  (echo "tree-right list 1:" (tree->list-1 tree-right))
  (echo "tree-right list 2:" (tree->list-2 tree-right))
  (newline)
  (echo "tree-left:" tree-left)
  (echo "tree-left list 1:" (tree->list-1 tree-left))
  (echo "tree-left list 2:" (tree->list-2 tree-left))
  (newline)
  (echo "tree-middle:" tree-middle)
  (echo "tree-middle list 1:" (tree->list-1 tree-middle))
  (echo "tree-middle list 2:" (tree->list-2 tree-middle)))
\end{minted}

\begin{verbatim}
tree-right: (1 () (2 () (3 () (4 () ())))) 
tree-right list 1: (1 2 3 4) 
tree-right list 2: (1 2 3 4) 

tree-left: (1 (2 (3 (4 () ()) ()) ()) ()) 
tree-left list 1: (4 3 2 1) 
tree-left list 2: (4 3 2 1) 

tree-middle: (5 (2 (1 (0 () ()) ()) (4 (3 () ()) ())) (8 (7 (6 () ()) ()) (9 () ()))) 
tree-middle list 1: (0 1 2 3 4 5 6 7 8 9) 
tree-middle list 2: (0 1 2 3 4 5 6 7 8 9) 
\end{verbatim}

So, the lists are the same for both.

Fun fact: Emacs org-babel has suddenly stopped accepting the \(\lambda\) character
in source code.

\subsubsection{Question B}
\label{sec:org41d0ce3}
Do the two procedures have the same order of growth in the number of steps
required to convert a balanced tree with \(n\) elements to a list? If not, which
one grows more slowly?

\subsubsection{Answer B}
\label{sec:orgc28ba58}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; tree->list-1 evaluating the following tree:
;;     7
;;    / \
;;   3   9
;;  / \   \
;; 1   5   11
(append (append (append nil
                        (cons 1
                              nil))
                (cons 3
                      (append nil
                              (cons 5
                                    nil))))
        (cons 7
              (append nil
                      (cons 9
                            (append nil
                                    (cons 11
                                          nil))))))
;; holy cow that is wasteful. So many appends of nothing.

;; tree->list-2 evaluation (iterative)
(copy-to-list [full tree] nil)
(copy-to-list [tree 3 1 5]
              (cons 7
                    (copy-to-list
                     [tree 9 11]
                     nil)))
(copy-to-list [tree 3 1 5]
              (cons 7
                    (copy-to-list
                     nil
                     (cons 9
                           (copy-to-list
                            [tree 11]
                            nil)))))
(copy-to-list [tree 3 1 5]
              (cons 7
                    (copy-to-list
                     nil
                     (cons 9
                           (copy-to-list
                            nil
                            (cons 11
                                  (copy-to-list nil nil)))))))
(copy-to-list [tree 3 1 5]
              '(7 9 11))
(copy-to-list [tree 1]
              (cons 3
                    (copy-to-list
                     nil
                     (cons 5
                           (copy-to-list
                            nil
                            '(7 9 11))))))
(copy-to-list
 nil
 (cons 1
       (copy-to-list
        nil
        '(3 5 7 9 11))))
'(1 3 5 7 9 11)
\end{minted}

So, assuming the evaluation isn't as slow as operations like \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{append},
the second is definitely faster -- it's basically just evaluating to a series of
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cons} statements. The internet suggests that the first is
\(\Theta(n\log{n})\) while the second is \(\Theta(n)\).

\subsection{Exercise 2.64: Making a balanced binary tree}
\label{sec:org909c43b}
The following procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{list->tree} converts an ordered list to a
balanced binary tree. The helper procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{partial-tree} takes as
arguments an integer \(n\) and list of at least \(n\) elements and constructs a
balanced tree containing the first \(n\) elements of the list. The result
returned by \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{partial-tree} is a pair (formed with \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cons})
whose \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{car} is the constructed tree and whose \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cdr} is the
list of elements not included in the tree.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<make-tree>>
(define (list->tree elements)
  (car (partial-tree elements (length elements))))
(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result
               (partial-tree elts left-size)))
          (let ((left-tree (car left-result))
                (non-left-elts (cdr left-result))
                (right-size (- n (+ left-size 1))))
            (let ((this-entry (car non-left-elts))
                  (right-result
                   (partial-tree
                    (cdr non-left-elts)
                    right-size)))
              (let ((right-tree (car right-result))
                    (remaining-elts
                     (cdr right-result)))
                (cons (make-tree this-entry
                                 left-tree
                                 right-tree)
                      remaining-elts))))))))
\end{minted}

\subsubsection{Question A}
\label{sec:org879c78d}
Write a short paragraph explaining as clearly as you can how
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{partial-tree} works. Draw the tree produced by \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{list->tree}
for the list \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(1 3 5 7 9 11)}.

\subsubsection{Answer A}
\label{sec:org27d34e8}
For my own sake, I'll reorganize this with \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{let*}.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let* ((left-size (quotient (- n 1) 2))
            (left-result (partial-tree
                          elts
                          left-size))
            (left-tree (car left-result))
            (non-left-elts (cdr left-result))
            (right-size (- n (+ left-size 1)))
            (this-entry (car non-left-elts))
            (right-result (partial-tree
                           (cdr non-left-elts)
                           right-size))
            (right-tree (car right-result))
            (remaining-elts (cdr right-result)))
        (cons (make-tree this-entry
                         left-tree
                         right-tree)
              remaining-elts))))

\end{minted}

Say we're evaluating \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{'(1 3 5 7 9 11)}. We define
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{left-size} as \(\lfloor n/2 \rfloor\). \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{partial-tree} recurses
until hitting \(n=0\), at which point it returns the starting list with
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{'()} prepended to it. This is used as the empty left branch for the
second-to-the-bottom row of the tree, in this case for the tree node of
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{1}. That empty tree branch is saved in \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{left-tree},
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{this-entry} (\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{1}) is defined, then we recurse to the right
branch, finding a bottom to place \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{3}. Finally, the tree with only 3
is returned, it becomes the right branch off \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{1}, making
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(make-tree 1 '() (make-tree 3 '() '()))}. This gets
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cons}'d to the remaining list, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{'(5 7 9 11)}. Upon
returning the new list, this will become the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{left-tree} of its parent
process. All in all, this is a recursive algorithm that kind of solves itself
with minimal logic. Note its evaluation always comes back to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cons}
operations.

This is very elegant. However, I am left wondering how clear this is in
comparison with some C routine that does the same thing.

\begin{center}
\includegraphics[width=.9\linewidth]{2/fig/Ex64.png}
\end{center}

\subsubsection{Question B}
\label{sec:orga9ead36}
What is the order of growth in the number of steps required by
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{list->tree} to convert a list of \(n\) elements?

\subsubsection{Answer B}
\label{sec:org1cc63d3}
I'm going to estimate that it's \(\Theta(n)\) because of the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cons}
operations being the cornerstone of the procedure. The internet appears to agree
in this case.

\subsection{Exercise 2.65: Sets as binary trees}
\label{sec:orga67bac8}
\subsubsection{Textbook Definitions}
\label{sec:org7901ee0}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (element-of-set?-tree x set)
  (cond ((null? set) #f)
        ((= x (entry set)) #t)
        ((< x (entry set))
         (element-of-set?-tree
          x 
          (left-branch set)))
        ((> x (entry set))
         (element-of-set?-tree
          x 
          (right-branch set)))))
(define (adjoin-set-tree x set)
  (cond ((null? set) (make-tree x '() '()))
        ((= x (entry set)) set)
        ((< x (entry set))
         (make-tree 
          (entry set)
          (adjoin-set-tree x (left-branch set))
          (right-branch set)))
        ((> x (entry set))
         (make-tree
          (entry set)
          (left-branch set)
          (adjoin-set-tree x (right-branch set))))))
\end{minted}

\subsubsection{Question}
\label{sec:org3a8877e}
Use the results of Exercise 2.63 and Exercise 2.64 to give \(\Theta(n)\)
implementations of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{union-set} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{intersection-set} for
sets implemented as (balanced) binary trees.

\subsubsection{Answer}
\label{sec:org6ac54ba}
Ok, now that's stretching my brain for sure. Hmm\ldots{}

I think I need to look closer at how \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{tree->list} works.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (tree->list-debug tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (let ((result
               (begin (echo ">> entering tree at" (entry tree) "results" result-list)
                      (copy-to-list (left-branch tree)
                                    (begin (echo "we'll cons" (entry tree))
                                           (let ((pair
                                                  (cons (entry tree)
                                                        (copy-to-list
                                                         (right-branch tree)
                                                         result-list))))
                                             (echo "  cons'd" pair)
                                             pair))))))
          (echo "<< leaving tree at" (entry tree) "results" result-list)
          result)))
  (copy-to-list tree '()))
\end{minted}

\begin{verbatim}
>> entering tree at 5 results ()
we'll cons 5
>> entering tree at 9 results ()
we'll cons 9
>> entering tree at 11 results ()
we'll cons 11
  cons'd (11)
<< leaving tree at 11 results ()
  cons'd (9 11)
>> entering tree at 7 results (9 11)
we'll cons 7
  cons'd (7 9 11)
<< leaving tree at 7 results (9 11)
<< leaving tree at 9 results ()
  cons'd (5 7 9 11)
>> entering tree at 1 results (5 7 9 11)
we'll cons 1
>> entering tree at 3 results (5 7 9 11)
we'll cons 3
  cons'd (3 5 7 9 11)
<< leaving tree at 3 results (5 7 9 11)
  cons'd (1 3 5 7 9 11)
<< leaving tree at 1 results (5 7 9 11)
<< leaving tree at 5 results ()
(1 3 5 7 9 11)
\end{verbatim}

What's really holding me up is the \(\Theta(n)\) complexity. Since I'm probably
not going to figure this out easily, let's try doing it the ``wrong'' way first,
by using previously made algorithms.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<make-tree>>
<<list-to-tree>>
<<tree-to-list>>
<<tree-sets-txt>>

(define (tree->list-debug tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (let ((result
               (begin (echo ">> entering tree at" (entry tree) "results" result-list)
                      (copy-to-list (left-branch tree)
                                    (begin (echo "we'll cons" (entry tree))
                                           (let ((pair
                                                  (cons (entry tree)
                                                        (copy-to-list
                                                         (right-branch tree)
                                                         result-list))))
                                             (echo "  cons'd" pair)
                                             pair))))))
          (echo "<< leaving tree at" (entry tree) "results" result-list)
          result)))
  (copy-to-list tree '()))

(define (union-set-tree-wrong1 set1 set2)
  (define (copy-to-list tree held-tree result-list)
    (define (swap-trees)
      (copy-to-list held-tree tree result-list))
    (define (advance-tree-no-cons)
      (copy-to-list (left-branch tree)
                    held-tree
                    (copy-to-list
                     (right-branch tree)
                     held-tree
                     result-list)))
    (define (advance-tree-cons)
      (copy-to-list (left-branch tree)
                    held-tree
                    (cons (entry tree)
                          (copy-to-list
                           (right-branch tree)
                           held-tree
                           result-list))))
    (define (advance-both-cons)
      (copy-to-list (left-branch tree)
                    held-tree
                    (cons (entry tree)
                          (copy-to-list
                           (right-branch tree)
                           held-tree
                           result-list))))
    (cond ((and (null? tree)
                (null? held-tree))
           result-list)
          ((null? tree)
           (swap-trees))
          ((= (entry tree)
              (car result-list))
           (advance-tree-no-cons))
          ((= (entry tree) (entry held-tree))
           (advance-both-cons))
          ((< (entry tree) (entry held-tree))
           (advance-tree-cons))
          ((> (entry tree) (entry held-tree))
           (swap-trees))))
  (copy-to-list set1 set2 '()))

(define (union-set-tree-wrong2 set1 set2)
  (define (copy-to-tree tree result-tree)
    (if (null? tree)
        result-tree
        (copy-to-tree (left-branch tree)
                      (adjoin-set-tree (entry tree)
                                       (copy-to-tree
                                        (right-branch tree)
                                        result-tree)))))
  (copy-to-tree set1 set2))

(define (intersection-set-tree-wrong1 set1 set2)
  (define (copy-to-tree tree result-tree)
    (if (null? tree)
        result-tree
        (let ((adjoin-or-not
               (lambda (rest)
                 (if (element-of-set?-tree (entry tree)
                                           set2)
                     (adjoin-set-tree (entry tree)
                                      rest)
                     rest))))
          (copy-to-tree (left-branch tree)
                        (adjoin-or-not
                         (copy-to-tree
                          (right-branch tree)
                          result-tree))))))
    (copy-to-tree set1 '()))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<sets-as-trees>>
<<echo>>
(load "mattcheck2.scm")
(let ((set1 (list->tree '(1 3 5 7 9 11)))
;; (5 (1 () (3 () ())) (9 (7 () ()) (11 () ())))
      (set2 (list->tree '(2 4 6 7 8 11)))
;; (6 (2 () (4 () ())) (8 (7 () ()) (11 () ())))
      (union (list->tree '(1 2 3 4 5 6 7 8 9 11)))
;; (5 (2 (1 () ()) (3 () (4 () ()))) (8 (6 () (7 () ())) (9 () (11 () ()))))
      (union-unbal '(6 (2 (1 () ()) (4 (3 () ()) (5 () ()))) (8 (7 () ()) (11 (9 () ()) ()))))
      (int-unbal '(11 (7 () ()) ()))
      (int (list->tree '(7 11))))
;; (7 () (11 () ()))
  (mattcheck "element-of-set?-tree true"
             (element-of-set?-tree 1 set1)
             #t)
  (mattcheck "element-of-set?-tree true"
             (element-of-set?-tree 7 set1)
             #t)
  (mattcheck "element-of-set?-tree false"
             (element-of-set?-tree 2 set1)
             #f)
  (mattcheck "union-set-tree-wrong2"
             (union-set-tree-wrong2 set1 set2)
             union-unbal)
  (mattcheck "intersection-set-tree-wrong1"
             (intersection-set-tree-wrong1 set1 set2)
             int-unbal)
  (echo (tree->list-debug set1)))
\end{minted}

\begin{verbatim}
SUCCEED at element-of-set?-tree true
SUCCEED at element-of-set?-tree true
SUCCEED at element-of-set?-tree false
SUCCEED at union-set-tree-wrong2
SUCCEED at intersection-set-tree-wrong1
\end{verbatim}

I can't really think of a better way to do it. Time to look up the answer!

And\ldots{} To my surprise, the answer most internet people have given is what I
called the ``wrong'' one. In their case, using \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{tree->list} and
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{list->tree} to apply the list-based \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{union-set} and
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{intersection-set}, saying it's \(\Theta(n)\). I also notice that they
didn't use \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{element-of-set?} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{adjoin-to-set} like I did.

Let's compare.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-modules (ice-9 format))
(load "../mattbench.scm")
<<sets-txt>>
<<sets-as-trees>>
<<enumerate-interval>>
(define tree->list tree->list-2)
(define (union-set set1 set2)
  (cond ((or (null? set1) (null? set2))
         set2)
        ((element-of-set? (car set1) set2)
         (union-set (cdr set1)
                        set2))
        (else (cons (car set1)
                    (union-set (cdr set1)
                                   set2)))))

;; from http://community.schemewiki.org/?sicp-ex-2.65
(define (union-set-l2t set1 set2)
  (cond ((null? set1) set2)
        ((null? set2) set1)
        (else (list->tree (union-set (tree->list set1) (tree->list set2))))))

(define (intersection-set-l2t set1 set2)
  (cond ((null? set1) '())
        ((null? set2) '())
        (else (list->tree (intersection-set (tree->list set1) (tree->list set2))))))

(define (make-2sets max)
  (let* ((a-start 0)
         (a-end 0.6)
         (b-start 0.4)
         (b-end 1))
    (cons (list->tree
           (enumerate-interval
            0
            (inexact->exact (* a-end max))))
          (list->tree
           (enumerate-interval
            (inexact->exact (* b-start max))
            (inexact->exact (* b-end max)))))))

(define (test-with 2sets repeats)
  (format #t "~&union-set-tree-wrong2: ~a"
          (cadr (mattbench2
                 (lambda()(union-set-tree-wrong2
                      (car 2sets)
                      (cdr 2sets)))
                 repeats)))
  (format #t "~&union-set-l2t: ~a"
          (cadr (mattbench2
                 (lambda()(union-set-l2t (car 2sets)
                                    (cdr 2sets)))
                 repeats)))
  (format #t "~&intersection-set-tree-wrong1: ~a"
          (cadr (mattbench2
                 (lambda()(intersection-set-tree-wrong1
                      (car 2sets)
                      (cdr 2sets)))
                 repeats)))
  (format #t "~&intersection-set-l2t: ~a"
          (cadr (mattbench2
                 (lambda()(intersection-set-l2t (car 2sets)
                                           (cdr 2sets)))
                 repeats))))
(format #t "~&~a" (make-2sets 10))
(define base-repeats 10000)
(test-with (make-2sets 100)
           base-repeats)
(test-with (make-2sets 1000)
           (/ base-repeats 2))
(test-with (make-2sets 10000)
           (/ base-repeats 4))
\end{minted}

\begin{verbatim}
union-set-tree-wrong2: 159831.3273
union-set-l2t: 49633.5962
intersection-set-tree-wrong1: 42577.4905
intersection-set-l2t: 33261.5268
union-set-tree-wrong2: 12648028.8732
union-set-l2t: 2196015.1536
intersection-set-tree-wrong1: 3165935.4476
intersection-set-l2t: 2015603.052
union-set-tree-wrong2: 1393227860.116
union-set-l2t: 195546567.7616
intersection-set-tree-wrong1: 361923468.7844
intersection-set-l2t: 195366120.9524
\end{verbatim}

\begin{center}
\includegraphics[width=.9\linewidth]{2/fig/2-65.png}
\end{center}

Not really enough datapoints, but you can at least see that the \texttt{l2t} variants
are faster.

\subsection{Exercise 2.66: binary tree \texttt{lookup}}
\label{sec:orgd0719d7}
\subsubsection{Question}
\label{sec:org9f3a147}
Implement the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{lookup} procedure for the case where the set of records
is structured as a binary tree, ordered by the numerical values of the keys.

\subsubsection{Answer}
\label{sec:org64dbf25}
First let's define what these records look like.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (make-record key value)
  (cons key value))
(define (key record)
  (car record))
(define (value record)
  (cdr record))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<make-tree>>
<<make-record>>
(define (lookup given-key tree-of-records)
  (cond ((null? tree-of-records) #f)
        ((= given-key
            (key (entry tree-of-records)))
         (entry tree-of-records))
        ((< given-key
            (key (entry tree-of-records)))
         (lookup
          given-key 
          (left-branch tree-of-records)))
        ((> given-key
            (key (entry tree-of-records)))
         (lookup
          given-key 
          (right-branch tree-of-records)))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<lookup-tree>>
<<list-to-tree>>
<<echo>>
(load "mattcheck2.scm")
(let ((set1 (list->tree
             (list (make-record 1 'a)
                   (make-record 3 'b)
                   (make-record 5 'c)
                   (make-record 7 'd)
                   (make-record 9 'e)
                   (make-record 11 'f)))))
  (mattcheck "lookup retrieves correct record"
             (lookup 9 set1)
             (make-record 9 'e)))
\end{minted}

\begin{verbatim}
SUCCEED at lookup retrieves correct record
\end{verbatim}

\subsection{Exercise 2.67: decoding Huffman tree messages}
\label{sec:org2803cb8}
\subsubsection{Text definitions}
\label{sec:org0e05447}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; huffman-trees-txt
(define (make-leaf symbol weight)
  (list 'leaf
        symbol
        weight))
(define (leaf? object)
  (eq? (car object)
       'leaf))
(define (symbol-leaf x)
  (cadr x))
(define (weight-leaf x)
  (caddr x))

(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))

(define (left-branch  tree)
  (car tree))
(define (right-branch tree)
  (cadr tree))
(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))
(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))
(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch
               (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))
(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error "bad bit: CHOOSE-BRANCH" bit))))
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set))) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))
(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs)))
        (adjoin-set (make-leaf (car pair)
                               (cadr pair))
                    (make-leaf-set (cdr pairs))))))
\end{minted}

\subsubsection{Question}
\label{sec:org61f998d}
Define an encoding tree and a sample message. Use the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{decode}
procedure to decode the message, and give the result.

\subsubsection{Answer}
\label{sec:orgfa95ac4}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<huffman-trees-txt>>
<<echo>>
(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree
                    (make-leaf 'D 1)
                    (make-leaf 'C 1)))))
(define whos-on-first-tree
  (make-code-tree
   (make-leaf 'who 8)
                  (make-code-tree
                   (make-leaf 'what 4)
                   (make-code-tree
                    (make-leaf 'Idontknow 2)
                    (make-leaf 'why 2)))))
(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
(define whos-on-first-message '(0 1 0 1 1 0 1 1 1))
(echo (decode sample-message sample-tree))
(echo (decode whos-on-first-message whos-on-first-tree))
\end{minted}

\begin{verbatim}
(A D A B B C A) 
(who what Idontknow why) 
\end{verbatim}

\subsection{Exercise 2.68: encoding Huffman tree messages}
\label{sec:orgcf92bd5}
\subsubsection{Question}
\label{sec:orgf8cbc91}
The \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{encode} procedure takes as arguments a message and a tree and
produces the list of bits that gives the encoded message.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; encode-txt
(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))
\end{minted}

\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{encode-symbol} is a procedure, which you must write, that returns the
list of bits that encodes a given symbol according to a given tree. You should
design \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{encode-symbol} so that it signals an error if the symbol is
not in the tree at all. Test your procedure by encoding the result you obtained
in Exercise 2.67 with the sample tree and seeing whether it is the same as the
original sample message.

\subsubsection{Answer}
\label{sec:orgabeef88}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; encode-symbol
(define element-of-set? member)
(define (encode-symbol symbol tree)
  (define (rec t)
    (cond ((and (leaf? t)
                (eq? (symbol-leaf t)
                     symbol))
           '())
          ((element-of-set? symbol
                            (symbols (left-branch t)))
           (cons 0
                 (rec (left-branch t))))
          ((element-of-set? symbol
                            (symbols (right-branch t)))
           (cons 1
                 (rec (right-branch t))))
          (else (error "encode-symbol: logic error"))))
  (if (element-of-set? symbol (symbols tree))
      (rec tree)
      (error "encode-symbol: symbol not in tree")))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<huffman-trees-txt>>
<<encode-txt>>
<<encode-symbol>>
(load "mattcheck2.scm")
(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree
                    (make-leaf 'D 1)
                    (make-leaf 'C 1)))))
(define whos-on-first-tree
  (make-code-tree
   (make-leaf 'who 8)
                  (make-code-tree
                   (make-leaf 'what 4)
                   (make-code-tree
                    (make-leaf 'Idontknow 2)
                    (make-leaf 'why 2)))))
(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
(define whos-on-first-message '(0 1 0 1 1 0 1 1 1))
(mattcheck "sample encoded message"
           sample-message
           (encode '(A D A B B C A)
                   sample-tree))
(mattcheck "who's on first encoded message"
           whos-on-first-message
           (encode '(who what Idontknow why)
                   whos-on-first-tree))
\end{minted}

\begin{verbatim}
SUCCEED at sample encoded message
SUCCEED at who's on first encoded message
\end{verbatim}

\subsection{Exercise 2.69: Generating Huffman trees}
\label{sec:orgeb359a6}
\subsubsection{Question}
\label{sec:org10b4c77}
The following procedure takes as its argument a list of symbol-frequency pairs
(where no symbol appears in more than one pair) and generates a Huffman encoding
tree according to the Huffman algorithm.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))
\end{minted}

\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{make-leaf-set} is the procedure given above that transforms the list
of pairs into an ordered set of leaves. \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{successive-merge} is the
procedure you must write, using \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{make-code-tree} to successively merge
the smallest-weight elements of the set until there is only one element left,
which is the desired Huffman tree. (This procedure is slightly tricky, but not
really complicated. If you find yourself designing a complex procedure, then you
are almost certainly doing something wrong. You can take significant advantage
of the fact that we are using an ordered set representation.)

\subsubsection{Answer}
\label{sec:org38165e8}
This one took a while. The whole in-place-reorganization of the list seems
tricky, since adding branches together makes a new branch which is higher value
than the later entries. In a C language I'd be solving the problem by ``moving'' a
play-head forward and back, but here I'll have to coerce the evaluator into
doing it.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; generate-huffman-tree
(use-srfis '(1))
(define element-of-set? member)
(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))

(define (successivemerge-iter delayed leaves)
  (let ((dl (length delayed))
        (ll (length leaves)))
    (cond ((= ll 0)
           (successivemerge-iter '()
                                 delayed))
          ((= dl 0)
           (if (= ll 1)
               (car leaves)
               (successivemerge-iter (cons (car leaves) '())
                                     (cdr leaves))))
          ((and (= ll 1)
                (= dl 1))
           (make-code-tree (car delayed)
                           (car leaves)))
          ((<= (weight (car delayed))
               (weight (car leaves)))
           (successivemerge-iter (cdr delayed)
                                 (cons (make-code-tree (car delayed)
                                                       (car leaves))
                                       (cdr leaves))))
          ((> (weight (car delayed))
              (weight (car leaves)))
           (successivemerge-iter (cons (car leaves)
                                       delayed)
                                 (cdr leaves))))))

  (define (successive-merge leaves)
    (successivemerge-iter (cons (car leaves) '())
                          (cdr leaves)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<huffman-trees-txt>>
<<encode-txt>>
<<encode-symbol>>
<<generate-huffman-tree>>
<<echo>>
(load "mattcheck2.scm")

(let ((pairs
       (make-leaf-set '((A 8)(B 3)(C 1)(D 1)
                        (E 1)(F 1)(G 1)(H 1))))
      (answer
       (make-code-tree (make-leaf 'A 8)
                       (make-code-tree
                        (make-code-tree
                         (make-leaf 'B 3)
                         (make-code-tree
                          (make-leaf 'C 1)
                          (make-leaf 'D 1)))
                        (make-code-tree
                         (make-code-tree
                          (make-leaf 'E 1)
                          (make-leaf 'F 1))
                         (make-code-tree
                          (make-leaf 'G 1)
                          (make-leaf 'H 1)))))))
  (mattcheck "successive-merge"
             (successive-merge pairs)
             answer)
  (echo (successive-merge pairs)))
\end{minted}

\begin{verbatim}
FAIL at successive-merge
expected: ((leaf A 8) (((leaf B 3) ((leaf C 1) (leaf D 1) (C D) 2) (B C D) 5) (# â¦) â¦) â¦)
returned: (((((leaf H 1) (leaf G 1) (H G) 2) ((leaf F 1) (leaf E 1) (F E) 2) (â¦) â¦) â¦) â¦)
(((((leaf H 1) (leaf G 1) (H G) 2) ((leaf F 1) (leaf E 1) (F E) 2) (H G F E) 4)
  (((leaf D 1) (leaf C 1) (D C) 2) (leaf B 3) (D C B) 5) (H G F E D C B) 9)
    (leaf A 8) (H G F E D C B A) 17) 
\end{verbatim}

And the tree is \emph{backwards}. But it is correct. \begin{tiny}Sigh.\end{tiny}

Time to be embarrassed by the internet's solution.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; see 2.67
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set)))
         (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))
;; for my own edification
(define (adjoin-set-iter x set)
  (define (iter less more)
    (cond ((null? more)
           (reverse (cons x less)))
          ((< (weight x) (weight (car more)))
           (append (reverse (cons x less))
                   more))
          (else (adjoin-set-iter (cons (car more) less)
                                 (cdr more)))))

  (iter '() set))

;; https://codereview.stackexchange.com/a/117980
(define (successive-merge-small leaves)
  (if (null? (cdr leaves))
      (car leaves)
      (successive-merge-small
       (adjoin-set
        (make-code-tree (car leaves)
                        (cadr leaves))
        (cddr leaves)))))
\end{minted}

Comparing my above code with the code for \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{adjoin-set}, mine is
definitely unnecessarily complicated. How does the performance stack up?

\begin{verbatim}
Mine: 4453.0773347
Theirs: 4554.0141235
\end{verbatim}

So for all that unnecessary complexity it's still about the same.

The lesson I keep failing to learn is remembering past work (i.e.
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{adjoin-set}), since this book loves to integrate past exercises.

\subsection{Exercise 2.70: encoding 1950s rock songs}
\label{sec:org14d9f2e}
\subsubsection{Question}
\label{sec:org3d981cb}
The following eight-symbol alphabet with associated relative frequencies was
designed to efficiently encode the lyrics of 1950s rock songs. (Note that the
âsymbolsâ of an âalphabetâ need not be individual letters.)


\begin{center}
\begin{tabular}{lrlr}
A & 2 & NA & 16\\[0pt]
BOOM & 1 & SHA & 3\\[0pt]
GET & 2 & YIP & 9\\[0pt]
JOB & 2 & WAH & 1\\[0pt]
\end{tabular}
\end{center}

Use \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{generate-huffman-tree} to generate a corresponding Huffman tree,
and use \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{encode} to encode the following message:

\begin{verbatim}
Get a job
Sha na na na na na na na na

Get a job
Sha na na na na na na na na

Wah yip yip yip yip 
yip yip yip yip yip
Sha boom
\end{verbatim}

How many bits are required for the encoding? What is the smallest number of bits
that would be needed to encode this song if we used a fixed-length code for the
eight-symbol alphabet?

\subsubsection{Answer}
\label{sec:org4819dc2}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define hippie-set
  '((NA 16)(YIP 9)(SHA 3)(A 2)
    (GET 2)(JOB 2)(BOOM 1)(WAH 1)))
(define hippie-tree
  (generate-huffman-tree hippie-set))
(define hippie-plaintext
  '(GET A JOB
    SHA NA NA NA NA NA NA NA NA
    GET A JOB
    SHA NA NA NA NA NA NA NA NA
    WAH YIP YIP YIP YIP
    YIP YIP YIP YIP YIP
    SHA BOOM))
(define hippie-encoded
  (encode hippie-plaintext
          hippie-tree))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<huffman-trees-txt>>
<<encode-txt>>
<<encode-symbol>>
<<generate-huffman-tree>>
(define (successive-merge leaves)
  (if (null? (cdr leaves))
      (car leaves)
      (successive-merge
       (adjoin-set
        (make-code-tree (car leaves)
                        (cadr leaves))
        (cddr leaves)))))
<<hippie-trees>>
<<echo>>
(load "mattcheck2.scm")

(echo "Length of unencoded message is" (length hippie-plaintext) "words.")
(echo "Length of encoded message is" (length hippie-encoded) "bits")
(echo "Unencoded message (newlines added):" (decode hippie-encoded hippie-tree))
\end{minted}

\begin{verbatim}
Length of unencoded message is 36 words. 
Length of encoded message is 84 bits 
Unencoded message (newlines added):
(GET A JOB
SHA NA NA NA NA NA NA NA NA
GET A JOB SHA NA NA NA NA NA NA NA NA
WAH YIP YIP YIP YIP
YIP YIP YIP YIP YIP
SHA BOOM) 
\end{verbatim}

A fixed-length alphabet would take 3 bits per word, or 108 bits. So the VLE is
77\% the size of anything else.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<huffman-trees-txt>>
<<encode-txt>>
<<encode-symbol>>
<<generate-huffman-tree>>
(define (successive-merge leaves)
  (if (null? (cdr leaves))
      (car leaves)
      (successive-merge
       (adjoin-set
        (make-code-tree (car leaves)
                        (cadr leaves))
        (cddr leaves)))))
<<hippie-trees>>
(define (split-list-every-x list x)
  (define (rec ll)
    (if (< (length ll) x)
        (cons ll '())
        (cons (list-head ll x)
              (rec (list-tail ll x)))))
  (rec list))
(split-list-every-x hippie-encoded 7)
\end{minted}

\begin{center}
\begin{tabular}{rrrrrrr}
1 & 1 & 1 & 1 & 1 & 1 & 1\\[0pt]
0 & 0 & 1 & 1 & 1 & 1 & 0\\[0pt]
1 & 1 & 1 & 0 & 0 & 0 & 0\\[0pt]
0 & 0 & 0 & 0 & 0 & 1 & 1\\[0pt]
1 & 1 & 1 & 1 & 1 & 0 & 0\\[0pt]
1 & 1 & 1 & 1 & 0 & 1 & 1\\[0pt]
1 & 0 & 0 & 0 & 0 & 0 & 0\\[0pt]
0 & 0 & 0 & 1 & 1 & 0 & 1\\[0pt]
0 & 1 & 0 & 1 & 0 & 1 & 0\\[0pt]
1 & 0 & 1 & 0 & 1 & 0 & 1\\[0pt]
0 & 1 & 0 & 1 & 0 & 1 & 1\\[0pt]
1 & 0 & 1 & 1 & 0 & 1 & 1\\[0pt]
\hline
\end{tabular}
\end{center}


\begin{center}
\includegraphics[width=.9\linewidth]{2/fig/2-70.png}
\end{center}

\subsection{Exercise 2.71}
\label{sec:org29b0b19}
\subsubsection{Questions}
\label{sec:org1d174c1}
Suppose we have a Huffman tree for an alphabet of \(n\) symbols, and that the
relative frequencies of the symbols are \(1, 2, 4, \dots, 2^{n-1}\). Sketch the
tree for \(n=5\); for \(n=10\). In such a tree (for general \(n\)) how many bits
are required to encode the most frequent symbol? The least frequent symbol?

\subsubsection{Answers}
\label{sec:orgdb2de23}
In this type of tree, the most frequent symbol takes 1 bit. The \(n\)th symbol
takes \(n\) bits. If it's the least frequent symbol and \(n\) is even, it takes
\(n-1\) bits.

\subsection{Exercise 2.72: order of growth of \texttt{encode}}
\label{sec:org1d4944f}
Let's take a look at \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{encode-symbol}. 

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; encode-symbol
(define (encode-symbol symbol tree)
  (define (rec t) ;; rec is O(log n)
    (cond ((and (leaf? t) 
                (eq? (symbol-leaf t)
                     symbol)) ; O(1)
           '())
          ((element-of-set? symbol ; O(symbols of left-branch)
                            (symbols (left-branch t)))
           (cons 0 ;; O(1)
                 (rec (left-branch t)))) ;; rec is O(log symbols)
          ((element-of-set? symbol ; O(symbols of right-branch)
                            (symbols (right-branch t)))
           (cons 1 ;; O(1)
                 (rec (right-branch t)))) ;; rec is O(log symbols)
          (else (error "encode-symbol: logic error"))))
  (if (element-of-set? symbol (symbols tree)) ;; O(symbols)
      (rec tree) ;; rec is O(log n)
      (error "encode-symbol: symbol not in tree")))
\end{minted}

I'm not expecting to get a correct answer,but here's what I'm able to derive.
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{encode-symbol} uses binary search to find the symbol, which is
\(\Theta(\log{n})\). However, at each step it needs to perform a \(\Theta(n)\)
search of the left branch. If the symbol isn't found, it will execute a
\(\Theta(n)\) search of the right branch. So these searches have a varying cost
depending on if the tree is biased to the left or the right. So in the worst
case of being right-biased, the searches will incur an order of \(\Theta(n2)\),
while doing the overall binary search of \(\Theta(\log{n})\). So I think this
simplifies to \(\Theta(n \log{n})\). Time to check my answer\ldots{}

While I see a couple answers\footnote{see the answer of \texttt{aos} here:
\url{http://community.schemewiki.org/?sicp-ex-2.72}} agreeing with mine, I see more saying that
\texttt{encode-symbol} is \(\Theta(1)\) for the most frequent symbol, and \(\Theta(n)\)
for the average case. Some also say\footnote{\url{https://mk12.github.io/sicp/exercise/2/3.html\#ex2.72} and others.} that in the worst case (the least
frequent symbol), you may have to visit every non-leaf node for a complexity of
\(\Theta(n^2)\).

\subsection{2.4: Multiple Representations for Abstract Data}
\label{sec:org22950c1}
We have learned how to abstract ``higher'' and ``lower'' parts of a system. Now we
will talk about having multiple simultaneous representations of data in the same
system. This could be considered ``side-by-side'' abstraction. The authors tout
the 

To allow programmers to add and remove representations at will without modifying
the original code, the authors suggest using a table lookup system to keep track
of representations and their related methods. For example:

\begin{center}
\begin{tabular}{l|ll}
Operations & Polar Type & Rectangular Type\\[0pt]
\hline
real-part & real-part-polar & real-part-rectangular\\[0pt]
imag-part & imag-part-polar & imag-part-rectangular\\[0pt]
magnitude & magnitude-polar & magnitude-rectangular\\[0pt]
angle & angle-polar & angle-rectangular\\[0pt]
\end{tabular}
\end{center}

\begin{description}
\item[{data-directed programming}] designing programs to organize their behaviors
by a table of operations like the one above.
\item[{principle of least commitment}] abstracting a system so it can work with
\end{description}
many possible representations of data without being rewritten.

The book introduces two methods, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(put 'operation 'type lambda)} to
add such a method to the table, and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(get 'operation 'type)} to fetch
the saved lambda. I'll use Guile's native \href{https://www.gnu.org/software/guile/manual/html\_node/Hash-Table-Reference.html}{hash tables}\footnote{\url{https://www.gnu.org/software/guile/manual/html\_node/Hash-Table-Reference.html}}
to implement this.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define op-table (make-hash-table))

(define (put operation type f)
  (hash-set! op-table (cons operation type) f))
(define (get operation type)
  (hash-ref op-table (cons operation type)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; basic test of lambda storage
<<op-table>>
<<echo>>
(put 'A 'X (lambda()'AX))
(put 'B 'Y (lambda()'BY))
(put 'C 'Z (lambda()'CZ))

(echo ((get 'A 'X))
      ((get 'B 'Y))
      ((get 'C 'Z)))
\end{minted}

\begin{verbatim}
AX BY CZ 
\end{verbatim}

One method to distinguish these types of items is called \textbf{type tagging}. Take this code as an example:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "Bad tagged datum: 
              TYPE-TAG" datum)))

(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error "Bad tagged datum: 
              CONTENTS" datum)))
\end{minted}

\subsection{Exercise 2.73: Data-driven symbolic differentiator}
\label{sec:org2b532af}
\hyperref[sec:orgd597c64]{2.3.2: Example: Symbolic differentiator} described a program that performs
symbolic differentiation:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum (make-product
                    (multiplier exp)
                    (deriv (multiplicand exp) var))
                   (make-product
                    (deriv (multiplier exp) var)
                    (multiplicand exp))))
        ;; more rules can be added here
        (else (error "unknown expression type:
                      DERIV" exp))))
\end{minted}

We can regard this program as performing a dispatch on the type of the
expression to be differentiated. In this situation the ''type tag'' of the datum
is the algebraic operator symbol (such as \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{+}) and the operation being
performed is \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{deriv}. We can transform this program into data-directed
style by rewriting the basic derivative procedure as

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        (else ((get 'deriv (operator exp))
               (operands exp) var))))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
\end{minted}

\subsubsection{Question A}
\label{sec:orgfcb9ba6}
Explain what was done above. Why can't we assimilate the predicates
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{number?} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{variable?} into the data-directed dispatch?

\subsubsection{Answer A}
\label{sec:org638116e}
This rewrite removes the predicate-based tests for sums, products, etc,
replacing them with the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{get}-based lookup system explained earlier.

The call to \texttt{get} requires using the \texttt{operator} procedures on \texttt{exp}, which would
fail on a single-item \texttt{exp}. So it is necessary to handle the number and
variable checks before calling \texttt{deriv}.

\subsubsection{Questions B and C}
\label{sec:org321273c}
\begin{itemize}
\item Write the procedures for derivatives of sums and products, and the auxiliary
code required to install them in the table used by the program above.
\item Choose any additional differentiation rule that you like, such as the one for
exponents (\hyperref[sec:org30ff1f7]{Exercise 2.56: Differentiating exponentiation}), and install it in
this data-directed system.
\end{itemize}

\subsubsection{Answer B \& C version 1}
\label{sec:orgef530ee}
Here's my first solution, which is functional, but not at all idiomatic like the textbook's examples of such a system.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
;; old ^^ vv new
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        (else ((get 'deriv (operator exp))
               (operands exp) var))))
;; vv old
(define (addend s) (car s)) ;; these and similar procedures
(define (augend s) (cadr s));; modified for 2-item lists of operands
(define (multiplier p) (car p))
(define (multiplicand p) (cadr p))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2))
         (+ a1 a2))
        (else (list '+ a1 a2))))
(define (=number? exp num)
  (and (number? exp) (= exp num)))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))
(define (base e) (car e))
(define (exponent e) (cadr e))
(define (make-exponentiation b e)
  (cond ((=number? b 1) 1)
        ((=number? e 0) 1)
        ((=number? e 1) b)
        ((and (number? b) (number? e)) (expt b e))
        (else (list '** b e))))
;; new table-entered functions
(put 'deriv '+
     (lambda (ops var)
       (make-sum (deriv (addend ops) var)
                 (deriv (augend ops) var))))
(put 'deriv '*
     (lambda (ops var)
       (make-sum (make-product
                  (multiplier ops)
                  (deriv (multiplicand ops) var))
                 (make-product
                  (deriv (multiplier ops) var)
                  (multiplicand ops)))))
(put 'deriv '**
     (lambda (ops var)
         (make-product  
          (make-product  
           (exponent ops) 
           (make-exponentiation (base ops) 
                                (make-sum (exponent ops) -1)))                                                                                               
          (deriv (base ops) var))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<op-table>>
<<deriv-datadriven>>
(load "mattcheck2.scm")
(mattcheck "deriv: basic addition"
           (deriv '(+ x 3) 'x)
           1)
(mattcheck "deriv: basic multiplication"
           (deriv '(* x y) 'x)
           'y)

(mattcheck "deriv: exponentiation 1"
           (deriv (make-exponentiation 'a 5) 'a)
           '(* 5 (** a 4)))
(mattcheck "deriv: exponentiation 2"
           (deriv (make-exponentiation 'a 'b) 'a)
           '(* b (** a (+ b -1))))
\end{minted}

\begin{verbatim}
SUCCEED at deriv: basic addition
SUCCEED at deriv: basic multiplication
SUCCEED at deriv: exponentiation 1
SUCCEED at deriv: exponentiation 2
\end{verbatim}

\subsubsection{Answer B \& C version 2}
\label{sec:orgf77bf3b}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (deriv exp var)
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  (define (operator exp) (type-tag exp)) ;; use type tags
  (define (operands exp) (contents exp))

  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        (else ((get 'deriv (operator exp))
               (operands exp) var))))

(define (install-deriv-package choice)
  ;;shared procedures
  (define (=number? exp num)
    (and (number? exp) (= exp num)))
  (define (make-sum a1 a2)
    (cond ((=number? a1 0) a2)
          ((=number? a2 0) a1)
          ((and (number? a1) (number? a2))
           (+ a1 a2))
          (else (attach-tag '+ (list a1 a2)))))
  (define (make-product m1 m2)
    (cond ((or (=number? m1 0) (=number? m2 0)) 0)
          ((=number? m1 1) m2)
          ((=number? m2 1) m1)
          ((and (number? m1) (number? m2)) (* m1 m2))
          (else (attach-tag '* (list m1 m2)))))
  (define (make-exponentiation b e)
    (cond ((=number? b 1) 1)
          ((=number? e 0) 1)
          ((=number? e 1) b)
          ((and (number? b) (number? e)) (expt b e))
          (else (attach-tag '** (list b e)))))

  ;; packages
  (define (install-sum-package)
    (define (addend s) (car s))
    (define (augend s) (cadr s))
    (put 'deriv '+
         (lambda (ops var)
           (make-sum (deriv (addend ops) var)
                     (deriv (augend ops) var)))))

  (define (install-mult-package)
    (define (multiplier p) (car p))
    (define (multiplicand p) (cadr p))
    (put 'deriv '*
         (lambda (ops var)
           (make-sum (make-product
                      (multiplier ops)
                      (deriv (multiplicand ops) var))
                     (make-product
                      (deriv (multiplier ops) var)
                      (multiplicand ops))))))
  (define (install-exp-package)
    (define (base e) (car e))
    (define (exponent e) (cadr e))
    (put 'deriv '**
         (lambda (ops var)
           (make-product  
            (make-product  
             (exponent ops) 
             (make-exponentiation (base ops) 
                                  (make-sum (exponent ops)
                                            -1)))
            (deriv (base ops) var)))))

  ;;body
  (cond ((eqv? choice 'sum)
         (install-sum-package))
        ((eqv? choice 'mult)
         (install-mult-package))
        ((eqv? choice 'exp)
         (install-exp-package))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<op-table>>
<<type-tagging>>
<<deriv-datadriven2>>
(load "mattcheck2.scm")
(install-deriv-package 'sum)
(install-deriv-package 'mult)
(install-deriv-package 'exp)
(mattcheck "deriv: basic addition"
           (deriv '(+ x 3) 'x)
           1)
(mattcheck "deriv: basic multiplication"
           (deriv '(* x y) 'x)
           'y)

(mattcheck "deriv: exponentiation 1"
           (deriv '(** a 5) 'a) ;; no more external access
           '(* 5 (** a 4)))
(mattcheck "deriv: exponentiation 2"
           (deriv '(** a b) 'a)
           '(* b (** a (+ b -1))))
\end{minted}

\begin{verbatim}
SUCCEED at deriv: basic addition
SUCCEED at deriv: basic multiplication
SUCCEED at deriv: exponentiation 1
SUCCEED at deriv: exponentiation 2
\end{verbatim}

It's notable that Scheme doesn't let you access the sub-definitions inside
definitions, so I had to change my tests above. It makes me miss the dot
notation that future languages would use for accessing children of objects. It
also makes debugging processes less informative, not showing entries in the
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{,trace foo} system call.

\subsubsection{Question D}
\label{sec:org72015ae}
In this simple algebraic manipulator the type of an expression is the algebraic
operator that binds it together. Suppose, however, we indexed the procedures in
the opposite way, so that the dispatch line in \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{deriv} looked like

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
((get (operator exp) 'deriv)
 (operands exp) var)
\end{minted}

What corresponding changes to the derivative system are required?

\subsubsection{Answer D}
\label{sec:orga182225}
Besides the change given in the example above, all the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{put} calls would need their arguments switched.

\subsection{Exercise 2.74: Multi-division record storage}
\label{sec:org053aef8}
\subsubsection{Questions ABC}
\label{sec:orgf534ae2}
Insatiable Enterprises, Inc., is a highly decentralized conglomerate company
consisting of a large number of independent divisions located all over the
world. The company's computer facilities have just been interconnected by means
of a clever network-interfacing scheme that makes the entire network appear to
any user to be a single computer. Insatiable's president, in her first attempt
to exploit the ability of the network to extract administrative information from
division files, is dismayed to discover that, although all the division files
have been implemented as data structures in Scheme, the particular data
structure used varies from division to division. A meeting of division managers
is hastily called to search for a strategy to integrate the files that will
satisfy headquarters' needs while preserving the existing autonomy of the
divisions.

Show how such a strategy can be implemented with data-directed programming. As
an example, suppose that each division's personnel records consist of a single
file, which contains a set of records keyed on employees' names. The structure
of the set varies from division to division. Furthermore, each employee's record
is itself a set (structured differently from division to division) that contains
information keyed under identifiers such as \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{address} and
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{salary}. In particular:

\begin{enumerate}
\item Implement for headquarters a \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{get-record} procedure that retrieves
a specified employee's record from a specified personnel file. The procedure
should be applicable to any division's file. Explain how the individual
divisions' files should be structured. In particular, what type information
must be supplied?

\item Implement for headquarters a \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{get-salary} procedure that returns
the salary information from a given employee's record from any division's
personnel file. How should the record be structured in order to make this
operation work?

\item Implement for headquarters a \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{find-employee-record} procedure. This
should search all the divisions' files for the record of a given employee and
return the record. Assume that this procedure takes as arguments an
employee's name and a list of all the divisions' files.
\end{enumerate}

\subsubsection{Answers ABC}
\label{sec:org7e79be9}
Let's talk assumptions:
\begin{itemize}
\item Assume every division has one file
\item Assume HQ wants a consistent schema returned
\end{itemize}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<make-tree>>
<<make-record>>
<<op-table>>
(define (find x ll)
  (define (iter ll) ;; aka SRFI-1 'find'
    (cond ((null? ll)
           #f)
          ((equal? id (employee-id-east (car ll)))
           (car ll))
          (else (iter (cdr ll)))))
  (iter ll))

;; East: records as named cdr aliases
(define (install-east-package)
  (define (make-employee-east id salary)
    (cons id (/ salary 1000))) ;; East keeps salary in thousands
  (define (employee-id-east record)
    (car record))
  (define (employee-salary-east record)
    (* (cdr record) 1000))
  (define East-Employee-List
    (list (make-employee-east 101 37000) ; bob
          (make-employee-east 102 48000) ; linda
          (make-employee-east 103 29000) ; john
          ))
  (define (find-employee-east id)
    (find id East-Employee-List))
  (put 'employee-record 'East
       (lambda (id)
         (let ((e (find-employee-east id)))
           (if e
               (list (list 'id id)
                     (list (employee-salary-east e)))
               #f))))
  (put 'employee-salary 'East
       (lambda(id) 
         (employee-salary-east (find-employee-east id)))))

;; records as lookup trees (Ex 2.66)
(define (install-west-package)
  (define (maketree . args)
    (apply list->tree args))
  (define (make-employee-west id name salary)
    (make-record 'id
                 (maketree (make-record 'name name)
                           (make-record 'salary salary))))
  (define West-Record-File
    (maketree (make-employee-west 201 "James" 55000)
              (make-employee-west 202 "Joy" 45000)
              (make-employee-west 203 "Richard" 73000)))
  (define (employee-west id)
    (lookup id West-Record-File))
  (define (employee-attrib-west attrib record)
    (lookup attrib record))
  (put 'employee-record 'West
       (lambda(id)
         (let ((e (employee-west id)))
           (if e
               (list (list 'id id)
                     (list 'name (employee-attrib-west 'name e))
                     (list 'salary (employee-attrib-west 'salary e)))
               #f))))
  (put 'employee-salary 'West
       (lambda(id)
         (employee-attrib-west 'salary
                               (employee-west id)))))

;; South: records as lambdas
(define (install-south-package)
  (define (make-employee-south id name salary)
    (lambda(value)
      (cond ((eqv? 'id) id)
            ((eqv? 'name) name)
            ((eqv? 'salary) (* 1000
                               (/ salary 1000))))))
  (define South-Employee-File
    (list (make-employee-south 301 "Jacquelyn" 49000)
          (make-employee-south 302 "Mazie" 66000)))
  (define (find-employee-south id)
    (define (iter ll)
      (cond ((null? ll)
             #f)
            ((equal? id ((car ll) 'id))
             (car ll))
            (else (iter (cdr ll)))))
    (iter South-Employee-File))
  
  (put 'employee-record 'West
       (lambda(id)
         (let ((e (find-employee-south id)))
           (if e
               (list (list 'id id)
                     (list 'name (e 'id))
                     (list 'salary (e 'salary)))
               #f))))
  (put 'employee-salary 'South
       (lambda(id)
         ((find-employee-west id) 'salary))))

;; HQ record fetcher
(define (get-record employee-id division)
  ((get 'employee-record division)
   employee-id))

;; HQ's salary fetcher
(define (get-salary employee-id division)
  ((get 'employee-salary division)
   employee-id))

;; HQ's employee finder
;; problem asks for "list of files" but since we're working with
;; differently-structured files it must need the procs as well
;; and there's one file per division
(define (find-employee-record id list-of-divisions)
  (if (null? list-of-divisions)
      #f
      (let ((result (get-record id (car list-of-divisions))))
        (if result
            result
            (find-employee-record (cdr list-of-divisions))))))
\end{minted}


In retrospect I should have designed it so each file had a type tag for the division, methods took a file, and dispatch was made on the file's tag. This makes more sense in a real-world context.

\subsubsection{Question D}
\label{sec:org0bdde59}
When Insatiable takes over a new company, what changes must be made in order to
incorporate the new personnel information into the central system?

\subsubsection{Answer D}
\label{sec:orgf581034}
The new division must provide appropriate methods for \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{get-record} and
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{get-salary} to use.

\subsection{2.4.3: Data-directed and message-passing programs}
\label{sec:orgbd8d313}
Altogether the book has introduced 3 ways to organize functions and data types:

\begin{enumerate}
\item Generic operations with explicit dispatch: functions which each include
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{case} statements to dispatch depending on type of data provided.
Bulk of the book so far.
\item Data-directed style: given a tagged object and a desired operation, lookup
what function to call.
\item Message-passing style: package operations with their appropriate data
objects, then fetch those operations from the object.
\end{enumerate}

\subsection{Exercise 2.75: Message-passing styled imaginary numbers}
\label{sec:org21a5fd5}
\subsubsection{Question}
\label{sec:org8e2fa24}
Implement the constructor \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{make-from-mag-ang} in message-passing
style. This procedure should be analogous to the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{make-from-real-imag}
procedure given above.

\subsubsection{Answer}
\label{sec:org1611753}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (make-from-mag-ang r a)
  (define (dispatch op)
    (cond ((eq? op 'magnitude) r)
          ((eq? op 'angle) a)
          ((eq? op 'real-part)
           (* r (cos a)))
          ((eq? op 'imag-part)
           (* r (sin a)))
          (else (error "Unknown op: MAKE-FROM-MAG-ANG" op))))

  dispatch)
\end{minted}

\subsection{Exercise 2.76: comparing generic operation solutions}
\label{sec:orgedf0b95}
\subsubsection{Question}
\label{sec:org1684f8e}
As a large system with generic operations evolves, new types of data objects or
new operations may be needed. For each of the three strategies---generic
operations with explicit dispatch, data-directed style, and
message-passing-style---describe the changes that must be made to a system in
order to add new types or new operations. Which organization would be most
appropriate for a system in which new types must often be added? Which would be
most appropriate for a system in which new operations must often be added?

\subsubsection{Answer}
\label{sec:org841c430}
The most important part of this is where code \emph{doesn't} need to be changed.

\begin{description}
\item[{Generic operations with explicit dispatch}] let you add new functions without
changing existing code.
\item[{Message-passing style}] let you add new data types without modifying existing
code.
\item[{Data-directed table-lookups}] let you add new data types \emph{and} functions
without modifying existing code.
\end{description}

Let's be clear: this does not really save you much code, only the cognitive load
imposed when you have to enter old code to modify it. Let's say \(T\) is how
many data types you have, \(O\) is how many desired operations you have. All of
these are \(O\times T\), the key is where the code is being stored and what it
effects.

This issue of one change requiring traveling across your code to change dozens
of definitions is described as the \href{http://c2.com/cgi/wiki?ExpressionProblem}{Expression Problem}\footnote{\url{http://c2.com/cgi/wiki?ExpressionProblem}}. Data-directed table lookups appear to
solve the problem, as discussed by \href{http://community.schemewiki.org/?sicp-ex-2.76}{torinmr in this Scheme wiki solution}\footnote{\url{http://community.schemewiki.org/?sicp-ex-2.76}}.

\begin{quote}
``Old code should not stop working when you add new code.'' -Brian Harvey
\end{quote}

Also of note is that this kind of decision-making between generic operations and
generic datatypes is commonplace in modern OO programming. I wonder what the old
heads from this time period think about OO as it stands today.

\subsection{Exercise 2.77: generic arithmetic package}
\label{sec:orgc38157c}
\subsubsection{Question}
\label{sec:org80e628a}
Louis Reasoner tries to evaluate the expression \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(magnitude z)} where
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{z} is the object shown in Figure 2.24. To his surprise, instead of
the answer 5 he gets an error message from \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{apply-generic}, saying
there is no method for the operation \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{magnitude} on the types
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(complex)}. He shows this interaction to Alyssa P. Hacker, who says
``The problem is that the complex-number selectors were never defined for
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{complex} numbers, just for \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{polar} and
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{rectangular} numbers. All you have to do to make this work is add the
following to the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{complex} package'':

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(put 'real-part '(complex) real-part)
(put 'imag-part '(complex) imag-part)
(put 'magnitude '(complex) magnitude)
(put 'angle '(complex) angle)
\end{minted}

Describe in detail why this works. As an example, trace through all the
procedures called in evaluating the expression \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(magnitude z)} where
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{z} is the object shown in Figure 2.24. In particular, how many times
is \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{apply-generic} invoked? What procedure is dispatched to in each
case?

\subsubsection{Answer}
\label{sec:orgec6408a}
Surprised to find I never actually imported \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{apply-generic}.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<op-table>>
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (error
            "No method for these types: APPLY-GENERIC"
            (list op type-tags))))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (square x) (* x 2))
(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (real-part z) (apply-generic 'real-part z))
(define (imag-part z) (apply-generic 'imag-part z))
(define (magnitude z) (apply-generic 'magnitude z))
(define (angle z) (apply-generic 'angle z))

(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (if (or (inexact? n)
            (inexact? d))
        (cons n d)
        (let ((g (gcd n d)))
          (cons (/ n g) (/ d g)))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  ;; interface to rest of the system
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'numer '(rational) numer) ;; my addition
  (put 'denom '(rational) denom)
  'done)

;; for future use
(define (numer r)
  ((get 'numer '(rational))
   (contents r)))
(define (denom r)
  ((get 'denom '(rational))
   (contents r)))

(define (make-rational n d)
  ((get 'make 'rational) n d))

(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z) (* (magnitude z) (cos (angle z))))
  (define (imag-part z) (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y)
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  ;; internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
                         (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))
  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle))

(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number (lambda (x) (tag x)))
  'done)
\end{minted}

First I want to do sanity checks on the system.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<type-tagging>>
<<generic-arithmetic>>
<<scheme-number-package>>
<<echo>>
(load "mattcheck2.scm")

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)

<<gen-math-tests>>
\end{minted}

\begin{verbatim}
5+5 = (scheme-number . 10) 
5-5 = (scheme-number . 0) 
5*5 = (scheme-number . 25) 
5/5 = (scheme-number . 1) 
1/2 + 1/2 = (rational 1 . 1) 
1/2 - 1/2 = (rational 0 . 1) 
1/2 * 1/2 = (rational 1 . 4) 
1/2 / 1/2 = (rational 1 . 1) 
3+4i + 3+4i = (complex rectangular 6 . 8) 
3+4i - 3+4i = (complex rectangular 0 . 0) 
3+4i * 3+4i = (complex polar 14.0 . 1.8545904360032244) 
3+4i / 3+4i = (complex polar 1.0 . 0.0) 
3m+4deg + 3m+4deg = (complex rectangular -3.921861725181672 . -4.540814971847569) 
3m+4deg - 3m+4deg = (complex rectangular 0.0 . 0.0) 
3m+4deg * 3m+4deg = (complex polar 9 . 8) 
3m+4deg / 3m+4deg = (complex polar 1 . 0) 
\end{verbatim}

Now let's run this:
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
,trace (magnitude (make-complex-from-real-imag 3 4))
\end{minted}

I've heavily pared down this from the real debug output.

\begin{verbatim}
(make-complex-from-real-imag 3 4)
|  (get make-from-real-imag complex)
|  #<procedure 1ca8ad0 at <unknown port>:166:4 (x y)>
(_ 3 4)
|  (get make-from-real-imag rectangular)
|  #<procedure 1ca87e8 at <unknown port>:111:4 (x y)>
|  (_ 3 4)
|  (attach-tag rectangular (3 . 4))
|  (rectangular 3 . 4)
(attach-tag complex (rectangular 3 . 4))
(complex rectangular 3 . 4) <- now fully tagged
(magnitude (complex rectangular 3 . 4))
(apply-generic magnitude (complex rectangular 3 . 4)) <- identifying complex number
|  (map #<procedure type-tag (datum)> ((complex rectangular 3 . 4)))
|  (complex)
|  (get magnitude (complex))
|  #<procedure magnitude (z)>
|  (map #<procedure contents (datum)> ((complex rectangular 3 . 4)))
|  ((rectangular 3 . 4))
(_ #<procedure magnitude (z)> ((rectangular 3 . 4))) <- identifying rectangular number
(magnitude (rectangular 3 . 4))
(apply-generic magnitude (rectangular 3 . 4))
|  (map #<procedure type-tag (datum)> ((rectangular 3 . 4)))
|  (rectangular)
|  (get magnitude (rectangular))
|  #<procedure magnitude (z)>
|  (map #<procedure contents (datum)> ((rectangular 3 . 4)))
|  ((3 . 4))
(_ #<procedure magnitude (z)> ((3 . 4)))
(magnitude (3 . 4)) <- finally applying native operations
|  (square 3)
|  6
|  (square 4)
|  8
3.7416573867739413
\end{verbatim}

The procedures in \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{apply-generic 'complex} are only proxies to other
procedures at the moment. However they could be useful for other procedures that
should need to know very little about the \texttt{complex} package.

\subsection{Exercise 2.78: native scheme numbers}
\label{sec:org1811e23}
\subsubsection{Question}
\label{sec:orge492d22}
The internal procedures in the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{scheme-number} package are essentially
nothing more than calls to the primitive procedures \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{+},
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{-}, etc. It was not possible to use the primitives of the language
directly because our type-tag system requires that each data object have a type
attached to it. In fact, however, all Lisp implementations do have a type
system, which they use internally. Primitive predicates such as
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{symbol?} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{number?} determine whether data objects have
particular types. Modify the definitions of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{type-tag},
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{contents}, and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{attach-tag} from 2.4.2 so that our
generic system takes advantage of Scheme's internal type system. That is to say,
the system should work as before except that ordinary numbers should be
represented simply as Scheme numbers rather than as pairs whose \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{car}
is the symbol \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{scheme-number}.

\subsubsection{Answer}
\label{sec:org711c784}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (attach-tag type-tag contents)
  (if (number? contents)
      contents
      (cons type-tag contents)))

(define (type-tag datum)
  (cond ((pair? datum)
         (car datum))
        ((number? datum)
         'scheme-number)
        (else (error "Bad tagged datum: 
              TYPE-TAG" datum))))

(define (contents datum)
  (cond ((pair? datum)
         (cdr datum))
        ((number? datum)
         datum)
        (else (error "Bad tagged datum: 
              CONTENTS" datum))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define msn make-scheme-number)
(echo "5+5 =" (add (msn 5) (msn 5)))
(echo "5-5 =" (sub (msn 5) (msn 5)))
(echo "5*5 =" (mul (msn 5) (msn 5)))
(echo "5/5 =" (div (msn 5) (msn 5)))
(echo "1/2 + 1/2 =" (add (make-rational 1 2)
                         (make-rational 1 2)))
(echo "1/2 - 1/2 =" (sub (make-rational 1 2)
                         (make-rational 1 2)))
(echo "1/2 * 1/2 =" (mul (make-rational 1 2)
                         (make-rational 1 2)))
(echo "1/2 / 1/2 =" (div (make-rational 1 2)
                         (make-rational 1 2)))
(let ((r (make-complex-from-real-imag 3 4))
      (p (make-complex-from-mag-ang 3 4)))
  (echo "3+4i + 3+4i =" (add r r))
  (echo "3+4i - 3+4i =" (sub r r))
  (echo "3+4i * 3+4i =" (mul r r))
  (echo "3+4i / 3+4i =" (div r r))
  (echo "3m+4deg + 3m+4deg =" (add p p))
  (echo "3m+4deg - 3m+4deg =" (sub p p))
  (echo "3m+4deg * 3m+4deg =" (mul p p))
  (echo "3m+4deg / 3m+4deg =" (div p p)))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<sqrt>>
<<square>>
<<echo>>
<<smarter-type-tagging>>
<<generic-arithmetic>>
<<scheme-number-package>>
(load "mattcheck2.scm")

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)

<<gen-math-tests>>
\end{minted}

\begin{verbatim}
5+5 = 10 
5-5 = 0 
5*5 = 25 
5/5 = 1 
1/2 + 1/2 = (rational 1 . 1) 
1/2 - 1/2 = (rational 0 . 1) 
1/2 * 1/2 = (rational 1 . 4) 
1/2 / 1/2 = (rational 1 . 1) 
3+4i + 3+4i = (complex rectangular 6 . 8) 
3+4i - 3+4i = (complex rectangular 0 . 0) 
3+4i * 3+4i = (complex polar 14.0 . 1.8545904360032244) 
3+4i / 3+4i = (complex polar 1.0 . 0.0) 
3m+4deg + 3m+4deg = (complex rectangular -3.921861725181672 . -4.540814971847569) 
3m+4deg - 3m+4deg = (complex rectangular 0.0 . 0.0) 
3m+4deg * 3m+4deg = (complex polar 9 . 8) 
3m+4deg / 3m+4deg = (complex polar 1 . 0) 
\end{verbatim}

Confirmed by debugging that these calls aren't adding any tags.

\subsection{Exercise 2.79: generic equality}
\label{sec:org2ae333c}
\subsubsection{Question}
\label{sec:org2ac11a7}
Define a generic equality predicate \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{equ?} that tests the equality of
two numbers, and install it in the generic arithmetic package. This operation
should work for ordinary numbers, rational numbers, and complex numbers.

\subsubsection{Answer}
\label{sec:org01fbda0}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (equ? x y) (apply-generic 'equ? x y))
(define (install-equ?)
  (put 'equ? '(scheme-number scheme-number)
       (lambda(x y) (= x y)))
  (put 'equ? '(complex complex)
       (lambda(x y)
         (let ((t1 (type-tag x))
               (t2 (type-tag y)))
           (cond ((and (eqv? t1 'polar)
                       (eqv? t2 'polar))
                    (and (= (apply-generic 'magnitude x)
                            (apply-generic 'magnitude y))
                         (= (apply-generic 'angle x)
                            (apply-generic 'angle y))))
                 (else
                    (and (= (apply-generic 'real-part x)
                            (apply-generic 'real-part y))
                         (= (apply-generic 'imag-part x)
                            (apply-generic 'imag-part y))))))))
  (put 'equ? '(rational rational)
       (lambda(x y)
         (and (= ((get 'numer '(rational)) x)
                 ((get 'numer '(rational)) y))
              (= ((get 'denom '(rational)) x)
                 ((get 'denom '(rational)) y)))))
  (put 'equ? '(real real)
       (lambda(x y) (= x y))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<sqrt>>
<<square>>
<<echo>>
<<smarter-type-tagging>>
<<generic-arithmetic>>
<<scheme-number-package>>
<<equ?>>
(load "mattcheck2.scm")

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)
(install-equ?)

<<gen-math-tests>>

(mattcheck "basic equ? true" (equ? 5 5) #t)
(mattcheck "basic equ? false" (equ? 4 5) #f)
(mattcheck "rect equ? true" (equ? (make-complex-from-real-imag 2 3)
                                  (make-complex-from-real-imag 2 3)) #t)
(mattcheck "rect equ? false" (equ? (make-complex-from-real-imag 2 3)
                                   (make-complex-from-real-imag 2 5)) #f)
(mattcheck "polar equ? true" (equ? (make-complex-from-mag-ang 2 3)
                                   (make-complex-from-mag-ang 2 3)) #t)
(mattcheck "polar equ? false" (equ? (make-complex-from-mag-ang 2 3)
                                    (make-complex-from-mag-ang 2 5)) #f)
(mattcheck "rational equ? true" (equ? (make-rational 2 3)
                                      (make-rational 2 3)) #t)
(mattcheck "rational equ? false" (equ? (make-rational 2 3)
                                       (make-rational 2 5)) #f)
\end{minted}

\begin{verbatim}
<gen-math-tests output>
SUCCEED at basic equ? true
SUCCEED at basic equ? false
SUCCEED at rect equ? true
SUCCEED at rect equ? false
SUCCEED at polar equ? true
SUCCEED at polar equ? false
SUCCEED at rational equ? true
SUCCEED at rational equ? false
\end{verbatim}

\subsection{Exercise 2.80: Generic testing for zero}
\label{sec:org061b96c}
\subsubsection{Question}
\label{sec:org8277f8e}
Define a generic predicate \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{=zero?} that tests if its argument is
zero, and install it in the generic arithmetic package. This operation should
work for ordinary numbers, rational numbers, and complex numbers.

\subsubsection{Answer}
\label{sec:org6363d47}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (=zero? x) (apply-generic '=zero? x))
(define (install-=zero?)
  (put '=zero? '(scheme-number)
       (lambda(x) (= x 0)))
  (put '=zero? '(complex)
       (lambda(x)
         (apply-generic '=zero? x)))
  (let ((magnitude (get 'magnitude '(polar))))
    (put '=zero? '(polar)
         (lambda(x)
           (= 0 (magnitude x)))))
  (let ((real-part (get 'real-part '(rectangular)))
        (imag-part (get 'imag-part '(rectangular))))
    (put '=zero? '(rectangular)
         (lambda(x)
           (and (= 0 (real-part x))
                (= 0 (imag-part x))))))
  (put '=zero? '(rational)
       (lambda(x)
         (or (= 0 ((get 'numer '(rational)) x))
             (= 0 ((get 'denom '(rational)) x))))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<sqrt>>
<<square>>
<<echo>>
<<smarter-type-tagging>>
<<generic-arithmetic>>
<<scheme-number-package>>
<<equ?>>
<<eqzero?>>
(load "mattcheck2.scm")

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)
(install-equ?)
(install-=zero?)
<<gen-math-tests>>

(mattcheck "basic =zero? true" (=zero? 0) #t)
(mattcheck "basic =zero? false" (=zero? 5) #f)
(mattcheck "rect =zero? true" (=zero? (make-complex-from-real-imag 0 0)) #t)
(mattcheck "rect =zero? false" (=zero? (make-complex-from-real-imag 2 5)) #f)
(mattcheck "polar =zero? true" (=zero? (make-complex-from-mag-ang 0 3)) #t)
(mattcheck "polar =zero? false" (=zero? (make-complex-from-mag-ang 2 0)) #f)
(mattcheck "rational =zero? true" (=zero? (make-rational 0 3)) #t)
(mattcheck "rational =zero? false" (=zero? (make-rational 2 3)) #f)
\end{minted}

\begin{verbatim}
<gen-math-tests output>

SUCCEED at basic =zero? true
SUCCEED at basic =zero? false
SUCCEED at rect =zero? true
SUCCEED at rect =zero? false
SUCCEED at polar =zero? true
SUCCEED at polar =zero? false
SUCCEED at rational =zero? true
SUCCEED at rational =zero? false
\end{verbatim}

\subsection{2.4.3: Combining Data of Different Types}
\label{sec:orgbc3e7ae}
So far, the generic type system has had all types be completely independent.
However, all of these number systems have relations between each other,
specifically they can be converted in this order:

integers \rarrow rational \rarrow real \rarrow complex

Converting types to each other is called \textbf{\textbf{coercion}}. With changes to
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{apply-generic}, the system can automatically find compatible
coercions and use them. For example, \(\frac{1}{3}\times3\) is now possible.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (let ((t1->t2 
                       (get-coercion type1
                                     type2))
                      (t2->t1 
                       (get-coercion type2 
                                     type1)))
                  (cond (t1->t2
                         (apply-generic 
                          op (t1->t2 a1) a2))
                        (t2->t1
                         (apply-generic 
                          op a1 (t2->t1 a2)))
                        (else
                         (error 
                          "No method for 
                           these types"
                          (list 
                           op 
                           type-tags))))))
              (error 
               "No method for these types"
               (list op type-tags)))))))
\end{minted}

This assumes \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{put-coercion} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{get-coercion}.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define type-table (make-hash-table))

(define (put-coercion type1 type2 f)
  (hash-set! type-table (cons type1 type2) f))
(define (get-coercion type1 type2)
  (hash-ref type-table (cons type1 type2)))
\end{minted}

Authors observe that much work in programs using object-oriented languages is
around type coercion.

To write coercion procedures between every type would require \(n^2\) routines.
However, by keeping track of the relations between types (similarly to a tree or
graph), we can find paths through multiple coercion routines at once. i.e. we
can coerce type A to type D by coercion routines A->B, B->C, and C->D.

\subsection{Exercise 2.81: Louis' \texttt{apply-generic}}
\label{sec:orgb8c21f7}
Louis Reasoner has noticed that \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{apply-generic} may try to coerce the
arguments to each other's type even if they already have the same type.
Therefore, he reasons, we need to put procedures in the coercion table to coerce
arguments of each type to their own type. For example, in addition to the
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{scheme-number->complex} coercion shown above, he would do:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)
(put-coercion 'scheme-number
              'scheme-number
              scheme-number->scheme-number)
(put-coercion 'complex 'complex complex->complex)
\end{minted}

\subsubsection{Question A}
\label{sec:org6d4d3f6}
With Louis's coercion procedures installed, what happens if
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{apply-generic} is called with two arguments of type
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{scheme-number} or two arguments of type \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{complex} for an
operation that is not found in the table for those types? For example, assume
that we've defined a generic exponentiation operation:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (exp x y) (apply-generic 'exp x y))
\end{minted}

and have put a procedure for exponentiation in the Scheme-number package but not
in any other package:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; following added to Scheme-number package
(put 'exp '(scheme-number scheme-number)
     (lambda (x y) (tag (expt x y))))
     ; using primitive expt
\end{minted}

What happens if we call \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{exp} with two complex numbers as arguments?

\subsubsection{Answer A}
\label{sec:orgdb63326}
I think it will loop infinitely at the first nested \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{apply-generic}
call, seen in the block after \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{t1->t2}.

\subsubsection{Question B}
\label{sec:org32e4f94}
Is Louis correct that something had to be done about coercion with arguments of
the same type, or does \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{apply-generic} work correctly as is?

\subsubsection{Answer B}
\label{sec:org0ef2545}
He is correct. The predicate which determines whether type coercion is attempted is only a check to if the requested procedure exists. This is a problem if, as seen in the last problem, the data types are compatible but the operation does not exist.

\subsubsection{Question C}
\label{sec:org4e0b6b7}
Modify \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{apply-generic} so that it doesn't try coercion if the two
arguments have the same type.

\subsubsection{Answer C}
\label{sec:orga6f55a9}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (if (equal? type1 type2)
                  ;      'failgood ; proving correct operation
                        (error 
                     "No method for this type"
                     (list op type-tags))
                    (let ((t1->t2 
                           (get-coercion type1
                                         type2))
                          (t2->t1 
                           (get-coercion type2 
                                         type1)))
                      (cond (t1->t2
                             (apply-generic 
                              op (t1->t2 a1) a2))
                            (t2->t1
                             (apply-generic 
                              op a1 (t2->t1 a2)))
                            (else
                             (error 
                              "No coercion method for these types"
                              (list 
                               op 
                               type-tags)))))))
              (error 
               "No method for these types"
               (list op type-tags)))))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(put-coercion 'scheme-number 'rational
              (lambda(num)
                (make-rational num 1)))
<<eqnumber>>
(put-coercion 'rational 'complex
              (lambda(num)
                (make-complex-from-real-imag
                 (if (=number? 1 ((get 'denom '(rational)) num)) ; if rat could be integer
                     ((get 'numer '(rational)) num)       ; might as well simplify
                     num) 0)))
(put-coercion 'scheme-number 'complex
              (lambda(num)
                (make-complex-from-real-imag num 0)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<op-table>>
<<type-table>>
<<sqrt>>
<<square>>
<<echo>>
<<smarter-type-tagging>>
<<apply-generic-coerce-fixed>>
<<generic-arithmetic>>
<<scheme-number-package>>
<<equ?>>
<<eqzero?>>
(load "mattcheck2.scm")

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)
(install-equ?)
(install-=zero?)
<<gen-math-tests>>
<<basic-coercions>>

(mattcheck "good coercion test"
           (mul (make-rational 8 1)
                (make-rational 2 3))
           (mul 8 (make-rational 2 3)))
(mattcheck "bad coercion test"
           (apply-generic 'foobar 8 9)
           'failgood)
\end{minted}

\begin{verbatim}
SUCCEED at good coercion test
SUCCEED at bad coercion test
\end{verbatim}

\subsection{Exercise 2.82: \texttt{apply-generic} with multiple coerced arguments}
\label{sec:org070872c}
\subsubsection{Question}
\label{sec:org5ea5098}
Show how to generalize \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{apply-generic} to handle coercion in the
general case of multiple arguments. One strategy is to attempt to coerce all the
arguments to the type of the first argument, then to the type of the second
argument, and so on. Give an example of a situation where this strategy (and
likewise the two-argument version given above) is not sufficiently general.
(Hint: Consider the case where there are some suitable mixed-type operations
present in the table that will not be tried.)

\subsubsection{Answer}
\label{sec:org872cbf5}
These strategies are not sufficient when a path to the correct type will require
multiple coercions. Say you want to coerce arguments of types \(ABCD\). There
are coercions for \(A \rightarrow B\), \(B \rightarrow C\), \(A \rightarrow
D\), \(C \rightarrow A\) but \emph{not} \(C \rightarrow D\). If fed arguments of
types \(ABCD\), \texttt{apply-generic} will first coerce A to B, then B to C, and
then fail to find a coercion from C to D despite a path \(C \rightarrow A
\rightarrow D\) existing.

The other scenario is if there is a different type not included in the original
set which all types could convert to. For example if coercions to \(E\) exist
for all \(ABCD\), this would not be checked for.

Here's an implementation of the first strategy, which is a mess:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
;; Version of apply-generic that look for coercion functions
;; that work for the entire list
(define (apply-generic op . args)
  (define types (map type-tag args))
  (define (coercions-for-list ll target)
    (map (lambda(item) ; find coercion functions, if identical type return id func
           (let ((type (type-tag item)))
             (if (equal? type target)
                 (lambda(x)x)
                 (get-coercion type target))))
         args))
  ;; map-coercions: list of types -> list of tagged numbers.
  ;; find one type which all items can be coerced to,
  ;; then do all coercions and return as list
  (define (map-coercions ll)
    (if (null? ll) ;; exhausted possibilities
        (error
         "No method between all these types"
         (list op types))
        (let ((tries (coercions-for-list ll (car ll))))
          (if (every procedure? tries); if all coercions found, apply them
              (map (lambda(f x) (f x))  
                   tries args)
              (map-coercions (cdr ll)))))) ; else keep trying
  (let ((proc (get op types)))
    (if proc
        (apply proc (map contents args))
        (let ((coerced (map-coercions types)))
          (apply (get op (map type-tag coerced))
                 (map contents coerced))))))
\end{minted}

Testing my code:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<op-table>>
<<type-table>>
<<sqrt>>
<<square>>
<<echo>>
<<smarter-type-tagging>>
<<apply-generic-coerce-varargs-naive>>
<<generic-arithmetic>>
<<scheme-number-package>>
<<equ?>>
<<eqzero?>>
(load "mattcheck2.scm")

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)
(install-equ?)
(install-=zero?)
<<gen-math-tests>>
<<basic-coercions>>

(mattcheck "num -> frac coercion test"
           (mul (make-rational 8 1)
                (make-rational 2 3))
           (mul 8 (make-rational 2 3)))
(mattcheck "num -> complex coercion test"
           (mul (make-complex-from-real-imag 8 0)
                (make-complex-from-real-imag 2 3))
           (mul 8 (make-complex-from-real-imag 2 3)))
\end{minted}

\begin{verbatim}
SUCCEED at num -> frac coercion test
SUCCEED at num -> complex coercion test
\end{verbatim}

The strategy I implemented was ``search the list and find one type which all
others coerce to.'' However, a superior strategy, \href{https://github.com/danielpi/SICP-Exercises/blob/46a6b38fd83faae21db239f40d913ff24062d2e6/Racket/Ex\%202.82\%20Generalized\%20apply-generic.rkt\#L269}{as implemented by danielpi on
GitHub}\footnote{starting on line 269
\url{https://github.com/danielpi/SICP-Exercises/blob/46a6b38fd83faae21db239f40d913ff24062d2e6/Racket/Ex\%202.82\%20Generalized\%20apply-generic.rkt\#L269}}
is to iterate through the list's types, attempting every coercion that works,
and leaving unmodified every number that doesn't have one. In a linear ``tower''
structure, the types will raise as far as is necessary -- assuming the types are
ordered lowest-to-highest.

Here's my attempt at a much simplified version. 

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
;; Version of apply-generic that tries to coerce each variable
;; into each type represebted in args.
(define (apply-generic op . args)
  (define types (map type-tag args))
  ;; map-coercion: type, list of tagged numbers -> list of tagged numbers
  ;; try to coerce all items in list to given type. If this isn't possible,
  ;; leave the item alone. Meant for fold.
  (define (map-coercion type-to-try items)
    (map (lambda(item) ; find and apply coercion functions,
           (let* ((coerce (get-coercion (type-tag item) type-to-try)))
             (cond ((or (not coerce)
                        (equal? (type-tag item) type-to-try))
                    item)
                   (else (coerce item)))))
         items))
  
  (let ((proc (get op types)))
    (if proc ; is this already doable?
        (apply proc (map contents args))
        ; if not, try type coercion
        (let ((coerced (fold map-coercion args types)))
          (apply (get op (map type-tag coerced))
                 (map contents coerced))))))
;; However this won't actually handle multiple arguments
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<op-table>>
<<type-table>>
<<sqrt>>
<<square>>
<<echo>>
<<smarter-type-tagging>>
<<apply-generic-coerce-less-naive>>
<<generic-arithmetic>>
<<scheme-number-package>>
<<equ?>>
<<eqzero?>>
(load "mattcheck2.scm")

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)
(install-equ?)
(install-=zero?)
<<gen-math-tests>>
<<basic-coercions>>

(mattcheck "num -> frac coercion test"
           (mul (make-rational 8 1)
                (make-rational 2 3))
           (mul 8 (make-rational 2 3)))
(mattcheck "num -> complex coercion test"
           (mul (make-complex-from-real-imag 8 0)
                (make-complex-from-real-imag 2 3))
           (mul 8 (make-complex-from-real-imag 2 3)))
(mattcheck "multiple arguments test"
           (false-if-exception (apply-generic 'add 8 (make-rational 2 3)
                                              (make-complex-from-real-imag 2 3))))
\end{minted}

\begin{verbatim}
SUCCEED at num -> frac coercion test
SUCCEED at num -> complex coercion test
FAIL at multiple arguments test
expected: "boolean true"
returned: "boolean false"
\end{verbatim}

\subsubsection{Answer with vararg support}
\label{sec:org32217b9}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
;; Version of apply-generic that tries to coerce each variable
;; into each type represebted in args.
(define (apply-generic op . args)
  (define types (map type-tag args))
  ;; map-coercion: type, list of tagged numbers -> list of tagged numbers
  ;; try to coerce all items in list to given type. If this isn't possible,
  ;; leave the item alone. Meant for fold.
  (define (map-coercion type-to-try items)
    (map (lambda(item) ; find and apply coercion functions,
           (let* ((coerce (get-coercion (type-tag item) type-to-try)))
             (cond ((or (not coerce)
                        (equal? (type-tag item) type-to-try))
                    item)
                   (else (coerce item)))))
         items))
  
  (let ((proc (get op types)))
    (if proc ; is this already doable?
        (apply proc (map contents args))
        ; if not, try type coercion
        (let ((coerced (fold map-coercion args types)))
          (if (< (length args) 3)
              ;; short args
              (apply (get op (map type-tag coerced))
                     (map contents coerced))
              ;; long args
              (reduce (lambda(elem previous)
                        (apply-generic op previous elem))
                      "ERROR" coerced))))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<op-table>>
<<type-table>>
<<sqrt>>
<<square>>
<<echo>>
<<smarter-type-tagging>>
<<apply-generic-coerce-varargs>>
<<generic-arithmetic>>
<<scheme-number-package>>
<<equ?>>
<<eqzero?>>
(load "mattcheck2.scm")

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)
(install-equ?)
(install-=zero?)
<<basic-coercions>>

(mattcheck "multiple arguments test"
           (apply-generic 'add 8 2 3)
           13)
(mattcheck "multiple arguments test 2"
           (apply-generic 'add (make-complex-from-real-imag 3 5)
                          (make-complex-from-real-imag 3 5)
                          (make-complex-from-real-imag 3 5))
           (cons 'complex
                 (cons 'rectangular
                       (cons 9 15))))
(mattcheck "multiple arguments coercion test"
           (false-if-exception
            (apply-generic 'add 8 (make-rational 2 3)
            (make-complex-from-real-imag 2 3))))
\end{minted}

\begin{verbatim}
<unknown-location>: warning: possibly unbound variable `fold'
<unknown-location>: warning: possibly unbound variable `reduce'
<unknown-location>: warning: possibly unbound variable `mattcheck'
SUCCEED at multiple arguments test
SUCCEED at multiple arguments test 2
FAIL at multiple arguments coercion test
expected: "boolean true"
returned: "boolean false"
\end{verbatim}

The second test fails because of the rational being nested within the complex
number type. Taking this any further would involve reworking earlier procedures
(such as \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{add-complex}) and likely writing the future \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{drop}
procedure anyway.

So let's move on.

\subsection{Exercise 2.83: \texttt{raise}}
\label{sec:org1509370}
\subsubsection{Question}
\label{sec:orgf10a524}
Suppose you are designing a generic arithmetic system for dealing with the tower
of types shown in Figure 2.25: integer, rational, real, complex. For each type
(except complex), design a procedure that raises objects of that type one level
in the tower. Show how to install a generic \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{raise} operation that
will work for each type (except complex).

\subsubsection{Answer}
\label{sec:org9a4fab3}
I'm again getting the feeling that the authors are asking for a theoretical
exercise, but one that I'm not satisfied leaving to theory. First we need a
structure to clarify the promotional possibilities of the tower. Then we need
coercions for each type which can be used when following the tower.

Something which I haven't defined before but will now is a \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{'real}
type. A real number is a superset of ints and rationals, but isn't fundamentally
different from these until a non-zero imaginary part is added. So my first
instinct was to make it an untagged type like \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{'scheme-number} that is
detected by \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{type-tag} with the builtin predicate \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{real?}.
However after thinking about it some more I think I'll just implement it in the
type table and have it pass its arguments off to the ``real'' types.

\texttt{Real numbers are a superset of integers, rationals, and **irrational** numbers,
which are not a part of this system yet. Also it turns out this module expected
a "real" number to be a decimal. -Matt}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (=number? x y)
  (and (number? x)
       (number? y)
       (= x y)))
(define (=int? x y)
  (and (number? x)
       (number? y)
       (integer? x)
       (integer? y)
       (= x y)))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define tower
  '(scheme-number rational real complex))

(define (raise x)
  (let ((t1 (type-tag x)))
    (let recurse ((ll tower))
      (let ((t2 (car ll)))
        (cond ((null? (cdr ll)) #f)
              ((equal? t1 t2)
               ((get-coercion t1 (cadr ll)) (contents x)))
              (else (recurse (cdr ll))))))))

(put-coercion 'scheme-number 'rational
              (lambda(num)
                (make-rational num 1)))
<<eqnumber>>
(put-coercion 'rational 'real
              (lambda(num)
                (make-real
                 (exact->inexact (/ ((get 'numer '(rational)) num)
                                    ((get 'denom '(rational)) num))))))
(put-coercion 'real 'complex
              (lambda(num)
                (make-complex-from-real-imag
                 num 0)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (install-real-package)
  ;; interface to rest of the system
  (define (tag x) (attach-tag 'real x))
  (put 'add '(real real)
       (lambda (x y) (tag (add x y))))
  (put 'sub '(real real)
       (lambda (x y) (tag (sub x y))))
  (put 'mul '(real real)
       (lambda (x y) (tag (mul x y))))
  (put 'div '(real real)
       (lambda (x y) (tag (div x y))))
  (put 'make 'real
       (lambda (r) (tag r)))
  'done)

(define (make-real r)
  ((get 'make 'real) r))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
<<op-table>>
<<type-table>>
<<sqrt>>
<<square>>
<<echo>>
<<smarter-type-tagging>>
<<attach-tag-fixed>> ;; time travel due to numer/denom fixes
<<apply-generic-coerce-less-naive>>
<<generic-arithmetic>>
<<scheme-number-package>>
<<real-package>>
<<equ?>>
<<eqzero?>>
<<real-package>>
<<basic-tower-coercions>>

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)
(install-real-package)
(install-equ?)
(install-=zero?)
<<gen-math-tests>>

(let recurse ((x 42))
  (let ((x2 (raise x)))
    (if (eqv? #f x2)
        (echo "Done")
        (begin (echo x2)
               (recurse x2)))))
\end{minted}

\begin{verbatim}
<unknown-location>: warning: possibly unbound variable `fold'
5+5 = 10 
5-5 = 0 
5*5 = 25 
5/5 = 1 
1/2 + 1/2 = (rational 1 . 1) 
1/2 - 1/2 = (rational 0 . 1) 
1/2 * 1/2 = (rational 1 . 4) 
1/2 / 1/2 = (rational 1 . 1) 
3+4i + 3+4i = (complex rectangular 6 . 8) 
3+4i - 3+4i = (complex rectangular 0 . 0) 
3+4i * 3+4i = (complex polar 14.0 . 1.8545904360032244) 
3+4i / 3+4i = (complex polar 1.0 . 0.0) 
3m+4deg + 3m+4deg = (complex rectangular -3.921861725181672 . -4.540814971847569) 
3m+4deg - 3m+4deg = (complex rectangular 0.0 . 0.0) 
3m+4deg * 3m+4deg = (complex polar 9 . 8) 
3m+4deg / 3m+4deg = (complex polar 1 . 0) 
(rational 42 . 1) 
(real . 42.0) 
(complex rectangular (real . 42.0) . 0) 
Done 
\end{verbatim}

\subsection{Exercise 2.84: \texttt{append-generic} with \texttt{raise}}
\label{sec:orgcd753a7}
\subsubsection{Question}
\label{sec:org809f968}
Using the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{raise} operation of Exercise 2.83, modify the
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{apply-generic} procedure so that it coerces its arguments to have the
same type by the method of successive raising, as discussed in this section. You
will need to devise a way to test which of two types is higher in the tower. Do
this in a manner that is ``compatible'' with the rest of the system and will not
lead to problems in adding new levels to the tower.

\subsubsection{Answer}
\label{sec:org0a0aab5}
First some (unnecessarily general) ways to find items in a list.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
;; list, items to find -> list of indices
;; example: (list-indices '(c b a) a b c z)
;;          (2 1 0 #f)
;; takes a list and items to find in the list
;; returns the index of each or #f
(define (list-indices lst . items)
  ;; folder: item, ongoing list of search results
  ;;             -> list of search results
  ;; List of results is a list of #f for unfound items
  ;; and indices for found ones. Take an item to be
  ;; searched for in lst and prior search results. Check
  ;; for each unfound item and if now found, mark index.
  (define (folder x counters)
    (cons (1+ (car counters))
          (let rec ((il items)
                    (cl (cdr counters)))
            (cons (if (and (equal? (car cl) #f)
                           (equal? x (car il)))
                      (car counters)
                      (car cl))
                  (if (null? (cdr il))
                      '()
                      (rec (cdr il) (cdr cl)))))))
  (if (= 1 (length items))
      ;; list-index is good enough
      (cons (list-index (lambda(x)
                          (equal? x (car items)))
                        lst)
            '())
      (cdr (fold folder (cons 0
                              (make-list (length items) #f))    
                 lst))))
(define (max-index lst)
  (define (folder x result)
    (let ((index (car result))
          (max-i (cadr result))
          (max-value (caddr result)))
    (cons (1+ index)
          (if (> x max-value)
              (list (1+ index)
                    x)
              (list max-i
                    max-value)))))

  (cadr (fold folder (list -1 0 0)
               lst)))

;; My first definition for max-index was this under the
;; assumption it would be faster, because the former
;; makes variables for each fold. But they benchmarked
;; identically.
;(define (max-index lst)
;  (define index car)
;  (define max-i cadr)
;  (define max-value caddr)
;  (define (folder x result)
;    (cons (1+ (index result))
;          (if (> x (max-value result))
;              (list (1+ (index result))
;                    x)
;              (list (max-i result)
;                    (max-value result)))))
;
;  (max-i (fold folder (list -1 0 0)
;               lst)))
\end{minted}

The new apply-generic and helper functions.
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; type, type -> bool
;; Return true if type a is the lowest, false otherwise.
(define (is-earlier-in-tower? a b)
  (let ((result (list-indices tower a b)))
    (if (any (lambda(x) (eq? x #f)) result)
        (error "type missing from tower!" result)
        (apply < result))))
;; types -> type
;; Take types to check on tower. Finds the
;; highest-ranked and returns it.
(define (latest-in-tower . args)
  (let* ((types (if (and (= 1 (length args))
                         (list? (car args)))
                    (car args)
                    args))
         (result (apply list-indices
                        tower types)))
    (if (any (lambda(x) (eq? x #f)) result)
        (error "type missing from tower!"
               "args" args "types" types "result" result)
        (list-ref types (max-index result)))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
;; Version of apply-generic that tries raising
;; its arguments.
(define (apply-generic op . args)
  (define types (map type-tag args))
  (define (map-raise highest-type item)
    (if (equal? (type-tag item) highest-type)
        item
        (let ((raised (raise item)))
          (if (not raised)
              (error "map-raise: could not raise:" item highest-type)
              (map-raise highest-type raised)))))
  
  (let ((proc (get op types)))
    (if proc ; is this already doable?
        (apply proc (map contents args))
                                        ; if not, try type coercion
  
        (let* ((highest-type (apply latest-in-tower types))
               (map-raise-prime (lambda(item)(map-raise highest-type item)))
               (raised (map map-raise-prime args)))
          (if (< (length args) 3)
              ;; short args
              (apply (get op (map type-tag raised))
                     (map contents raised))
              ;; long args
              (reduce (lambda(elem previous)
                        (apply-generic op previous elem))
                      "ERROR" raised))))))
\end{minted}

I discovered that the prior method for avoiding tagging scheme-numbers also keeps you from tagging other things. Here's one that avoids the problem:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (attach-tag type-tag contents)
  (if (eqv? type-tag 'scheme-number)
      contents
      (cons type-tag contents)))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<op-table>>
<<type-table>>
<<sqrt>>
<<square>>
<<echo>>
<<smarter-type-tagging>>
<<attach-tag-fixed>>
<<list-indices>>
<<tower-predicates>>
<<apply-generic-raise>>
<<generic-arithmetic>>
<<scheme-number-package>>
<<real-package>>
<<equ?>>
<<eqzero?>>
<<real-package>>
<<basic-tower-coercions>>

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)
(install-real-package)
(install-equ?)
(install-=zero?)
<<gen-math-tests>>

(mattcheck "is-earlier-in-tower? true"
           (is-earlier-in-tower? 'scheme-number 'real))
(mattcheck "is-earlier-in-tower? false"
           #f (is-earlier-in-tower? 'complex 'scheme-number))
(mattcheck "max-index"
           (max-index (list 1 3 5 4 2 0))
           2)
(mattcheck "latest-in-tower"
           (apply latest-in-tower tower)
           'complex)
(mattcheck "latest-in-tower reverse"
           (apply latest-in-tower (reverse tower))
           'complex)
(mattcheck "latest-in-tower 2 args"
           (apply latest-in-tower '(scheme-number real))
           'real)
(mattcheck "latest-in-tower 1 arg"
           (apply latest-in-tower '(real))
           'real)
(mattcheck "raise success"
           (raise 78)
           (make-rational 78 1))
(mattcheck "raise fail"
           (raise (make-complex-from-mag-ang 78 64))
           #f)
(mattcheck "apply-generic 1"
           (add 1 (make-rational 3 5))
           (make-rational 8 5))
(mattcheck "apply-generic 2"
           (add (make-real 2)
                (make-complex-from-mag-ang 3 5))
           (make-complex-from-real-imag 2.850986556389679 -2.8767728239894153))
\end{minted}

\begin{verbatim}
5+5 = 10 
5-5 = 0 
5*5 = 25 
5/5 = 1 
1/2 + 1/2 = (rational 1 . 1) 
1/2 - 1/2 = (rational 0 . 1) 
1/2 * 1/2 = (rational 1 . 4) 
1/2 / 1/2 = (rational 1 . 1) 
3+4i + 3+4i = (complex rectangular 6 . 8) 
3+4i - 3+4i = (complex rectangular 0 . 0) 
3+4i * 3+4i = (complex polar 14.0 . 1.8545904360032244) 
3+4i / 3+4i = (complex polar 1.0 . 0.0) 
3m+4deg + 3m+4deg = (complex rectangular -3.921861725181672 . -4.540814971847569) 
3m+4deg - 3m+4deg = (complex rectangular 0.0 . 0.0) 
3m+4deg * 3m+4deg = (complex polar 9 . 8) 
3m+4deg / 3m+4deg = (complex polar 1 . 0) 
SUCCEED at is-earlier-in-tower? true
SUCCEED at is-earlier-in-tower? false
SUCCEED at max-index
SUCCEED at latest-in-tower
SUCCEED at latest-in-tower reverse
SUCCEED at latest-in-tower 2 args
SUCCEED at latest-in-tower 1 arg
SUCCEED at raise success
SUCCEED at raise fail
SUCCEED at apply-generic 1
SUCCEED at apply-generic 2
\end{verbatim}

In this implementation, In order to add a new type, all that will be needed is
to replace the tower variable (the horrors of \texttt{setq}\ldots{}) and add a coercion to
the respective type.

My first attempt at this exercise had a problem from \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{'real} and above,
where numbers passed to math primitives would fail, because of receiving numbers tagged
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{'real}.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(add (make-real 2)
     (make-complex-from-mag-ang 3 5))
;; eventually reaches...
(add-complex (rectangular (real . 2) . 0)
             (polar 3 . 5))
;; which resulfs in...
\end{minted}

\begin{verbatim}
ice-9/boot-9.scm:1685:16: In procedure raise-exception:
In procedure +: Wrong type argument in position 1: (real . 2)
\end{verbatim}

This issue was caused by not consuming the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{'real} tag when being
coerced to a new type.

My code also had an issue where real numbers raised from rational couldn't be
operated on because they were always nested inside the real number. This is
solved by reducing the fraction to a decimal number, which fixes a few ``bugs'' in
the book's code as well.

\subsection{Exercise 2.85: \texttt{append-generic} with \texttt{drop}}
\label{sec:org91711e7}
\subsubsection{Question}
\label{sec:orga8420f5}
This section mentioned a method for ``simplifying'' a data object by lowering it
in the tower of types as far as possible. Design a procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{drop}
that accomplishes this for the tower described in Exercise 2.83. The key is to
decide, in some general way, whether an object can be lowered. For example, the
complex number \(1.5 + 0i\) can be lowered as far as \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{real}, the
complex number \(1 + 0i\) can be lowered as far as \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{integer}, and the
complex number \(2 + 3i\) cannot be lowered at all. Here is a plan for
determining whether an object can be lowered: Begin by defining a generic
operation \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{project} that ``pushes'' an object down in the tower. For
example, projecting a complex number would involve throwing away the imaginary
part. Then a number can be dropped if, when we \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{project} it and
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{raise} the result back to the type we started with, we end up with
something equal to what we started with. Show how to implement this idea in
detail, by writing a \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{drop} procedure that drops an object as far as
possible. You will need to design the various projection operations\footnote{A real
number can be projected to an integer using the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{round} primitive,
which returns the closest integer to its argument.} and install
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{project} as a generic operation in the system. You will also need to
make use of a generic equality predicate, such as described in Exercise 2.79.
Finally, use \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{drop} to rewrite \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{apply-generic} from Exercise
2.84 so that it ``simplifies'' its answers.

\subsubsection{Answer}
\label{sec:org60744a7}
The question asks to install \texttt{project} as a generic operation in the system, and
I assume that means a \texttt{project} function in the ops table. At first I thought it
would be a function in the same way \texttt{raise} is, with coercions in the coercion
table. However upon consideration, it might be for the purpose of handling the type tags, as I encountered in previous exercises.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (project x)
  (let ((t1 (type-tag x)))
    (let ((p (get 'project t1)))
      (if p
          (p (contents x))
          #f))))

(define (drop x)
  (if (not (pair? x))
      x
      (let ((projected (project x)))
        (cond ((eqv? projected #f)
               x)
              ((equ? x projected)
               (drop projected))
              (else x)))))

(put 'project 'rational
     (lambda(num)
       ((get 'numer '(rational))
        num)))
(put 'project 'real
     (lambda(num)
       (round num)))
(put 'project 'complex
     (lambda(num)
       (make-real
        ((get 'real-part '(complex)) num))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
;; Version of apply-generic that tries to drop its type
;; when returning
(define (apply-generic op . args)
  (define types (map type-tag args))
  (define (map-raise highest-type item)
    (if (equal? (type-tag item) highest-type)
        item
        (let ((raised (raise item)))
          (if (not raised)
              (error "MAP-RAISE: could not raise" item highest-type)
              (map-raise highest-type raised)))))
  
  (drop
   (let ((proc (get op types)))
     (if proc ; is this already doable?
         (apply proc (map contents args))
                                        ; if not, try type coercion
         
         (let* ((highest-type (apply latest-in-tower types))
                (map-raise-prime (lambda(item)(map-raise highest-type item)))
                (raised (map map-raise-prime args)))
           (if (< (length raised) 3)
               ;; short args
               (let ((f (get op (map type-tag raised))))
                 (if (eqv? #f f)
                     (error "APPLY-GENERIC: could not find procedure for types" (map type-tag raised) raised)
                     (apply f (map contents raised))))
               ;; long args
               (reduce (lambda(elem previous)
                         (apply-generic op previous elem))
                       "ERROR" raised)))))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<op-table>>
<<type-table>>
<<sqrt>>
<<square>>
<<echo>>
<<smarter-type-tagging>>
<<attach-tag-fixed>>
<<list-indices>>
<<tower-predicates>>
<<drop-project>>
<<apply-generic-drop>>
<<generic-arithmetic>>
<<scheme-number-package>>
<<real-package>>
<<equ?>>
<<eqzero?>>
<<real-package>>
<<basic-tower-coercions>>

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)
(install-real-package)
(install-equ?)
(install-=zero?)
<<gen-math-tests>>

(mattcheck "raise success"
           (raise 78)
           (make-rational 78 1))
(mattcheck "raise fail"
           (raise (make-complex-from-mag-ang 78 64))
           #f)
(mattcheck "apply-generic 1"
           (add 1 (make-rational 3 5))
           (make-rational 8 5))
(mattcheck "apply-generic 2"
           (add (make-real 2)
                (make-complex-from-mag-ang 3 5))
           (make-complex-from-real-imag 2.850986556389679 -2.8767728239894153))
(mattcheck "drop 1"
           (drop (make-complex-from-real-imag 5 0))
           5)
(mattcheck "drop 2"
           (drop (make-real 5))
           5)
(mattcheck "drop 3"
           (drop (make-rational 5 1))
           5)
\end{minted}

\begin{verbatim}
5+5 = 10 
5-5 = 0 
5*5 = 25 
5/5 = 1 
1/2 + 1/2 = 1 
1/2 - 1/2 = 0 
1/2 * 1/2 = (rational 1 . 4) 
1/2 / 1/2 = 1 
3+4i + 3+4i = (complex rectangular 6 . 8) 
3+4i - 3+4i = 0 
3+4i * 3+4i = (complex polar 14.0 . 1.8545904360032244) 
3+4i / 3+4i = 1.0 
3m+4deg + 3m+4deg = (complex rectangular -3.921861725181672 . -4.540814971847569) 
3m+4deg - 3m+4deg = 0.0 
3m+4deg * 3m+4deg = (complex polar 9 . 8) 
3m+4deg / 3m+4deg = 1 
SUCCEED at raise success
SUCCEED at raise fail
SUCCEED at apply-generic 1
SUCCEED at apply-generic 2
SUCCEED at drop 1
SUCCEED at drop 2
SUCCEED at drop 3
\end{verbatim}

Compare the gen-math-tests output here with that of the \hyperref[sec:org1811e23]{first run in Ex 2.77}.
They are being correctly simplified.

After getting these solutions working, I have to say I'm really reaping what
I've sown. I've been very inconsistent with my tagging and untagging. Some
functions in the type system expected tagged numbers, others expect untagged
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{contents}, which means those functions cannot be used in the same
places. I've had to run over the system and make sure I'm doing it at the right
time.

\subsection{Exercise 2.86: complex numbers with flexible types}
\label{sec:org125e1c3}
\subsubsection{Question}
\label{sec:org8083dc1}
Suppose we want to handle complex numbers whose real parts, imaginary parts,
magnitudes, and angles can be either ordinary numbers, rational numbers, or
other numbers we might wish to add to the system. Describe and implement the
changes to the system needed to accommodate this. You will have to define
operations such as \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{sine} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{cosine} that are generic over
ordinary numbers and rational numbers.

\subsubsection{Answer}
\label{sec:org13e7c0c}
We'll need the internal procedures in the complex package to themselves be calls
to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{apply-generic}, so that calculations with our new data types can
be handled.

In the real and complex parts of the tower, I had assumed that the return of
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{real-part} would always be of tagged type \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{'real}. However,
in this version it may be either real or rational, so I'll want to adjust the
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{project} procedures accordingly.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (real-part z) (apply-generic 'real-part z))
(define (imag-part z) (apply-generic 'imag-part z))
(define (magnitude z) (apply-generic 'magnitude z))
(define (angle z) (apply-generic 'angle z))
;; Now we begin to change code for support
;; These will be named slightly different so the primitive
;; functions aren't shadowed
(define (square x) (mul x 2))
(define (sine x) (apply-generic 'sine x)) ;; (sin)
(define (cosine x) (apply-generic 'cosine x)); (cos)
(define (square-root x) (apply-generic 'square-root x));(sqrt)
(define (arctan x y) (apply-generic 'arctan x y));(atan)

(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'sine '(scheme-number)
       (lambda (x) (tag (sin x))))
  (put 'cosine '(scheme-number)
       (lambda (x) (tag (cos x))))
  (put 'square-root '(scheme-number)
       (lambda (x) (tag (sqrt x))))
  (put 'arctan '(scheme-number scheme-number)
       (lambda (x y) (tag (atan x y))))
  (put 'make 'scheme-number (lambda (x) (tag x)))
  'done)

(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (if (or (inexact? n)
            (inexact? d))
        (cons n d)
        (let ((g (gcd n d)))
          (cons (/ n g) (/ d g)))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  ;; interface to rest of the system
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'numer '(rational) numer)
  (put 'denom '(rational) denom)
  (put 'sine '(rational)
       (lambda(r) ((get 'sine '(scheme-number))
                   (/ (numer r) (denom r)))))
  (put 'cosine '(rational)
       (lambda(r) ((get 'cosine '(scheme-number))
                   (/ (numer r) (denom r)))))
  (put 'square-root '(rational)
       (lambda(r) ((get 'square-root '(scheme-number))
                   (/ (numer r) (denom r)))))
  (put 'arctan '(rational)
       (lambda(r s) ((get 'arctan '(scheme-number))
                     (/ (numer r) (denom r)) (/ (numer s) (denom s)))))
  'done)

;; for future use
(define (numer r)
  ((get 'numer '(rational))
   (contents r)))
(define (denom r)
  ((get 'denom '(rational))
   (contents r)))

(define (make-rational n d)
  ((get 'make 'rational) n d))

(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (square-root (add (square (real-part z))
                      (square (imag-part z)))))
  (define (angle z)
    (arctan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (mul r (cosine a)) (mul r (sine a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z) (mul (magnitude z) (cosine (angle z))))
  (define (imag-part z) (mul (magnitude z) (sine (angle z))))
  (define (make-from-real-imag x y)
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-complex-package)
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  ;; let's make these generic
  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (sub (real-part z1) (real-part z2))
                         (sub (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
                       (add (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (div (magnitude z1) (magnitude z2))
                       (sub (angle z1) (angle z2))))
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))
  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle))

(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(define (project x)
  (let ((t1 (type-tag x)))
    (let ((p (get 'project t1)))
      (if p
          (p (contents x))
          #f))))

(define (drop x)
  (if (not (pair? x))
      x
      (let ((projected (project x)))
        (cond ((eqv? projected #f)
               x)
              ((equ? x projected)
               (drop projected))
              (else x)))))

(put 'project 'rational
     (lambda(num)
       ((get 'numer '(rational))
        num)))
(put 'project 'real
     (lambda(num)
       (round num)))
;; projecting a complex number may return something other than a single number
(put 'project 'complex
     (lambda(num)
       (let ((r ((get 'real-part '(complex)) num)))
         (if (number? (contents r))
             (make-real (contents r))
             r))))

;; equality testing with complex numbers also changes
(define (equ? x y) (apply-generic 'equ? x y))
(define (install-equ?)
  (put 'equ? '(scheme-number scheme-number)
       (lambda(x y) (= x y)))
  (put 'equ? '(complex complex)
       (lambda(x y)
         (let ((t1 (type-tag x))
               (t2 (type-tag y)))
           (cond ((and (eqv? t1 'polar)
                       (eqv? t2 'polar))
                  (and (equ? (apply-generic 'magnitude x)
                             (apply-generic 'magnitude y))
                       (equ? (apply-generic 'angle x)
                             (apply-generic 'angle y))))
                 (else
                  (and (equ? (apply-generic 'real-part x)
                             (apply-generic 'real-part y))
                       (equ? (apply-generic 'imag-part x)
                             (apply-generic 'imag-part y))))))))
  (put 'equ? '(rational rational)
       (lambda(x y)
         (and (= ((get 'numer '(rational)) x)
                 ((get 'numer '(rational)) y))
              (= ((get 'denom '(rational)) x)
                 ((get 'denom '(rational)) y)))))
  (put 'equ? '(real real)
       (lambda(x y) (= x y))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<op-table>>
<<type-table>>
<<sqrt>>
<<echo>>
<<smarter-type-tagging>>
<<attach-tag-fixed>>
<<list-indices>>
<<tower-predicates>>
<<apply-generic-drop>>
<<generic-arithmetic-complex-parts>>
<<real-package>>
<<eqzero?>>
<<real-package>>
<<basic-tower-coercions>>

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)
(install-real-package)
(install-equ?)
(install-=zero?)
<<gen-math-tests>>

(mattcheck "raise success"
           (raise 78)
           (make-rational 78 1))
(mattcheck "raise fail"
           (raise (make-complex-from-mag-ang 78 64))
           #f)
(mattcheck "apply-generic 1"
           (add 1 (make-rational 3 5))
           (make-rational 8 5))
(mattcheck "apply-generic 2"
           (add (make-real 2)
                (make-complex-from-mag-ang 3 5))
           (make-complex-from-real-imag 2.850986556389679 -2.8767728239894153))
(mattcheck "drop 1"
           (drop (make-complex-from-real-imag 5 0))
           5)
(mattcheck "drop 2"
           (drop (make-real 5))
           5)
(mattcheck "drop 3"
           (drop (make-rational 5 1))
           5)
(mattcheck "complex with nested rational"
           (make-complex-from-real-imag 2 (make-rational 3 5))
           (cons 'complex (cons 'rectangular (cons 2 (cons 'rational (cons 3 5))))))
(mattcheck "math on complex with nested rational"
           (add (make-complex-from-real-imag 2 (make-rational 3 5))
                (make-complex-from-mag-ang (make-rational 3 5) 2))
           (cons 'complex (cons 'rectangular
                 (cons (cons 'rational (cons 8.751559490358574 5))
                       (cons 'rational (cons 28.639461402385223 25))))))
\end{minted}

\begin{verbatim}
(etc)
SUCCEED at complex with nested rational
SUCCEED at math on complex with nested rational
\end{verbatim}

\subsection{2.5: Symbolic Algebra}
\label{sec:org2b78294}
In this section, we implement an addition to the generic math system we have
been building by adding support for polynomials (with only addition and
multiplication involved) to start.

I'm going to split the polynomial package into two blocks so I can insert code
inside without needing to copy the whole block again.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (install-polynomial-package)
  ;; internal procedures
  ;; representation of poly
  (define (make-poly variable term-list) (cons variable term-list))
  (define (variable p) (car p))
  (define (terms p) (cdr p)) ;; renamed from term-list since many procs happen
  (define (variable? x) (symbol? x))  ; to use "term-list" as an internal variable
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  ;; representation of terms and term lists
  (define (adjoin-term term term-list)
    (if (=zero? (coeff term))
        term-list
        (cons term term-list)))
  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))
  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))
  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (terms p1) (terms p2)))
        (error "Polys not in same var: ADD-POLY" (list p1 p2))))
  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (terms p1) (terms p2)))
        (error "Polys not in same var: MUL-POLY" (list p1 p2))))
  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term
                     t1 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2))
                    (adjoin-term
                     t2 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term
                     (make-term (order t1)
                                (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
  ;; interface to rest of the system
  (define (tag p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'make 'polynomial
       (lambda (var terms) (tag (make-poly var terms))))
  
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2))
                      (mul (coeff t1) (coeff t2)))
           (mul-term-by-all-terms t1 (rest-terms L))))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
  'done)

(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
\end{minted}

\subsection{Exercise 2.87: \texttt{=zero?} for polynomials}
\label{sec:org7336b5d}
\subsubsection{Question}
\label{sec:org15c9b5c}
Install \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{=zero?} for polynomials in the generic arithmetic package.
This will allow \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{adjoin-term} to work for polynomials with
coefficients that are themselves polynomials.

\subsubsection{Answer}
\label{sec:org9a393f0}
After testing, I see a problem. \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{add}ing nested polynomials works
fine. However, when a coefficient is a polynomial,
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{mul-term-by-all-terms} will call \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{mul} with the types
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{'(polynomial scheme-number)}. If I added polynomials to the type
tower and used \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{raise} to make it into a \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{'(polynomial polynomial)} call, I then need to specify a matching variable for the raised
number, which is not available in \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{raise}. It seems like I'll need to
modify the \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{mul-term-by-all-terms} procedure to detect when one item
is a polynomial and the other isn't, and turn the non-polynomial entry into a
polynomial before calling \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{mul}.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (if-1st-poly-make-2nd-poly t1 t2)
  (if (and (eqv? 'polynomial (type-tag t1))
           (not (eqv? 'polynomial (type-tag t2))))
      (tag (make-poly (variable (contents t1)) (list (make-term 0 t2))))
      t2))
(define (mul-term-by-all-terms t1 L)
  (if (empty-termlist? L)
      (the-empty-termlist)
      (let* ((t2 (first-term L)) ;; If one coeff is a poly, make the other a poly
             (t1-coeff (if-1st-poly-make-2nd-poly (coeff t2) (coeff t1)))
             (t2-coeff (if-1st-poly-make-2nd-poly (coeff t1) (coeff t2))))
        
        (adjoin-term
         (make-term (+ (order t1) (order t2))
                    (mul t1-coeff t2-coeff))
         (mul-term-by-all-terms t1 (rest-terms L))))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
  (define (terms-=zero? L)
    (or (empty-termlist? L)
        (and (=zero? (coeff (first-term L)))
             (terms-=zero? (rest-terms L)))))
  (define (poly-=zero? p)
    (terms-=zero? (terms p)))
  (put '=zero? '(polynomial) poly-=zero?)
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<op-table>>
<<type-table>>
<<sqrt>>
<<echo>>
<<smarter-type-tagging>>
<<attach-tag-fixed>>
<<list-indices>>
<<tower-predicates>>
<<apply-generic-drop>>
<<generic-arithmetic-complex-parts>>
<<real-package>>
<<eqzero?>>
<<real-package>>
<<basic-tower-coercions>>

<<polynomials-package-top>>
<<mul-term-by-all-terms-mine>>
<<poly-terms-eqzero>>
<<polynomials-package-bottom>>

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)
(install-real-package)
(install-equ?)
(install-=zero?)
(install-polynomial-package)
<<gen-math-tests>>

(mattcheck "raise success"
           (raise 78)
           (make-rational 78 1))
(mattcheck "raise fail"
           (raise (make-complex-from-mag-ang 78 64))
           #f)
(mattcheck "apply-generic 1"
           (add 1 (make-rational 3 5))
           (make-rational 8 5))
(mattcheck "apply-generic 2"
           (add (make-real 2)
                (make-complex-from-mag-ang 3 5))
           (make-complex-from-real-imag 2.850986556389679 -2.8767728239894153))
(mattcheck "drop 1"
           (drop (make-complex-from-real-imag 5 0))
           5)
(mattcheck "drop 2"
           (drop (make-real 5))
           5)
(mattcheck "drop 3"
           (drop (make-rational 5 1))
           5)
(mattcheck "complex with nested rational"
           (make-complex-from-real-imag 2 (make-rational 3 5))
           (cons 'complex (cons 'rectangular (cons 2 (cons 'rational (cons 3 5))))))
(mattcheck "math on complex with nested rational"
           (add (make-complex-from-real-imag 2 (make-rational 3 5))
                (make-complex-from-mag-ang (make-rational 3 5) 2))
           (cons 'complex (cons 'rectangular
                                (cons (cons 'rational (cons 8.751559490358574 5))
                                      (cons 'rational (cons 28.639461402385223 25))))))
(mattcheck "polynomial = zero"
           (=zero? (make-polynomial 'x '((0 0) (0 0)))))
(mattcheck "polynomial != zero" #f
           (=zero? (make-polynomial 'x '((0 0) (1 1)))))
(let ((p1 '((100 1)(2 2)(0 1)))
      (p2 (list (list 7 (make-polynomial 'x '((3 2)))))))
  (mattcheck "polynomial addition"
             (add (make-polynomial 'x p1)
                  (make-polynomial 'x p1))
             '(polynomial x (100 2)(2 4)(0 2)))
  (mattcheck "polynomial multiplication"
             (mul (make-polynomial 'x p1)
                  (make-polynomial 'x p1))
             '(polynomial x (200 1) (102 4) (100 2) (4 4) (2 4) (0 1)))
  (mattcheck "nested polynomial addition"
             (add (make-polynomial 'x p2)
                  (make-polynomial 'x p1))
             '(polynomial x (100 1) (7 (polynomial x (3 2))) (2 2) (0 1)))
  (mattcheck "nested polynomial mult"
             (mul (make-polynomial 'x p2)
                  (make-polynomial 'x p1))
             '(polynomial x (107 (polynomial x (3 2))) (9 (polynomial x (3 4))) (7 (polynomial x (3 2))))))
\end{minted}

\begin{verbatim}
(etc...)
SUCCEED at polynomial = zero
SUCCEED at polynomial != zero
SUCCEED at polynomial addition
SUCCEED at polynomial multiplication
SUCCEED at nested polynomial addition
SUCCEED at nested polynomial mult
\end{verbatim}

\subsection{Exercise 2.88: negation, subtracting polynomials}
\label{sec:org0ce33ff}
\subsubsection{Question}
\label{sec:orgff0b681}
Extend the polynomial system to include subtraction of polynomials. (Hint: You
may find it helpful to define a generic negation operation.)

\subsubsection{Answer}
\label{sec:org02f067e}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (neg x)
  (apply-generic 'neg x))
(define (install-negation)
  (put 'neg '(scheme-number)
       (lambda(x) (- x)))
  (put 'neg '(rational)
       (lambda(R) (make-rational (neg ((get 'numer '(rational)) R))
                                 ((get 'denom '(rational)) R))))
  (put 'neg '(real) (get 'neg '(scheme-number)))
  (put 'neg '(rectangular)
       (lambda (C)
         (make-complex-from-real-imag (neg ((get 'real-part '(rectangular)) C))
                                      (neg ((get 'imag-part '(rectangular)) C)))))
  (put 'neg '(polar)
       (lambda (C)
         (make-complex-from-mag-ang (neg ((get 'magnitude '(polar)) C))
                                    ((get 'angle '(polar)) C))))
  (put 'neg '(complex)
       (lambda(C) (apply-generic 'neg C))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
    ;; inserted in install routine
    (define (neg-poly p)
    (make-poly (variable p)
                (map (lambda(t)
                        (make-term (order t) (neg (coeff t))))
                    (terms p))))
    (put 'neg '(polynomial)
        (lambda (p1) (tag (neg-poly p1))))
    (define (sub-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (add-poly p1 (neg-poly p2))
        (error "Polys not in same var: SUB-POLY" (list p1 p2))))
    (put 'sub '(polynomial polynomial)
        (lambda (p1 p2) (tag (sub-poly p1 p2))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<op-table>>
<<type-table>>
<<sqrt>>
<<echo>>
<<smarter-type-tagging>>
<<attach-tag-fixed>>
<<list-indices>>
<<tower-predicates>>
<<apply-generic-drop>>
<<generic-arithmetic-complex-parts>>
<<real-package>>
<<eqzero?>>
<<real-package>>
<<basic-tower-coercions>>

<<polynomials-package-top>>
<<mul-term-by-all-terms-mine>>
<<poly-terms-eqzero>>
<<polynomial-subtraction>>
<<polynomials-package-bottom>>

<<generic-negation>>

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)
(install-real-package)
(install-equ?)
(install-=zero?)
(install-polynomial-package)
(install-negation)

<<gen-math-tests>>

(mattcheck "raise success"
           (raise 78)
           (make-rational 78 1))
(mattcheck "raise fail"
           (raise (make-complex-from-mag-ang 78 64))
           #f)
(mattcheck "apply-generic 1"
           (add 1 (make-rational 3 5))
           (make-rational 8 5))
(mattcheck "apply-generic 2"
           (add (make-real 2)
                (make-complex-from-mag-ang 3 5))
           (make-complex-from-real-imag 2.850986556389679 -2.8767728239894153))
(mattcheck "drop 1"
           (drop (make-complex-from-real-imag 5 0))
           5)
(mattcheck "drop 2"
           (drop (make-real 5))
           5)
(mattcheck "drop 3"
           (drop (make-rational 5 1))
           5)
(mattcheck "complex with nested rational"
           (make-complex-from-real-imag 2 (make-rational 3 5))
           (cons 'complex (cons 'rectangular (cons 2 (cons 'rational (cons 3 5))))))
(mattcheck "math on complex with nested rational"
           (add (make-complex-from-real-imag 2 (make-rational 3 5))
                (make-complex-from-mag-ang (make-rational 3 5) 2))
           (cons 'complex (cons 'rectangular
                                (cons (cons 'rational (cons 8.751559490358574 5))
                                      (cons 'rational (cons 28.639461402385223 25))))))
(mattcheck "polynomial = zero"
           (=zero? (make-polynomial 'x '((0 0) (0 0)))))
(mattcheck "polynomial != zero" #f
           (=zero? (make-polynomial 'x '((0 0) (1 1)))))
(let ((p1 '((100 1)(2 2)(0 1)))
      (p2 (list (list 7 (make-polynomial 'x '((3 2)))))))
  (mattcheck "polynomial addition"
             (add (make-polynomial 'x p1)
                  (make-polynomial 'x p1))
             '(polynomial x (100 2)(2 4)(0 2)))
  (mattcheck "polynomial multiplication"
             (mul (make-polynomial 'x p1)
                  (make-polynomial 'x p1))
             '(polynomial x (200 1) (102 4) (100 2) (4 4) (2 4) (0 1)))
  (mattcheck "nested polynomial addition"
             (add (make-polynomial 'x p2)
                  (make-polynomial 'x p1))
             '(polynomial x (100 1) (7 (polynomial x (3 2))) (2 2) (0 1)))
  (mattcheck "nested polynomial mult"
             (mul (make-polynomial 'x p2)
                  (make-polynomial 'x p1))
             '(polynomial x (107 (polynomial x (3 2))) (9 (polynomial x (3 4))) (7 (polynomial x (3 2))))))
(mattcheck "negation scheme-number"
           (neg 5) -5)
(mattcheck "negation rational"
           (neg (make-rational 1 5))
           (make-rational -1 5))
(mattcheck "negation rectangular complex"
           (neg (make-complex-from-real-imag 3 7))
           (make-complex-from-real-imag -3 -7))
(mattcheck "negation polar complex"
           (neg (make-complex-from-mag-ang 3 7))
           (make-complex-from-mag-ang -3 7))

(let ((p1 '((100 1)(2 2)(0 1)))
      (p2 (list (list 7 (make-polynomial 'x '((3 2))))))
      (p3 '((100 1)(2 1)(0 3)))
      (p4 '((100 -1)(2 -2)(0 -1))))
  (mattcheck "negation polynomials"
             (neg (make-polynomial 'x p1))
             (make-polynomial 'x p4))
  (mattcheck "polynomial subtraction"
             (sub (make-polynomial 'x p1)
                  (make-polynomial 'x p3))
             '(polynomial x (2 1) (0 -2))))
\end{minted}

\begin{verbatim}
(etc...)
SUCCEED at negation scheme-number
SUCCEED at negation rational
SUCCEED at negation rectangular complex
SUCCEED at negation polar complex
SUCCEED at negation polynomials
SUCCEED at polynomial subtraction
\end{verbatim}

\subsection{Exercise 2.89: an abstraction for dense polynomials}
\label{sec:org05ee2d4}
\subsubsection{Question}
\label{sec:org398d35c}
Define procedures that implement the term-list representation described above as
appropriate for dense polynomials.

\subsubsection{Answer}
\label{sec:org80568fb}
At first I thought I needed to rewrite the \texttt{order} and \texttt{coeff} procedures. Then
I realized these are only called with one term, and thus don't have the term
list available, which means the order can't be learned. It's much simpler to
make a new \texttt{first-term} selector that gets the needed info and always returns
the sparse term format, so long as \texttt{adjoin-set} is modified so it will convert
back when adding to a sparse term list.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (sparse-termlist? term-list)
  (let ((t (car term-list)))
    (cond ((and (list? t)
                (number? (first t))
                (number? (second t))) #t)
          ((number? t) #f)
          (else (error "badly formed term: SPARSE-TERMLIST?" t term-list)))))
(define (make-sparse-term order coeff)
  (list order coeff))
(define (dense-first-term term-list)
  (make-term (car term-list)
             (1- (length term-list))))
(define (sparse-first-term term-list)
  (car term-list))
(define (first-term term-list)
  (if (sparse-termlist? term-list)
      (sparse-first-term term-list)
      (dense-first-term term-list)))
\end{minted}

\subsection{Exercise 2.90: dense polynomials integrated into the system}
\label{sec:orgaa0bbc1}
\subsubsection{Question}
\label{sec:orgfd18d52}
Suppose we want to have a polynomial system that is efficient for both sparse
and dense polynomials. One way to do this is to allow both kinds of term-list
representations in our system. The situation is analogous to the complex-number
example of \hyperref[sec:org22950c1]{2.4: Multiple Representations for Abstract Data}, where we allowed
both rectangular and polar representations. To do this we must distinguish
different types of term lists and make the operations on term lists generic.
Redesign the polynomial system to implement this generalization. This is a major
effort, not a local change.

\subsubsection{Answer}
\label{sec:orgc58cd0e}
Although I was debating using tags to distinguish the two types, it occurs to me
they can be told apart just by checking the contents. A valid coefficient is
either a number or a list for a nested type. If the first item of the list is a
list whose \texttt{car} is a number and whose \texttt{cadr} is a number or list, assume it's
sparse. On the other hand, if the first item is a number, or list that doesn't
match that previous description, assume it's dense. This format would \emph{not} be
adequate if we had any potential nested types that happened to look similar, and
especially not if the term-lists were meant for external use.

The new implementations are abstracted such that average procedures using
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{first-term}, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{rest-term} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{adjoin-term} are
totally unaffected.

Whenever a procedure requests a \texttt{first-term}, a sparse representation is
returned (pair of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{(order coeff)}). Then, when \texttt{adjoin-term} is run,
the list is appended-to appropriately whether it is sparse or dense. When
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{make-poly} is run, the statistics of the term list are measured to
decide which implementation should be used. If there are more zero-terms than
\(\frac{1}{2}\) of the highest order in the term, the sparse implementation is
used.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
(define (install-polynomial-package)
  ;; internal procedures
  ;; representation of poly
  (define (make-poly variable term-list)
    (cons variable
          (if (empty-termlist? term-list)
              term-list
              (cond ((and (sparse-termlist? term-list)
                          (not (should-be-sparse? term-list)))
                     (sparse-to-dense term-list))
                    ((and (not (sparse-termlist? term-list))
                          (should-be-sparse? term-list))
                     (dense-to-sparse term-list))
                    (else term-list)))))
  (define (variable p) (car p))
  (define (terms p) (cdr p))
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  
  ;; representation of terms and term lists
  (define (sparse-termlist? term-list)
    (let ((t (car term-list)))
      (cond ((and (list? t) ;; looks like a sparse list
                  (number? (first t))
                  (or (list? (second t)) ;; or sparse with nested poly
                      (number? (second t)))) #t)
            ((or (number? t) ;; looks dense
                 (list? t)) #f) ;; or dense with a nested poly
            (else (error "badly formed term: SPARSE-TERMLIST?" t term-list)))))
  (define (should-be-sparse? term-list)
    ;; sparse or dense term-list -> bool
    ;; if more than half of term-list is zeroes, return true
    ;; reasoning:
    ;; - number of elements used for sparse list is (non-zero elements * 2)
    ;; - number of elements used for dense list is (highest order)
    (define (count-zeroes term-list)
      ;; term-list -> (highest order, zeroes)
      (let iter ((length 0)
                 (zeroes 0)
                 (TL (if (sparse-termlist? term-list)
                         (sparse-to-dense term-list)
                         term-list)))
        (if (empty-termlist? TL)
            (list zeroes length)
            (iter (1+ length)
                  (if (=zero? (car TL))
                      (1+ zeroes)
                      zeroes)
                  (cdr TL)))))
    (let ((stats (if (sparse-termlist? term-list) ;; do appropriate measurement
                     (list (- (1+ (order (sparse-first-term term-list)))
                              (length term-list))
                           (1+ (order (sparse-first-term term-list))))
                     (count-zeroes term-list))))
      (let ((zero-elements (first stats))
            (highest-order (second stats)))
        (> (/ zero-elements highest-order)
           (/ 1 2)))))
  (define (sparse-to-dense term-list)
    (let iter ((old-list (reverse term-list))
               (new-list (the-empty-termlist)))
      (if (empty-termlist? old-list)
          new-list
          (iter (rest-terms old-list)
                (adjoin-term-dense (sparse-first-term old-list)
                                   new-list)))))
  (define (dense-to-sparse term-list)
    (let iter ((old-list (reverse term-list))
               (old-order 0)
               (new-list (the-empty-termlist)))
      (if (empty-termlist? old-list)
          new-list
          (iter (rest-terms old-list)
                (1+ old-order)
                (adjoin-term-sparse (make-sparse-term old-order
                                                      (coeff (dense-first-term old-list)))
                                    new-list)))))
  (define (make-sparse-term order coeff)
    (list order coeff))
  (define (dense-termlist-order term-list)
    (1- (length term-list)))
  (define (dense-first-term term-list)
    (make-sparse-term (dense-termlist-order term-list)
                      (car term-list)))
  (define (sparse-first-term term-list)
    (car term-list))
  (define (first-term term-list)
    (if (sparse-termlist? term-list)
        (sparse-first-term term-list)
        (dense-first-term term-list)))
  (define (adjoin-term-sparse term term-list)
    (cons term term-list))
  (define (adjoin-term-dense term term-list)
    ;; if term is exactly 1 order above top of list, adjoin
    ;; if term is more than 1 order above, adjoin 0 and recurse
    (let ((top-order (dense-termlist-order term-list)))
      (cond ((= (1+ top-order) (order term))
             (cons (coeff term) term-list))
            ((<= top-order (order term))
             (adjoin-term-dense term (cons 0 term-list)))
            (else (error "term is lower order than top of list: ADJOIN-TERM-DENSE" term term-list top-order)))))

  ;; ;; I wrote the versions below which can insert into the middle of the list,
  ;; ;; before remembering that a footnote in the text excuses this.
  ;;
  ;; (define (adjoin-term-sparse term term-list)
  ;;   ;; if term is higher order, cons to list
  ;;   ;; if term is lower order than top of list, try to insert in the middle
  ;;   (let ((top-order (order (sparse-first-term term-list))))
  ;;     (cond ((<= (1+ top-order) (order term))
  ;;            (cons term term-list))
  ;;           (else (adjoin-term-sparse (sparse-first-term term-list)
  ;;                                     (adjoin-term-sparse term
  ;;                                                         (rest-terms term-list)))))))
  ;; (define (adjoin-term-dense term term-list)
  ;;   ;; if term is 1 order above top of list, adjoin
  ;;   ;; if term is more than 1 order above, adjoin 0 and recurse
  ;;   ;; if term is lower order than top of list, try to insert in the middle
  ;;   (let ((top-order (dense-termlist-order term-list)))
  ;;     (cond ((= (1+ top-order) (order term))
  ;;            (cons (coeff term) term-list))
  ;;           ((<= top-order (order term))
  ;;            (adjoin-term-dense term (cons 0 term-list)))
  ;;           (else (adjoin-term-dense (dense-first-term term-list)
  ;;                                    (adjoin-term-dense term
  ;;                                                       (rest-terms term-list)))))))

  (define (adjoin-term term term-list)
    (if (=zero? (coeff term))
        term-list
        (if (or (empty-termlist? term-list)
                (sparse-termlist? term-list))
            (adjoin-term-sparse term term-list)
            (adjoin-term-dense term term-list))))
  (define (the-empty-termlist) '())
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))
  (define (order term) (first term))
  (define (coeff term) (second term))
  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (terms p1) (terms p2)))
        (error "Polys not in same var: ADD-POLY" (list p1 p2))))
  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (terms p1) (terms p2)))
        (error "Polys not in same var: MUL-POLY" (list p1 p2))))
  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term
                     t1 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2))
                    (adjoin-term
                     t2 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term
                     (make-sparse-term (order t1)
                                       (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
  
  ;; interface to rest of the system
  (define (tag p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'make 'polynomial
       (lambda (var terms) (tag (make-poly var terms))))
  (define (if-1st-poly-make-2nd-poly t1 t2)
    (if (and (eqv? 'polynomial (type-tag t1))
             (not (eqv? 'polynomial (type-tag t2))))
        (tag (make-poly (variable (contents t1)) (list t2)))
        t2))
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let* ((t2 (first-term L)) ;; If one coeff is a poly, make the other a poly
               (t1-coeff (if-1st-poly-make-2nd-poly (coeff t2) (coeff t1)))
               (t2-coeff (if-1st-poly-make-2nd-poly (coeff t1) (coeff t2))))
          
          (adjoin-term
           (make-sparse-term (+ (order t1) (order t2))
                             (mul t1-coeff t2-coeff))
           (mul-term-by-all-terms t1 (rest-terms L))))))
  (define (terms-=zero? L)
    (or (empty-termlist? L)
        (and (=zero? (coeff (first-term L)))
             (terms-=zero? (rest-terms L)))))
  (define (poly-=zero? p)
    (terms-=zero? (terms p)))
  (put '=zero? '(polynomial) poly-=zero?)
  (define (neg-terms TL)
    (let ((negterm (if (sparse-termlist? TL)
                       (lambda(t)
                         (make-sparse-term (order t) (neg (coeff t))))
                       (lambda(t)
                         (neg (coeff t))))))
      (map negterm TL)))
  (define (sub-terms T1 T2)
    (add-terms T1 (neg-terms T2)))
  (define (neg-poly p)
    (make-poly (variable p)
               (neg-terms (terms p))))
  (put 'neg '(polynomial)
       (lambda (p1) (tag (neg-poly p1))))
  (define (sub-poly p1 p2)
    (add-poly p1 (neg-poly p2)))
  (put 'sub '(polynomial polynomial)
       (lambda (p1 p2) (tag (sub-poly p1 p2))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
  'done)
(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<op-table>>
<<type-table>>
<<sqrt>>
<<echo>>
<<smarter-type-tagging>>
<<attach-tag-fixed>>
<<list-indices>>
<<tower-predicates>>
<<apply-generic-drop>>
<<generic-arithmetic-complex-parts>>
<<real-package>>
<<eqzero?>>
<<real-package>>
<<basic-tower-coercions>>

<<polynomial-sparse-dense-top>>
<<polynomial-sparse-dense-bottom>>

<<generic-negation>>

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)
(install-real-package)
(install-equ?)
(install-=zero?)
(install-polynomial-package)
(install-negation)

<<gen-math-tests>>

(mattcheck "raise success"
           (raise 78)
           (make-rational 78 1))
(mattcheck "raise fail"
           (raise (make-complex-from-mag-ang 78 64))
           #f)
(mattcheck "apply-generic 1"
           (add 1 (make-rational 3 5))
           (make-rational 8 5))
(mattcheck "apply-generic 2"
           (add (make-real 2)
                (make-complex-from-mag-ang 3 5))
           (make-complex-from-real-imag 2.850986556389679 -2.8767728239894153))
(mattcheck "drop 1"
           (drop (make-complex-from-real-imag 5 0))
           5)
(mattcheck "drop 2"
           (drop (make-real 5))
           5)
(mattcheck "drop 3"
           (drop (make-rational 5 1))
           5)
(mattcheck "complex with nested rational"
           (make-complex-from-real-imag 2 (make-rational 3 5))
           (cons 'complex (cons 'rectangular (cons 2 (cons 'rational (cons 3 5))))))
(mattcheck "math on complex with nested rational"
           (add (make-complex-from-real-imag 2 (make-rational 3 5))
                (make-complex-from-mag-ang (make-rational 3 5) 2))
           (cons 'complex (cons 'rectangular
                                (cons (cons 'rational (cons 8.751559490358574 5))
                                      (cons 'rational (cons 28.639461402385223 25))))))
(mattcheck "polynomial = zero"
           (=zero? (make-polynomial 'x '((0 0)))))
(mattcheck "polynomial != zero" #f
           (=zero? (make-polynomial 'x '((1 1) (0 1)))))

(let ((p1 '((100 1)(2 2)(0 1)))
      (p2 (list (list 7 (make-polynomial 'x '((3 2))))))
      (p3 '((100 1)(2 1)(0 3)))
      (p4 '((100 -1)(2 -2)(0 -1)))
      (p5 '(8 2 5 -3 -7)))
  (mattcheck "polynomial addition"
             (add (make-polynomial 'x p1)
                  (make-polynomial 'x p1))
             '(polynomial x (100 2)(2 4)(0 2)))
  (mattcheck "polynomial multiplication"
             (mul (make-polynomial 'x p1)
                  (make-polynomial 'x p1))
             '(polynomial x (200 1) (102 4) (100 2) (4 4) (2 4) (0 1)))
  (mattcheck "nested polynomial addition"
             (add (make-polynomial 'x p2)
                  (make-polynomial 'x p1))
             '(polynomial x (100 1) (7 (polynomial x (3 2))) (2 2) (0 1)))
  (mattcheck "nested polynomial mult"
             (mul (make-polynomial 'x p2)
                  (make-polynomial 'x p1))
             '(polynomial x (107 (polynomial x (3 2))) (9 (polynomial x (3 4))) (7 (polynomial x (3 2)))))
  (mattcheck "negation scheme-number"
             (neg 5) -5)
  (mattcheck "negation rational"
             (neg (make-rational 1 5))
             (make-rational -1 5))
  (mattcheck "negation rectangular complex"
             (neg (make-complex-from-real-imag 3 7))
             (make-complex-from-real-imag -3 -7))
  (mattcheck "negation polar complex"
             (neg (make-complex-from-mag-ang 3 7))
             (make-complex-from-mag-ang -3 7))

  (mattcheck "negation polynomials"
             (neg (make-polynomial 'x p1))
             (make-polynomial 'x p4))
  (mattcheck "polynomial subtraction"
             (sub (make-polynomial 'x p1)
                  (make-polynomial 'x p3))
             '(polynomial x 1 0 -2)))
\end{minted}

\begin{verbatim}
(etc...)
SUCCEED at negation polynomials
SUCCEED at polynomial subtraction
\end{verbatim}

\subsection{Exercise 2.91: division of polynomials}
\label{sec:org00c212c}
\subsubsection{Question}
\label{sec:orgbae0113}
A univariate polynomial can be divided by another one to produce a polynomial
quotient and a polynomial remainder. For example,

\(\frac{x^5 - 1}{x^2 - 1} = x^3 + x, \hbox{  remainder  } x - 1\)

Division can be performed via long division.  That is, divide the highest-order
term of the dividend by the highest-order term of the divisor.  The result is
the first term of the quotient.  Next, multiply the result by the divisor,
subtract that from the dividend, and produce the rest of the answer by
recursively dividing the difference by the divisor.  Stop when the order of the
divisor exceeds the order of the dividend and declare the dividend to be the
remainder.  Also, if the dividend ever becomes zero, return zero as both
quotient and remainder.

We can design a \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{div-poly} procedure on the model of
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{add-poly} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{mul-poly}. The procedure checks to see if
the two polys have the same variable. If so, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{div-poly} strips off the
variable and passes the problem to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{div-terms}, which performs the
division operation on term lists. \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{div-poly} finally reattaches the
variable to the result supplied by \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{div-terms}. It is convenient to
design \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{div-terms} to compute both the quotient and the remainder of a
division. \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{div-terms} can take two term lists as arguments and return
a list of the quotient term list and the remainder term list.

Complete the following definition of \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{div-terms} by filling in the
missing expressions. Use this to implement \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{div-poly}, which takes two
polys as arguments and returns a list of the quotient and remainder polys.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (div-terms L1 L2)
  (if (empty-termlist? L1)
      (list (the-empty-termlist) (the-empty-termlist))
      (let ((t1 (first-term L1))
            (t2 (first-term L2)))
        (if (> (order t2) (order t1))
            (list (the-empty-termlist) L1)
            (let ((new-c (div (coeff t1) (coeff t2)))
                  (new-o (- (order t1) (order t2))))
              (let ((rest-of-result
                     ;;<compute rest of result recursively>
                     ))
                ;;<form complete result>
                ))))))
\end{minted}


\subsubsection{Answer}
\label{sec:orgd67b558}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (div-terms L1 L2)
  ;; termlist, termlist -> list of two termlists
  ;; returns quotient terms and remainder terms
  (if (empty-termlist? L1)
      (list (the-empty-termlist) (the-empty-termlist))
      (let ((t1 (first-term L1))
            (t2 (first-term L2)))
        (if (> (order t2) (order t1))
            (list (the-empty-termlist) L1)
            (let* ((new-term (make-sparse-term (- (order t1) (order t2))
                                               (div (coeff t1) (coeff t2))))
                   (rest-of-result
                    (div-terms (sub-terms L1
                                          (mul-terms (list new-term)
                                                     L2))
                               L2)))
              (list (adjoin-term new-term
                                 (car rest-of-result))
                    (cadr rest-of-result)))))))
(define (div-poly p1 p2)
  ;; poly, poly -> list of 2 polys
  ;; returns quotient poly and remainder poly
  (if (same-variable? (variable p1) (variable p2))
      (let* ((result (div-terms (terms p1) (terms p2)))
             (quotient (car result))
             (remainder (cadr result)))
        (list (make-poly (variable p1) quotient)
              (make-poly (variable p1) remainder)))
      (error "Polys not in same var: DIV-POLY" (list p1 p2))))
(put 'div '(polynomial polynomial)
     (lambda (p1 p2)
       (let* ((result (div-poly p1 p2))
              (quotient (car result))
              (remainder (cadr result)))
         (list (tag quotient)
               (tag remainder)))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<op-table>>
<<type-table>>
<<sqrt>>
<<echo>>
<<smarter-type-tagging>>
<<attach-tag-fixed>>
<<list-indices>>
<<tower-predicates>>
<<apply-generic-drop>>
<<generic-arithmetic-complex-parts>>
<<real-package>>
<<eqzero?>>
<<real-package>>
<<basic-tower-coercions>>

<<polynomial-sparse-dense-top>>
<<polynomial-division>>
<<polynomial-sparse-dense-bottom>>

<<generic-negation>>

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)
(install-real-package)
(install-equ?)
(install-=zero?)
(install-polynomial-package)
(install-negation)

<<gen-math-tests>>

(mattcheck "raise success"
           (raise 78)
           (make-rational 78 1))
(mattcheck "raise fail"
           (raise (make-complex-from-mag-ang 78 64))
           #f)
(mattcheck "apply-generic 1"
           (add 1 (make-rational 3 5))
           (make-rational 8 5))
(mattcheck "apply-generic 2"
           (add (make-real 2)
                (make-complex-from-mag-ang 3 5))
           (make-complex-from-real-imag 2.850986556389679 -2.8767728239894153))
(mattcheck "drop 1"
           (drop (make-complex-from-real-imag 5 0))
           5)
(mattcheck "drop 2"
           (drop (make-real 5))
           5)
(mattcheck "drop 3"
           (drop (make-rational 5 1))
           5)
(mattcheck "complex with nested rational"
           (make-complex-from-real-imag 2 (make-rational 3 5))
           (cons 'complex (cons 'rectangular (cons 2 (cons 'rational (cons 3 5))))))
(mattcheck "math on complex with nested rational"
           (add (make-complex-from-real-imag 2 (make-rational 3 5))
                (make-complex-from-mag-ang (make-rational 3 5) 2))
           (cons 'complex (cons 'rectangular
                                (cons (cons 'rational (cons 8.751559490358574 5))
                                      (cons 'rational (cons 28.639461402385223 25))))))
(mattcheck "polynomial = zero"
           (=zero? (make-polynomial 'x '((0 0)))))
(mattcheck "polynomial != zero" #f
           (=zero? (make-polynomial 'x '((1 1)(0 1)))))

(let ((p1 '((100 1)(2 2)(0 1)))
      (p2 (list (list 7 (make-polynomial 'x '((3 2))))))
      (p3 '((100 1)(2 1)(0 3)))
      (p4 '((100 -1)(2 -2)(0 -1)))
      (p5 '(8 2 5 -3 -7))
      (p7 '((1 1)(0 1)))
      (p6 '((3 1)(0 1)))
      (p66 '(1 0 0 1))
      (p77 '(1 1)))
  (mattcheck "polynomial addition"
             (add (make-polynomial 'x p1)
                  (make-polynomial 'x p1))
             '(polynomial x (100 2)(2 4)(0 2)))
  (mattcheck "polynomial multiplication"
             (mul (make-polynomial 'x p1)
                  (make-polynomial 'x p1))
             '(polynomial x (200 1) (102 4) (100 2) (4 4) (2 4) (0 1)))
  (mattcheck "nested polynomial addition"
             (add (make-polynomial 'x p2)
                  (make-polynomial 'x p1))
             '(polynomial x (100 1) (7 (polynomial x (3 2))) (2 2) (0 1)))
  (mattcheck "nested polynomial mult"
             (mul (make-polynomial 'x p2)
                  (make-polynomial 'x p1))
             '(polynomial x (107 (polynomial x (3 2))) (9 (polynomial x (3 4))) (7 (polynomial x (3 2)))))
  (mattcheck "negation scheme-number"
             (neg 5) -5)
  (mattcheck "negation rational"
             (neg (make-rational 1 5))
             (make-rational -1 5))
  (mattcheck "negation rectangular complex"
             (neg (make-complex-from-real-imag 3 7))
             (make-complex-from-real-imag -3 -7))
  (mattcheck "negation polar complex"
             (neg (make-complex-from-mag-ang 3 7))
             (make-complex-from-mag-ang -3 7))

  (mattcheck "negation polynomials"
             (neg (make-polynomial 'x p1))
             (make-polynomial 'x p4))
  (mattcheck "polynomial subtraction"
             (sub (make-polynomial 'x p1)
                  (make-polynomial 'x p3))
             '(polynomial x 1 0 -2))
  (mattcheck "polynomial division 1"
             (div (make-polynomial 'x p6)
                  (make-polynomial 'x p7))
             '((polynomial x 1 -1 1) (polynomial x)))
  (mattcheck "polynomial division 2"
             (div (make-polynomial 'x p7)
                  (make-polynomial 'x p6))
             '((polynomial x) (polynomial x 1 1)))
  (mattcheck "polynomial division 3"
             (div (make-polynomial 'x p66)
                  (make-polynomial 'x p77))
             '((polynomial x 1 -1 1) (polynomial x))))
\end{minted}

\begin{verbatim}
(etc...)
SUCCEED at polynomial division 1
SUCCEED at polynomial division 2
SUCCEED at polynomial division 3
\end{verbatim}

\subsection{Exercise 2.92: operating on polys in different variables}
\label{sec:orgaed8b73}
\subsubsection{Question}
\label{sec:org5b002b1}
By imposing an ordering on variables, extend the polynomial package so that
addition and multiplication of polynomials works for polynomials in different
variables. (This is not easy!)

\subsubsection{Answer}
\label{sec:orgb51ac70}
\begin{center}
\emph{\emph{Unfortunately, I've spent a lot of time on this without making progress. For
some reason it's really screwed with my brain. I'm going to move on to
\hyperref[sec:org08d2326]{Exercise 2.93}}}
\end{center}

If I understand the previous section correctly, I need to change the polynomial
procedures so that when given two polys which include similar terms, say \(x\)
with coefficients in \(y\) and \(y\) with coefficients in \(x\), I need to pick
one variable to be priority, and convert the other expression to match that
priority. I suppose this would also need to work with multiple layers of
polynomials, say a poly of \(w\) with nested coefficients \(x^y^z\) and \(y\)
with \(w^z^y\).

I've also decided to upgrade my \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{adjoin-terms} procedures so that they
can adjoin to the middle of lists, or attempt to add two coefficients of the
same order.

I've \emph{also} also decided to add polynomials to the type coercion tower. This
will require putting a variable on the new polynomial, but it will be a poly of
one term of the 0'th order, which isn't really a polynomial. I'll need to add a
check, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{trivial-poly?}, which will allow the procedures to ignore the
variable of such a polynomial.

My earlier choice to not tag sparse and dense lists may be coming back to bite
me, now that I'm nesting items in the coefficients.

In the process of reorganizing polynomials, I'll make a hash table, and find the
terms in the poly which are not dependent on the top variable, and split them
into their own keys in the table. So for any terms of order 0, if it's a poly
it'll get keyed to the variable of the poly, and if it's not it'll be keyed to
the symbol \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{'ZEROTH}.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define tower
  '(scheme-number rational real complex polynomial))

(define (raise x)
  (let ((t1 (type-tag x)))
    (let recurse ((ll tower))
      (let ((t2 (car ll)))
        (cond ((null? (cdr ll)) #f)
              ((equal? t1 t2)
               ((get-coercion t1 (cadr ll)) (contents x)))
              (else (recurse (cdr ll))))))))

(put-coercion 'scheme-number 'rational
              (lambda(num)
                (make-rational num 1)))
<<eqnumber>>
(put-coercion 'rational 'real
              (lambda(num)
                (make-real
                 (exact->inexact (/ ((get 'numer '(rational)) num)
                                    ((get 'denom '(rational)) num))))))
(put-coercion 'real 'complex
              (lambda(num)
                (make-complex-from-real-imag
                 num 0)))
(put-coercion 'complex 'polynomial
              (lambda(num)
                ;; poly wants tagged numbers but (put-coercion) strips tags
                ;; also, might as well drop since it makes sense
                (let ((dropped-num (drop (attach-tag 'complex num))))
                  (make-polynomial 'DISCARD-ME
                                   (list (list 0 dropped-num))))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
(define (mem-index item ll)
  (list-index (lambda(x)(equal? item x))
              ll))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
(define (install-polynomial-package) 'no)
;; internal procedures
;; representation of poly
(define (make-poly variable term-list)
  (cons variable
        (convert-termlist-if-reasonable term-list)))
(define (variable p) (car p))
(define (terms p) (cdr p))
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (is-poly? list)
  (eqv? 'polynomial (type-tag list)))

;; representation of terms and term lists
(define (the-empty-termlist) '())
(define (rest-terms term-list) (cdr term-list))
(define (empty-termlist? term-list) (null? term-list))
(define (order term) (first term))
(define (coeff term) (second term))
(define (make-sparse-term order coeff)
  (list order coeff))
(define (sparse-termlist? term-list)
  (let ((t (car term-list)))
    (cond ((and (pair? t) ;; looks like a sparse list
                (number? (first t))
                (or (pair? (second t)) ;; or sparse with nested poly
                    (number? (second t))
                    (empty-termlist? (second t)))) #t)
          ((or (number? t) ;; looks dense
               (pair? t)
               (empty-termlist? term-list)) #f) ;; or dense with a nested poly
          (else (error "badly formed term: SPARSE-TERMLIST?" t term-list)))))
;; term and termlist procedures
(define (should-be-sparse? term-list)
  ;; sparse or dense term-list -> bool
  ;; if more than half of term-list is zeroes, return true
  ;; reasoning:
  ;; - number of elements used for sparse list is (non-zero elements * 2)
  ;; - number of elements used for dense list is (highest order)
  ;; also, if term-list is 1 non-number element, make a sparse term for clarity
  (define (count-zeroes term-list)
    ;; term-list -> (highest order, zeroes)
    (let iter ((length 0)
               (zeroes 0)
               (TL (if (sparse-termlist? term-list)
                       (sparse-to-dense term-list)
                       term-list)))
      (if (empty-termlist? TL)
          (list zeroes length)
          (iter (1+ length)
                (if (=zero? (car TL))
                    (1+ zeroes)
                    zeroes)
                (cdr TL)))))
  (let ((stats (if (sparse-termlist? term-list) ;; do appropriate measurement
                   (list (- (1+ (order (sparse-first-term term-list)))
                            (length term-list))
                         (1+ (order (sparse-first-term term-list))))
                   (count-zeroes term-list))))
    (let ((zero-elements (first stats))
          (highest-order (second stats)))
      (or (and (= 1 (length term-list))
               (not (number? (first-term term-list))))
          (> (/ zero-elements highest-order)
             (/ 1 2))))))
(define (convert-termlist-if-reasonable term-list)
  (if (empty-termlist? term-list)
      term-list
      (cond ((sparse-termlist? term-list)
             (let ((tl (sort-sparse-terms term-list)))
               (if (should-be-sparse? tl)
                   tl
                   (sparse-to-dense tl))))
            ((should-be-sparse? term-list)
             (dense-to-sparse term-list))
            (else term-list))))
(define (sparse-to-dense term-list)
  (let iter ((old-list (reverse term-list))
             (new-list (the-empty-termlist)))
    (if (empty-termlist? old-list)
        new-list
        (iter (rest-terms old-list)
              (adjoin-term-dense (sparse-first-term old-list)
                                 new-list)))))
(define (dense-to-sparse term-list)
  (let iter ((old-list (reverse term-list))
             (old-order 0)
             (new-list (the-empty-termlist)))
    (if (empty-termlist? old-list)
        new-list
        (iter (rest-terms old-list)
              (1+ old-order)
              (adjoin-term-sparse (make-sparse-term old-order
                                                    (coeff (dense-first-term old-list)))
                                  new-list)))))
(define (dense-termlist-order term-list)
  (1- (length term-list)))
(define (dense-first-term term-list)
  (make-sparse-term (dense-termlist-order term-list)
                    (car term-list)))
(define (sparse-first-term term-list)
  (car term-list))
(define (first-term term-list)
  (if (sparse-termlist? term-list)
      (sparse-first-term term-list)
      (dense-first-term term-list)))
(define (adjoin-term-sparse term term-list)
  ;; if term is higher order, cons to list
  ;; if equal, replace or add
  ;; if term is lower order than top of list, try to insert in the middle
  (if  (empty-termlist? term-list)
       (cons term term-list)
       (let ((top-order (order (sparse-first-term term-list))))
         (cond ((<= (1+ top-order) (order term))
                (cons term term-list))
               ((= top-order (order term))
                (if (=zero? (coeff (sparse-first-term term-list)))
                    ;; replace if it's zero
                    (cons term (rest-terms term-list))
                    ;; and add if it's not
                    (let ((result (add-sparse-term-to-sparse-term term
                                                                  (sparse-first-term term-list))))
                      (cons result
                            (rest-terms term-list))))) 
               (else (adjoin-term-sparse (sparse-first-term term-list)
                                         (adjoin-term-sparse term
                                                             (rest-terms term-list))))))))
(define (adjoin-term-dense term term-list)
  ;; if term is lower order than top of list, try to insert in the middle
  (let ((top-order (dense-termlist-order term-list)))
    (cond ((= (1+ top-order) (order term))
           ;; if term is 1 order above top of list, adjoin
           (cons (coeff term) term-list))
          ;; if term shares order with top of list, 
          ((= top-order (order term))
           (if (=zero? (coeff (dense-first-term term-list)))
               ;; replace if it's zero
               (cons (coeff term)
                     (rest-terms term-list))
               ;; and add if it's not
               (let ((result (add-sparse-term-to-sparse-term term
                                                             (dense-first-term term-list))))
                 (cons (coeff result)
                       (rest-terms term-list)))))
          ((< top-order (order term))
           (adjoin-term-dense term (cons 0 term-list)))
          ;; if term is more than 1 order above, adjoin 0 and recurse
          (else (adjoin-term-dense (dense-first-term term-list)
                                   (adjoin-term-dense term
                                                      (rest-terms term-list)))))))

(define (adjoin-term term term-list)
  (if (=zero? (coeff term))
      term-list
      (if (or (empty-termlist? term-list)
              (sparse-termlist? term-list))
          (adjoin-term-sparse term term-list)
          (adjoin-term-dense term term-list))))
(define (merge-terms t1 t2)
  (cond ((empty-termlist? t2)
         t1)
        ((empty-termlist? t1)
         t2)
        ((>= (order (first-term t1)) (order (first-term t2)))
         (adjoin-term (first-term t1)
                      (merge-terms (rest-terms t1) t2)))
        (else (adjoin-term (first-term t2)
                           (merge-terms t1 (rest-terms t2))))))
; ;; this second version is way simpler and way slower.
; (define (merge-terms-abstracted t1 t2)
;   (if (empty-termlist? t2)
;       t1
;       (merge-terms-abstracted (adjoin-term (first-term t2) t1)
;                                   (rest-terms t2))))
(define (map-terms f tl)
  ;; f is called (f order coeff)
  (let iter ((result '())
             (term-list tl))
    (if (empty-termlist? term-list)
        (reverse result)
        (iter (cons (let ((t (first-term term-list)))
                      (f (order t) (coeff t)))
                    result)
              (rest-terms term-list)))))
(define (map2-terms f tl1 tl2)
  (let iter ((result '())
             (term-list1 tl1)
             (term-list2 tl2))
    (if (or (empty-termlist? term-list1)
            (empty-termlist? term-list2))
        (reverse result)
        (iter (cons (let ((t1 (first-term term-list))
                          (t2 (first-term term-list)))
                      (f (order t1) (coeff t1)
                         (order t2) (coeff t2)))
                    result)
              (rest-terms term-list1)
              (rest-terms term-list2)))))
(define (equ?-terms t1 t2)
  (and (= (order t1)
          (order t2))
       (equ? (coeff t1)
             (coeff t2))))
(define (sort-sparse-terms term-list)
  (sort term-list (lambda(t1 t2)
                    (> (order t1)
                       (order t2)))))
(define (add-sparse-term-to-sparse-term t1 t2)
  (make-sparse-term (order t1)
                    (add (coeff t1) (coeff t2))))
(define (add-terms L1 L2)
  (cond ((empty-termlist? L1) L2)
        ((empty-termlist? L2) L1)
        (else
         (let ((t1 (first-term L1))
               (t2 (first-term L2)))
           (cond ((> (order t1) (order t2))
                  (adjoin-term
                   t1 (add-terms (rest-terms L1) L2)))
                 ((< (order t1) (order t2))
                  (adjoin-term
                   t2 (add-terms L1 (rest-terms L2))))
                 (else
                  (adjoin-term
                   (add-sparse-term-to-sparse-term t1 t2)
                   (add-terms (rest-terms L1)
                              (rest-terms L2)))))))))
(define (mul-terms L1 L2)
  (if (empty-termlist? L1)
      (the-empty-termlist)
      (add-terms (mul-term-by-all-terms (first-term L1) L2)
                 (mul-terms (rest-terms L1) L2))))
(define (terms-=zero? L)
  (or (empty-termlist? L)
      (and (=zero? (coeff (first-term L)))
           (terms-=zero? (rest-terms L)))))
(define (neg-terms TL)
  (let ((negterm (if (sparse-termlist? TL)
                     (lambda(t)
                       (make-sparse-term (order t) (neg (coeff t))))
                     (lambda(t)
                       (neg (coeff t))))))
    (map negterm TL)))
(define (sub-terms T1 T2)
  (add-terms T1 (neg-terms T2)))
(define (div-terms L1 L2)
  ;; termlist, termlist -> list of two termlists
  ;; returns quotient terms and remainder terms
  (if (empty-termlist? L1)
      (list (the-empty-termlist) (the-empty-termlist))
      (let ((t1 (first-term L1))
            (t2 (first-term L2)))
        (if (> (order t2) (order t1))
            (list (the-empty-termlist) L1)
            (let* ((new-term (make-sparse-term (- (order t1) (order t2))
                                               (div (coeff t1) (coeff t2))))
                   (rest-of-result
                    (div-terms (sub-terms L1
                                          (mul-terms (list new-term)
                                                     L2))
                               L2)))
              (list (adjoin-term new-term
                                 (car rest-of-result))
                    (cadr rest-of-result)))))))
;; polynomial procedures
(define (trivial-poly? poly)
  (and (= 1 (length (terms poly)))
       (= 0 (order (first-term (terms poly))))))
;;; TODO: get working once cross-variable comparisons can be done
(put 'project 'polynomial
     (lambda (p)
       (if (not (trivial-poly? p))
           #f
           (coeff (first-term (terms p))))))
(define (equ?-poly p q)
  (cond ((and (trivial-poly? p)
              (trivial-poly? q))
         (equ? (coeff (first-term (terms p)))
               (coeff (first-term (terms q)))))
        ((same-variable? (variable p) (variable q))
         (let iter ((term-list1 (reverse tl1))
                    (term-list2 (reverse tl2)))
           (cond ((and (empty-termlist? term-list1)
                       (empty-termlist? term-list2))
                  #t)
                 ((or (empty-termlist? term-list1)
                      (empty-termlist? term-list2))
                  #f)
                 ((equ?-terms (first-term term-list1)
                              (first-term term-list2))
                  (iter (rest-terms term-list1)
                        (rest-terms term-list2)))
                 (else #f))))
        (else (error "different vars not supported yet : EQU?-POLY" p q))))
(put 'equ? '(polynomial polynomial)
     equ?-poly)
(define (make-variable-priority-list poly)
  (cons (variable poly)
        (let rec ((term-list (terms poly)))
          (if (empty-termlist? term-list)
              '()
              (let* ((t (first-term term-list))
                     (c (coeff t))
                     (o (order t)))
                (cond ((is-poly? c)
                       (cons (variable (contents c))
                             (append (rec (rest-terms term-list))
                                     (rec (terms (contents c))))))
                      (else (rec (rest-terms term-list)))))))))
(define (merge-priority-lists l1 l2)
  (if (null? l2)
      l1
      (let rec ((to-check l1)
                (checking (car l2)))
        (cond ((null? to-check)
               (merge-priority-lists (append l1 (list checking))
                                     (cdr l2)))
              ((same-variable? checking (car to-check))
               (merge-priority-lists l1
                                     (cdr l2)))
              (else (rec (cdr to-check) checking))))))
(define (poly-single-var? wantedvar poly)
  (and (same-variable? (variable poly) wantedvar)
       (let rec ((term-list (terms poly)))
         (if (empty-termlist? term-list)
             #t
             (let ((c (coeff (first-term term-list))))
               (if (not (is-poly? c))
                   (rec (rest-terms term-list))
                   (and (poly-single-var? wantedvar c)
                        (rec (rest-terms term-list)))))))))
;;; Example of an inverted poly:
;;; (poly x (order 4, coeff (poly y (5 6)))
;;;         (order 3, coeff (poly y (1 2)))
;;;         (order 0, coeff 7))
;;; (poly y (order 5, coeff (poly x (4 6)))
;;;         (order 1, coeff (poly x (3 2)))
;;;         (order 0, coeff 7))
;;; (make-poly sub-var (list (make-sparse-term subO (make-polynomial super-var (list (make-sparse-term superO subC))))))
;;; (poly x (1, (poly y (2, (poly z (3, 4))))))
;;; (poly x (1, (poly z (3, (poly y (2, 4))))))
;;; (poly z (3, (poly x (1, (poly y (2, 4)))))
;;; (poly z (3, (poly y (2, (poly x (1, 4))))))

;; This isn't good enough, it doesn't invert the poly and also it needs to
;; produce multiple terms for one term with a poly with multiple terms
;(define (invert-term parent-var parent-order term)
;  (let* ((child-order (order term))
;        (child-coeff (coeff term)))
;    (make-sparse-term child-order
;                      (make-polynomial parent-var
;                                       (list (make-sparse-term parent-order
;                                                               child-coeff))))))
(define (pad-term-if-needed term parent-priority-list)
  ;; term with tagged poly, priority list -> term
  ;; parent-priority-list starts with the variable this term's order is in
  ;; term: term with tagged poly inside

  ;; pad term so that cross-variable functions will have equal structures
  ;; to thoughtlessly work from. I.e. if your list is '(a b c d e) and
  ;; your term is (5 (poly d (2 1))), we'll return
  ;; '(5 (poly b (poly c (poly d (2 1))))) (nested polys representing dense terms)
  (let* ((parent-var (car parent-priority-list))
         (child-var (variable (contents (coeff term))))
         (pri (member parent-var parent-priority-list))
         (difference (mem-index child-var pri)))
    (if (= difference 1)
        term
        (let* ((rest-priorities (cdr pri))
               (next-var (car rest-priorities)))
          (make-sparse-term (order term)
                            (make-polynomial next-var
                                             (list (pad-term-if-needed (make-sparse-term 0 (coeff term))
                                                                       rest-priorities))))))))
(define (pad-poly-if-needed poly parent-priority-list)
  ;; untagged poly -> untagged poly
  (let* ((child-var (variable poly))
         (difference (mem-index child-var parent-priority-list)))
    (if (> difference 0)
        (make-poly (car parent-priority-list)
                   (list (pad-term-if-needed (make-sparse-term 0 (tag poly))
                                             parent-priority-list))))))
(define (make-empty-poly-in var)
  (if (pair? var)
      (make-poly (car var)
                 (list (make-sparse-term
                        0 (tag (make-empty-poly-in
                                (if (= 2 (length var))
                                    (cadr var)
                                    (cdr var)))))))
      (make-poly var (the-empty-termlist))))
(define (priority-depth var priority-list)
  ;; return how far in a list a var is
  ;; 0 is head, 2 means two vars ahead, etc
  (mem-index var priority-list))
(define (priority-diff var1 var2 priority-list)
  ;; return how far ahead var2 is from var1
  ;; so a child correctly nested in a parent is 1
  ;; if vars need to be swapped, this will be negative
  (let ((d1 (mem-index var1 priority-list))
        (d2 (mem-index var2 priority-list)))
    (- d2 d1)))
(define (invert-nested-poly-terms superVar superO term-list)
  ;;  -> term-list
  (let iter ((tl term-list)
             (done (the-empty-termlist)))
    (if (empty-termlist? tl)
        done
        (let* ((t (first-term tl))
               (new-t (make-sparse-term (order t)
                                        (make-polynomial superVar
                                                         (make-sparse-term superO
                                                                           (coeff t))))))
          (iter (rest-terms tl)
                (adjoin-term new-t done))))))
(define (poly-has-no-children? p)
  (let iter ((tl (terms p)))
    (cond ((empty-termlist? tl) #t)
          ((and (pair? (coeff (first-term tl)))
                (equal? 'polynomial (type-tag (coeff (first-term tl))))) #f)
          (else (iter (rest-terms tl))))))
;; BIG PROBLEM: I NEED TO WORK OUT ORDERING OF TERMS VERSUS ORDERING OF POLY NESTING
;; i.e.
;(poly a (0
;         (poly b (1 2)
;                 (0
;                  (poly c (3 4))))))
;(poly a (0 (poly b (1 2)))
;        (poly c (3 4)))
;; Maybe the only good choice is to have polys strictly nest linearly
(define (reorganize-poly-if-needed poly parent-priority-list)
  ;; untagged poly, pri list -> untagged poly
  ;; pri list should start with the variable you want the poly in,
  ;; and contain all vars that the poly contains
  (define (promote p target-var)
    (define (p-rec term-list)
      (map-terms (lambda(t)
                   ())
                 term-list)))
    ;; descend into children until findng desired var, then ascend
    ;; to bring it back to the parent while rearranging as needed
    (receive (cool uncool)
        (partition (lambda(t)
                     (let ((c (coeff t)))
                     (and (pair? c)
                          (equal? 'polynomial (type-tag c))
                          (same-variable? target-var
                                          (variable (contents c))))))
                   (let ((tl (terms p)))
                     (if (sparse-termlist? tl)
                         tl
                         (dense-to-sparse tl))))
      (cond ((poly-has-no-children? p) p) ;;dead end
            ((null? cool) ;; var is below but not here yet, keep bubbling
             )
            (else (make-poly target-var
                             (let rec ((tl cool))
                               (if (empty-termlist? tl)
                                   (the-empty-termlist)
                                   (let* ((t (first-term tl))
                                          (o (order t))
                                          (c (coeff c))
                                          (child-poly (contents c)))
                                     (merge-termlists (invert-nested-poly-terms (variable p) o
                                                                                (terms child-poly))
                                                      (rec (rest-terms tl))))))))))
  (let rec ((p poly)
            (pri parent-priority-list))
    (if (null? pri)
        p ;; give up
        (let* ((top-var (car pri))
               (var (variable p))
               (tl (terms p))
               (child-descendants (make-variable-priority-list p))
               (diff (priority-diff top-var var parent-priority-list)))
          (cond ((equal? child-descendants parent-priority-list)
                 p) ;; sort done
                ((not (member top-var child-descendants))
                 ;; we need to pad for this var
                 (make-poly top-var (tag (rec p (cdr pri)))))
                ((= 0 diff)
                 ('todo)))))))
;(define (check-terms term-list)
;  (let iter ((remaining term-list)
;             (done (the-empty-termlist)))
;    (if (empty-termlist? remaining)
;        done
;        (let* ((t (first-term remaining))
;               (c (coeff t))
;               (o (order t))
;               (new-t (make-sparse-term o
;                                        (if (is-poly? c)
;                                            (tag (reorganize-poly-if-needed (contents c) parent-priority-list))
;                                            c))))
;          (iter (rest-terms remaining)
;                (adjoin-term new-t done))))))
;(define (invert-this-poly poly new-var)
;  (let ((var (variable poly))
;        (term-list (terms poly)))
;    (let iter ((remaining term-list)
;               (done (the-empty-termlist)))
;      (if (empty-termlist? remaining)
;          (make-poly new-var done)
;          (let* ((t (first-term remaining))
;                 (o (order t))
;                 (c (coeff t)))
;            (if (is-poly? c)
;                (let ((child-var (variable (contents c)))
;                      (child-terms (terms (contents c))))
;                  (cond ((> o 0) ;; if order is not 0, an inverted poly is needed
;                         (iter (rest-terms remaining)
;                               (merge-termlists done (invert-nested-poly-terms new-var o child-terms))))
;                        ((same-variable? var child-var)
;                         (error "This shouldn't happen : INVERT-THIS-POLY :" remaining done))
;                                      ;(iter (merge-termlists child-terms (rest-terms remaining))
;                                      ;      done))
;                        ((same-variable? new-var child-var)
;                         (iter (rest-terms remaining)
;                               (merge-termlists done (check-terms child-terms))))
;                        (else (error "WHAT TO HECK : INVERT-THIS-POLY :" remaining done))))
;                (let ((new-t (make-sparse-term 0
;                                               (make-polynomial var
;                                                                (make-sparse-term o
;                                                                                  c)))))
;                  (iter (rest-terms remaining)
;                        (adjoin-term new-t done)))))))))
;(let* ((top-var (car parent-priority-list))
;       (var (variable poly))
;       (tl (terms poly))
;       (child-descendants (make-variable-priority-list poly))
;       (diff (priority-diff top-var var parent-priority-list)))
;  (cond ((= 0 diff)
;         ;; if poly and top-var are the same, then keep terms how they are
;         ;; except for terms that have poly coeffs, which need to be checked
;         (make-poly top-var (check-terms tl)))
;        ((< 0 diff)
;         (let ((reorganized-terms (check-terms tl)))
;           (pad-poly-if-needed (make-poly var reorganized-terms)
;                               parent-priority-list)))
;        ;; if var is 1 step of priority below in the list than top-var, then
;        ;; swap its terms with top-var terms
;        ((= 1 diff)
;         (pad-poly-if-needed (invert-this-poly poly top-var)
;                             parent-priority-list))
;        ;; if var is >1 steps of priority below top-var, and top-var is known
;        ;; to be in the child's children, then reorganize the child poly's
;        ;; terms and try again
;        ((< 1 diff)
;         (if (member top-var child-descendants)
;             (let ((reorganized-terms (check-terms tl)))
;               (reorganize-poly-if-needed (make-poly var reorganized-terms)
;                                          parent-priority-list))
;             (error "expected child poly not found? : REORGANIZE-POLY-IF-NEEDED :"
;                    parent-priority-list child-descendants)))
;        (else "what the SCALLOP" child-descendants diff))))
(define (operate-on-polys f p1 p2)
  ;; f is a function to operate on term-lists
  (cond ((same-variable? (variable p1) (variable p2))
         (make-poly (variable p1)
                    (f (terms p1) (terms p2))))
        ((trivial-poly? p1)
         (make-poly (variable p2)
                    (f (terms p1) (terms p2))))
        ((trivial-poly? p2)
         (make-poly (variable p1)
                    (f (terms p1) (terms p2))))
        (((get '=zero? 'polynomial) p1)
         p2)
        (((get '=zero? 'polynomial) p2)
         p1)
        (else
         (let* ((priorities (merge-priority-lists (make-variable-priority-list p1)
                                                  (make-variable-priority-list p2)))
                (p1r ((reorganize-poly-if-needed p1 priorities)))
                (p2r ((reorganize-poly-if-needed p2 priorities))))
           (make-poly (variable p1r)
                      (f (terms p1r) (terms p2r)))))))
(define (add-poly p1 p2)
  (define triv
    ;; if a poly is trivial, return the opposite variable
    (cond ((trivial-poly? p1)
           (variable p2))
          ((trivial-poly? p2)
           (variable p1))
          (else #f)))
  (cond ((or (same-variable? (variable p1) (variable p2))
             triv)
         (make-poly (if triv
                        triv
                        (variable p1))
                    (add-terms (terms p1) (terms p2))))
        (else
         (let ((p2r ((reorganize-poly-if-needed p2
                                                (make-variable-priority-list p1)))))
           (make-poly (variable p1)
                      (add-terms (terms p1) (terms p2r)))))))
(define (mul-poly p1 p2)
  (define triv
    ;; if a poly is trivial, return the opposite variable
    (cond ((trivial-poly? p1)
           (variable p2))
          ((trivial-poly? p2)
           (variable p1))
          (else #f)))
  (cond ((or (same-variable? (variable p1) (variable p2))
             triv)
         (make-poly (if triv
                        triv
                        (variable p1))
                    (mul-terms (terms p1) (terms p2))))
        (else (error "Polys not in same var: MUL-POLY" (list p1 p2)))))

;; interface to rest of the system
(define (tag p) (attach-tag 'polynomial p))
(put 'add '(polynomial polynomial)
     (lambda (p1 p2) (tag (add-poly p1 p2))))
(put 'mul '(polynomial polynomial)
     (lambda (p1 p2) (tag (mul-poly p1 p2))))
(put 'make 'polynomial
     (lambda (var terms) (tag (make-poly var terms))))
(define (if-1st-poly-make-2nd-poly t1 t2)
  (if (and (eqv? 'polynomial (type-tag t1))
           (not (eqv? 'polynomial (type-tag t2))))
      (tag (make-poly (variable (contents t1)) (list t2)))
      t2))
(define (mul-term-by-all-terms t1 L)
  (if (empty-termlist? L)
      (the-empty-termlist)
      (let* ((t2 (first-term L)) ;; If one coeff is a poly, make the other a poly
             (t1-coeff (if-1st-poly-make-2nd-poly (coeff t2) (coeff t1)))
             (t2-coeff (if-1st-poly-make-2nd-poly (coeff t1) (coeff t2))))
        
        (adjoin-term
         (make-sparse-term (+ (order t1) (order t2))
                           (mul t1-coeff t2-coeff))
         (mul-term-by-all-terms t1 (rest-terms L))))))
(define (poly-=zero? p)
  (terms-=zero? (terms p)))
(put '=zero? '(polynomial) poly-=zero?)
(define (neg-poly p)
  (make-poly (variable p)
             (neg-terms (terms p))))
(put 'neg '(polynomial)
     (lambda (p1) (tag (neg-poly p1))))
(define (sub-poly p1 p2)
  (add-poly p1 (neg-poly p2)))
(put 'sub '(polynomial polynomial)
     (lambda (p1 p2) (tag (sub-poly p1 p2))))
(define (div-poly p1 p2)
  ;; poly, poly -> list of 2 polys
  ;; returns quotient poly and remainder poly
  (if (same-variable? (variable p1) (variable p2))
      (let* ((result (div-terms (terms p1) (terms p2)))
             (quotient (car result))
             (remainder (cadr result)))
        (list (make-poly (variable p1) quotient)
              (make-poly (variable p1) remainder)))
      (error "Polys not in same var: DIV-POLY" (list p1 p2))))
(put 'div '(polynomial polynomial)
     (lambda (p1 p2)
       (let* ((result (div-poly p1 p2))
              (quotient (car result))
              (remainder (cadr result)))
         (list (tag quotient)
               (tag remainder)))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;  'done)
(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "../mattcheck2.scm")
<<op-table>>
<<type-table>>
<<sqrt>>
<<echo>>
<<smarter-type-tagging>>
<<attach-tag-fixed>>
<<list-indices>>
<<tower-predicates>>
<<apply-generic-drop>>
<<generic-arithmetic-complex-parts>>
<<real-package>>
<<eqzero?>>
<<real-package>>
<<tower-coercions-polynomial>>

<<mem-index>>
<<polynomial-mixed-variables-top>>
<<polynomial-mixed-variables-bottom>>

<<generic-negation>>

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)
(install-real-package)
(install-equ?)
(install-=zero?)
(install-polynomial-package)
(install-negation)

<<gen-math-tests>>

(mattcheck "raise success"
           (raise 78)
           (make-rational 78 1))
(mattcheck "raise fail"
           (raise (make-polynomial 'x '(3 2)))
           #f)
(mattcheck "apply-generic 1"
           (add 1 (make-rational 3 5))
           (make-rational 8 5))
(mattcheck "apply-generic 2"
           (add (make-real 2)
                (make-complex-from-mag-ang 3 5))
           (make-complex-from-real-imag 2.850986556389679 -2.8767728239894153))
(mattcheck "drop 1"
           (drop (make-complex-from-real-imag 5 0))
           5)
(mattcheck "drop 2"
           (drop (make-real 5))
           5)
(mattcheck "drop 3"
           (drop (make-rational 5 1))
           5)
(mattcheck "complex with nested rational"
           (make-complex-from-real-imag 2 (make-rational 3 5))
           (cons 'complex (cons 'rectangular (cons 2 (cons 'rational (cons 3 5))))))
(mattcheck "math on complex with nested rational"
           (add (make-complex-from-real-imag 2 (make-rational 3 5))
                (make-complex-from-mag-ang (make-rational 3 5) 2))
           (cons 'complex (cons 'rectangular
                                (cons (cons 'rational (cons 8.751559490358574 5))
                                      (cons 'rational (cons 28.639461402385223 25))))))
(mattcheck "polynomial = zero"
           (=zero? (make-polynomial 'x '((0 0)))))
(mattcheck "polynomial != zero" #f
           (=zero? (make-polynomial 'x '((1 1)(0 1)))))

(define p1 '((100 1)(2 2)(0 1)))
(define p2 (list (list 7 (make-polynomial 'x '((3 2))))))
(define p3 '((100 1)(2 1)(0 3)))
(define p4 '((100 -1)(2 -2)(0 -1)))
(define p5 '(8 2 5 -3 -7))
(define p7 '((1 1)(0 1)))
(define p6 '((3 1)(0 1)))
(define p66 '(1 0 0 1))
(define p77 '(1 1))
(define p8 (make-poly 'a
                      (list (list 9 (make-polynomial 'b p3))
                            (list 8 (make-polynomial 'c p5))
                            (list 1 (make-polynomial 'd (list (list 0 (make-polynomial 'f '(3 2))))))
                            (list 0 (make-polynomial 'e (list 2 0))))))
(define p9 (make-poly 'a
                      (list (list 9
                                  (make-polynomial
                                   'b (list (list 8 (make-polynomial
                                                     'c (list (list 1 (make-polynomial
                                                                       'd (list (list 0 (make-polynomial
                                                                                         'e (list 2 0)))))))))))))))
(mattcheck "polynomial addition"
           (add (make-polynomial 'x p1)
                (make-polynomial 'x p1))
           '(polynomial x (100 2)(2 4)(0 2)))
(mattcheck "polynomial multiplication"
           (mul (make-polynomial 'x p1)
                (make-polynomial 'x p1))
           '(polynomial x (200 1) (102 4) (100 2) (4 4) (2 4) (0 1)))
(mattcheck "nested polynomial addition"
           (add (make-polynomial 'x p2)
                (make-polynomial 'x p1))
           '(polynomial x (100 1) (7 (polynomial x (3 2))) (2 2) (0 1)))
(mattcheck "nested polynomial mult"
           (mul (make-polynomial 'x p2)
                (make-polynomial 'x p1))
           '(polynomial x (107 (polynomial x (3 2))) (9 (polynomial x (3 4))) (7 (polynomial x (3 2)))))
(mattcheck "negation scheme-number"
           (neg 5) -5)
(mattcheck "negation rational"
           (neg (make-rational 1 5))
           (make-rational -1 5))
(mattcheck "negation rectangular complex"
           (neg (make-complex-from-real-imag 3 7))
           (make-complex-from-real-imag -3 -7))
(mattcheck "negation polar complex"
           (neg (make-complex-from-mag-ang 3 7))
           (make-complex-from-mag-ang -3 7))

(mattcheck "negation polynomials"
           (neg (make-polynomial 'x p1))
           (make-polynomial 'x p4))
(mattcheck "polynomial subtraction"
           (sub (make-polynomial 'x p1)
                (make-polynomial 'x p3))
           '(polynomial x 1 0 -2))
(mattcheck "polynomial division 1"
           (div (make-polynomial 'x p6)
                (make-polynomial 'x p7))
           '((polynomial x 1 -1 1) (polynomial x)))
(mattcheck "polynomial division 2"
           (div (make-polynomial 'x p7)
                (make-polynomial 'x p6))
           '((polynomial x) (polynomial x 1 1)))
(mattcheck "polynomial division 3"
           (div (make-polynomial 'x p66)
                (make-polynomial 'x p77))
           '((polynomial x 1 -1 1) (polynomial x)))

(mattcheck "poly projection good"
           (project (make-polynomial 'useless '((0 7))))
           7)
(mattcheck "poly projection bad"
           (project (make-polynomial 'useless '((1 7))))
           #f)
(mattcheck "raise to poly"
           (raise (make-complex-from-mag-ang 78 64))
           '(polynomial DISCARD-ME (complex polar 78 . 64)))
(mattcheck "reorganize-poly-if-needed"
           (reorganize-poly-if-needed p8 '(f e d c b a)))
(mattcheck "polynomials in multiple variables 1"
           (add (make-polynomial 'x p1)
                (make-polynomial 'y p1))
           'unknown)
\end{minted}

\subsection{Exercise 2.93: extending \texttt{make-rational} for rational functions}
\label{sec:org08d2326}
\subsubsection{Question}
\label{sec:org72ea720}
Modify the \texttt{rational-arithmetic} package to use generic operations, but change
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{make-rat} so that it does not attempt to reduce fractions to lowest
terms. Test your system by calling \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{make-rational} on two polynomials
to produce a rational function:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define p1 (make-polynomial 'x '((2 1) (0 1))))
(define p2 (make-polynomial 'x '((3 1) (0 1))))
(define rf (make-rational p2 p1))
\end{minted}

Now add \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{rf} to itself, using \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{add}. You will observe that
this addition procedure does not reduce fractions to lowest terms.

\subsubsection{Answer}
\label{sec:orgcc36c41}
\texttt{raise}-ing a rational function doesn't work, so I'll need a way around that.

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define tower
  '(scheme-number rational real complex polynomial))

(define (raise x)
  (let ((t1 (type-tag x)))
    (let recurse ((ll tower))
      (let ((t2 (car ll)))
        (cond ((null? (cdr ll)) #f)
              ((equal? t1 t2)
               ((get-coercion t1 (cadr ll)) (contents x)))
              (else (recurse (cdr ll))))))))

(define (raise-to x target)
  (define current-type (type-tag x))
  (define (try-coerce type-to-try)
    (let ((up (get-coercion current-type type-to-try)))
      (if up
          (up (contents x))
          #f)))
  (let* ((tower-from-here (member current-type tower)))
    (if (or (not tower-from-here)
            (not (member target tower-from-here)))
        #f ;; this raise can't happen
        (let rec ((ll (cdr tower-from-here)))
          (if (eqv? target (car ll))
              (try-coerce (car ll))
              (let ((try-harder
                     (rec (cdr ll))))
                (if try-harder
                    try-harder
                    (try-coerce (car ll)))))))))

(put-coercion 'scheme-number 'rational
              (lambda(num)
                (make-rational num 1)))
<<eqnumber>>
(put-coercion 'rational 'real
              (lambda(num)
                (let ((result (div ((get 'numer '(rational)) num)
                                   ((get 'denom '(rational)) num))))
                  (if (number? result)
                      (make-real (exact->inexact result))
                      #f))))
(put-coercion 'real 'complex
              (lambda(num)
                (make-complex-from-real-imag
                 num 0)))
(let ((raised-poly (lambda(num tag)
                       (make-polynomial 'DISCARD-ME
                                        (list (list 0 (attach-tag tag num)))))))
  (put-coercion 'scheme-number 'polynomial
                (lambda(num)
                  (raised-poly num 'scheme-number)))
  (put-coercion 'rational 'polynomial
                (lambda(num)
                  (raised-poly num 'rational)))
  (put-coercion 'real 'polynomial
                (lambda(num)
                  (raised-poly num 'real)))
  (put-coercion 'complex 'polynomial
                (lambda(num)
                  (raised-poly num 'complex))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
;; Version of apply-generic that tries to drop its type
;; when returning
(define (apply-generic op . args)
  (define types (map type-tag args))
  (define (map-raise highest-type item)
    (if (equal? (type-tag item) highest-type)
        item
        (let ((raised (raise-to item highest-type)))
          (if (not raised)
              (error "MAP-RAISE: could not raise" item highest-type)
              (map-raise highest-type raised)))))
  
  (drop
   (let ((proc (get op types)))
     (if proc ; is this already doable?
         (apply proc (map contents args))
                                        ; if not, try type coercion
         
         (let* ((highest-type (apply latest-in-tower types))
                (map-raise-prime (lambda(item)(map-raise highest-type item)))
                (raised (map map-raise-prime args)))
           (if (< (length raised) 3)
               ;; short args
               (let ((f (get op (map type-tag raised))))
                 (if (eqv? #f f)
                     (error "APPLY-GENERIC: could not find procedure for types" (map type-tag raised) raised)
                     (apply f (map contents raised))))
               ;; long args
               (reduce (lambda(elem previous)
                         (apply-generic op previous elem))
                       "ERROR" raised)))))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
(define (install-polynomial-package) 'no)
  ;; internal procedures
  ;; representation of poly
  (define (make-poly variable term-list)
    (cons variable
          (convert-termlist-if-reasonable term-list)))
  (define (convert-termlist-if-reasonable term-list)
    (if (empty-termlist? term-list)
        term-list
        (cond ((sparse-termlist? term-list)
               (let ((tl (sort-sparse-terms term-list)))
                 (if (should-be-sparse? tl)
                     tl
                     (sparse-to-dense tl))))
              ((should-be-sparse? term-list)
               (dense-to-sparse term-list))
              (else term-list))))
  (define (variable p) (car p))
  (define (terms p) (cdr p))
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  
  ;; representation of terms and term lists
(define (sparse-termlist? term-list)
  (let ((t (car term-list)))
    (cond ((and (pair? t) ;; looks like a sparse list
                (number? (first t))
                (or (pair? (second t)) ;; or sparse with nested poly
                    (number? (second t))
                    (empty-termlist? (second t)))) #t)
          ((or (number? t) ;; looks dense
               (pair? t)
               (empty-termlist? term-list)) #f) ;; or dense with a nested poly
          (else (error "badly formed term: SPARSE-TERMLIST?" t term-list)))))
(define (sort-sparse-terms term-list)
  (sort term-list (lambda(t1 t2)
                    (> (order t1)
                       (order t2)))))
  (define (should-be-sparse? term-list)
    ;; sparse or dense term-list -> bool
    ;; if more than half of term-list is zeroes, return true
    ;; reasoning:
    ;; - number of elements used for sparse list is (non-zero elements * 2)
    ;; - number of elements used for dense list is (highest order)
    (define (count-zeroes term-list)
      ;; term-list -> (highest order, zeroes)
      (let iter ((length 0)
                 (zeroes 0)
                 (TL (if (sparse-termlist? term-list)
                         (sparse-to-dense term-list)
                         term-list)))
        (if (empty-termlist? TL)
            (list zeroes length)
            (iter (1+ length)
                  (if (=zero? (car TL))
                      (1+ zeroes)
                      zeroes)
                  (cdr TL)))))
    (let ((stats (if (sparse-termlist? term-list) ;; do appropriate measurement
                     (list (- (1+ (order (sparse-first-term term-list)))
                              (length term-list))
                           (1+ (order (sparse-first-term term-list))))
                     (count-zeroes term-list))))
      (let ((zero-elements (first stats))
            (highest-order (second stats)))
        (> (/ zero-elements highest-order)
           (/ 1 2)))))
  (define (sparse-to-dense term-list)
    (let iter ((old-list (reverse term-list))
               (new-list (the-empty-termlist)))
      (if (empty-termlist? old-list)
          new-list
          (iter (rest-terms old-list)
                (adjoin-term-dense (sparse-first-term old-list)
                                   new-list)))))
  (define (dense-to-sparse term-list)
    (let iter ((old-list (reverse term-list))
               (old-order 0)
               (new-list (the-empty-termlist)))
      (if (empty-termlist? old-list)
          new-list
          (iter (rest-terms old-list)
                (1+ old-order)
                (adjoin-term-sparse (make-sparse-term old-order
                                                      (coeff (dense-first-term old-list)))
                                    new-list)))))
  (define (make-sparse-term order coeff)
    (list order coeff))
  (define (dense-termlist-order term-list)
    (1- (length term-list)))
  (define (dense-first-term term-list)
    (make-sparse-term (dense-termlist-order term-list)
                      (car term-list)))
  (define (sparse-first-term term-list)
    (car term-list))
  (define (first-term term-list)
    (if (sparse-termlist? term-list)
        (sparse-first-term term-list)
        (dense-first-term term-list)))
  (define (adjoin-term-sparse term term-list)
    (cons term term-list))
  (define (adjoin-term-dense term term-list)
    ;; if term is exactly 1 order above top of list, adjoin
    ;; if term is more than 1 order above, adjoin 0 and recurse
    (let ((top-order (dense-termlist-order term-list)))
      (cond ((= (1+ top-order) (order term))
             (cons (coeff term) term-list))
            ((<= top-order (order term))
             (adjoin-term-dense term (cons 0 term-list)))
            (else (error "term is lower order than top of list: ADJOIN-TERM-DENSE" term term-list top-order)))))

  ;; ;; I wrote the versions below which can insert into the middle of the list,
  ;; ;; before remembering that a footnote in the text excuses this.
  ;;
  ;; (define (adjoin-term-sparse term term-list)
  ;;   ;; if term is higher order, cons to list
  ;;   ;; if term is lower order than top of list, try to insert in the middle
  ;;   (let ((top-order (order (sparse-first-term term-list))))
  ;;     (cond ((<= (1+ top-order) (order term))
  ;;            (cons term term-list))
  ;;           (else (adjoin-term-sparse (sparse-first-term term-list)
  ;;                                     (adjoin-term-sparse term
  ;;                                                         (rest-terms term-list)))))))
  ;; (define (adjoin-term-dense term term-list)
  ;;   ;; if term is 1 order above top of list, adjoin
  ;;   ;; if term is more than 1 order above, adjoin 0 and recurse
  ;;   ;; if term is lower order than top of list, try to insert in the middle
  ;;   (let ((top-order (dense-termlist-order term-list)))
  ;;     (cond ((= (1+ top-order) (order term))
  ;;            (cons (coeff term) term-list))
  ;;           ((<= top-order (order term))
  ;;            (adjoin-term-dense term (cons 0 term-list)))
  ;;           (else (adjoin-term-dense (dense-first-term term-list)
  ;;                                    (adjoin-term-dense term
  ;;                                                       (rest-terms term-list)))))))

  (define (adjoin-term term term-list)
    (if (=zero? (coeff term))
        term-list
        (if (or (empty-termlist? term-list)
                (sparse-termlist? term-list))
            (adjoin-term-sparse term term-list)
            (adjoin-term-dense term term-list))))
  (define (the-empty-termlist) '())
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))
  (define (order term) (first term))
  (define (coeff term) (second term))
  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (terms p1) (terms p2)))
        (error "Polys not in same var: ADD-POLY" (list p1 p2))))
  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (terms p1) (terms p2)))
        (error "Polys not in same var: MUL-POLY" (list p1 p2))))
  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term
                     t1 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2))
                    (adjoin-term
                     t2 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term
                     (make-sparse-term (order t1)
                                       (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
  
  ;; interface to rest of the system
  (define (tag p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'make 'polynomial
       (lambda (var terms) (tag (make-poly var terms))))
  (define (if-1st-poly-make-2nd-poly t1 t2)
    (if (and (eqv? 'polynomial (type-tag t1))
             (not (eqv? 'polynomial (type-tag t2))))
        (tag (make-poly (variable (contents t1)) (list t2)))
        t2))
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let* ((t2 (first-term L)) ;; If one coeff is a poly, make the other a poly
               (t1-coeff (if-1st-poly-make-2nd-poly (coeff t2) (coeff t1)))
               (t2-coeff (if-1st-poly-make-2nd-poly (coeff t1) (coeff t2))))
          
          (adjoin-term
           (make-sparse-term (+ (order t1) (order t2))
                             (mul t1-coeff t2-coeff))
           (mul-term-by-all-terms t1 (rest-terms L))))))
  (define (terms-=zero? L)
    (or (empty-termlist? L)
        (and (=zero? (coeff (first-term L)))
             (terms-=zero? (rest-terms L)))))
  (define (poly-=zero? p)
    (terms-=zero? (terms p)))
  (put '=zero? '(polynomial) poly-=zero?)
  (define (neg-terms TL)
    (let ((negterm (if (sparse-termlist? TL)
                       (lambda(t)
                         (make-sparse-term (order t) (neg (coeff t))))
                       (lambda(t)
                         (neg (coeff t))))))
      (map negterm TL)))
  (define (sub-terms T1 T2)
    (add-terms T1 (neg-terms T2)))
  (define (neg-poly p)
    (make-poly (variable p)
               (neg-terms (terms p))))
  (put 'neg '(polynomial)
       (lambda (p1) (tag (neg-poly p1))))
  (define (sub-poly p1 p2)
    (add-poly p1 (neg-poly p2)))
  (put 'sub '(polynomial polynomial)
       (lambda (p1 p2) (tag (sub-poly p1 p2))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (trivial-poly? poly)
  (and (= 1 (length (terms poly)))
       (= 0 (order (first-term (terms poly))))))
;;; TODO: get working once cross-variable comparisons can be done
(put 'project 'polynomial
     (lambda (p)
       (if (not (trivial-poly? p))
           #f
           (coeff (first-term (terms p))))))
(define (equ?-terms t1 t2)
  (and (= (order t1)
          (order t2))
       (equ? (coeff t1)
             (coeff t2))))
(define (equ?-termlists tl1 tl2)
         (let iter ((term-list1 tl1)
                    (term-list2 tl2))
           (cond ((and (empty-termlist? term-list1)
                       (empty-termlist? term-list2))
                  #t)
                 ((or (empty-termlist? term-list1)
                      (empty-termlist? term-list2))
                  #f)
                 ((equ?-terms (first-term term-list1)
                              (first-term term-list2))
                  (iter (rest-terms term-list1)
                        (rest-terms term-list2)))
                 (else #f))))
(define (equ?-poly p q)
  (cond ((and (trivial-poly? p)
              (trivial-poly? q))
         (equ? (coeff (first-term (terms p)))
               (coeff (first-term (terms q)))))
        ((same-variable? (variable p) (variable q))
         (equ?-termlists (terms p) (terms q)))
        ((trivial-poly? p)
         (equ?-poly (make-poly (variable q) (terms p))
                    q))
        ((trivial-poly? q)
         (equ?-poly p
                    (make-poly (variable p) (terms q))))
        (else (error "different vars not supported yet : EQU?-POLY" p q))))
(put 'equ? '(polynomial polynomial)
     equ?-poly)
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
;; polynomial procedures
;  'done)
(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (real-part z) (apply-generic 'real-part z))
(define (imag-part z) (apply-generic 'imag-part z))
(define (magnitude z) (apply-generic 'magnitude z))
(define (angle z) (apply-generic 'angle z))
;; Now we begin to change code for support
;; These will be named slightly different so the primitive
;; functions aren't shadowed
(define (square x) (mul x 2))
(define (sine x) (apply-generic 'sine x)) ;; (sin)
(define (cosine x) (apply-generic 'cosine x)); (cos)
(define (square-root x) (apply-generic 'square-root x));(sqrt)
(define (arctan x y) (apply-generic 'arctan x y));(atan)

(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'sine '(scheme-number)
       (lambda (x) (tag (sin x))))
  (put 'cosine '(scheme-number)
       (lambda (x) (tag (cos x))))
  (put 'square-root '(scheme-number)
       (lambda (x) (tag (sqrt x))))
  (put 'arctan '(scheme-number scheme-number)
       (lambda (x y) (tag (atan x y))))
  (put 'make 'scheme-number (lambda (x) (tag x)))
  'done)

(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (first x))
  (define (denom x) (second x))
  (define (make-rat n d)
    (list n d))
  (define (add-rat x y)
    (make-rat (add (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (sub (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (mul (numer x) (numer y))
              (mul (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (mul (numer x) (denom y))
              (mul (denom x) (numer y))))
  ;; interface to rest of the system
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'numer '(rational) numer)
  (put 'denom '(rational) denom)
  (put 'sine '(rational)
       (lambda(r) ((get 'sine '(scheme-number))
                   (div (numer r) (denom r)))))
  (put 'cosine '(rational)
       (lambda(r) ((get 'cosine '(scheme-number))
                   (div (numer r) (denom r)))))
  (put 'square-root '(rational)
       (lambda(r) ((get 'square-root '(scheme-number))
                   (div (numer r) (denom r)))))
  (put 'arctan '(rational)
       (lambda(r s) ((get 'arctan '(scheme-number))
                     (div (numer r) (denom r)) (div (numer s) (denom s)))))
  'done)

;; for future use
(define (numer r)
  ((get 'numer '(rational))
   (contents r)))
(define (denom r)
  ((get 'denom '(rational))
   (contents r)))

(define (make-rational n d)
  ((get 'make 'rational) n d))

(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (square-root (add (square (real-part z))
                      (square (imag-part z)))))
  (define (angle z)
    (arctan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (mul r (cosine a)) (mul r (sine a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z) (mul (magnitude z) (cosine (angle z))))
  (define (imag-part z) (mul (magnitude z) (sine (angle z))))
  (define (make-from-real-imag x y)
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-complex-package)
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  ;; let's make these generic
  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (sub (real-part z1) (real-part z2))
                         (sub (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
                       (add (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (div (magnitude z1) (magnitude z2))
                       (sub (angle z1) (angle z2))))
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))
  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle))

(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(define (project x)
  (let ((t1 (type-tag x)))
    (let ((p (get 'project t1)))
      (if p
          (p (contents x))
          #f))))

(define (drop x)
  (if (not (pair? x))
      x
      (let ((projected (project x)))
        (cond ((eqv? projected #f)
               x)
              ((equ? x projected)
               (drop projected))
              (else x)))))

(put 'project 'rational
     (lambda(num)
       ((get 'numer '(rational))
        num)))
(put 'project 'real
     (lambda(num)
       (round num)))
;; projecting a complex number may return something other than a single number
(put 'project 'complex
     (lambda(num)
       (let ((r ((get 'real-part '(complex)) num)))
         (if (number? (contents r))
             (make-real (contents r))
             r))))

;; equality testing with complex numbers also changes
(define (equ? x y) (apply-generic 'equ? x y))
(define (install-equ?)
  (put 'equ? '(scheme-number scheme-number)
       (lambda(x y) (= x y)))
  (put 'equ? '(complex complex)
       (lambda(x y)
         (let ((t1 (type-tag x))
               (t2 (type-tag y)))
           (cond ((and (eqv? t1 'polar)
                       (eqv? t2 'polar))
                  (and (equ? (apply-generic 'magnitude x)
                             (apply-generic 'magnitude y))
                       (equ? (apply-generic 'angle x)
                             (apply-generic 'angle y))))
                 (else
                  (and (equ? (apply-generic 'real-part x)
                             (apply-generic 'real-part y))
                       (equ? (apply-generic 'imag-part x)
                             (apply-generic 'imag-part y))))))))
  (put 'equ? '(rational rational)
       (lambda(x y)
         (and (equ? ((get 'numer '(rational)) x)
                 ((get 'numer '(rational)) y))
              (equ? ((get 'denom '(rational)) x)
                 ((get 'denom '(rational)) y)))))
  (put 'equ? '(real real)
       (lambda(x y) (= x y))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (=zero? x) (apply-generic '=zero? x))
(define (install-=zero?)
  (put '=zero? '(scheme-number)
       (lambda(x) (= x 0)))
  (put '=zero? '(complex)
       (lambda(x)
         (apply-generic '=zero? x)))
  (let ((magnitude (get 'magnitude '(polar))))
    (put '=zero? '(polar)
         (lambda(x)
           (= 0 (magnitude x)))))
  (let ((real-part (get 'real-part '(rectangular)))
        (imag-part (get 'imag-part '(rectangular))))
    (put '=zero? '(rectangular)
         (lambda(x)
           (and (=zero? (real-part x))
                (=zero? (imag-part x))))))
  (put '=zero? '(rational)
       (lambda(x)
         (or (=zero? ((get 'numer '(rational)) x))
             (=zero? ((get 'denom '(rational)) x))))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<op-table>>
<<type-table>>
<<sqrt>>
<<echo>>
<<smarter-type-tagging>>
<<attach-tag-fixed>>
<<list-indices>>
<<tower-predicates>>
<<apply-generic-raiseto>>
<<generic-arithmetic-rational-functions>>
<<real-package>>
<<eqzero?-rf>>
<<real-package>>

<<tower-coercions-rf>>

<<polynomial-rf-top>>
<<polynomial-projection>>
<<polynomial-division>>
<<polynomial-rf-bottom>>

<<generic-negation>>

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)
(install-real-package)
(install-equ?)
(install-=zero?)
(install-polynomial-package)
(install-negation)

<<gen-math-tests>>

(mattcheck "raise success"
           (raise 78)
           (make-rational 78 1))
(mattcheck "raise fail"
           (raise (make-polynomial 'x '((3 2)(1 1))))
           #f)
(mattcheck "apply-generic 1"
           (add 1 (make-rational 3 5))
           (make-rational 8 5))
(mattcheck "apply-generic 2"
           (add (make-real 2)
                (make-complex-from-mag-ang 3 5))
           (make-complex-from-real-imag 2.850986556389679 -2.8767728239894153))
(mattcheck "drop 1"
           (drop (make-complex-from-real-imag 5 0))
           5)
(mattcheck "drop 2"
           (drop (make-real 5))
           5)
(mattcheck "drop 3"
           (drop (make-rational 5 1))
           5)
(mattcheck "complex with nested rational"
           (make-complex-from-real-imag 2 (make-rational 3 5))
           (cons 'complex (cons 'rectangular (cons 2 (list 'rational 3 5)))))
(mattcheck "math on complex with nested rational"
           (add (make-complex-from-real-imag 2 (make-rational 3 5))
                (make-complex-from-mag-ang (make-rational 3 5) 2))
           (cons 'complex (cons 'rectangular
                                (cons (list 'rational 8.751559490358574 5)
                                      (list 'rational 28.639461402385223 25)))))
(mattcheck "polynomial = zero"
           (=zero? (make-polynomial 'x '((0 0)))))
(mattcheck "polynomial != zero" #f
           (=zero? (make-polynomial 'x '((1 1)(0 1)))))

(define p1 '((100 1)(2 2)(0 1)))
(define p2 (list (list 7 (make-polynomial 'x '((3 2))))))
(define p3 '((100 1)(2 1)(0 3)))
(define p4 '((100 -1)(2 -2)(0 -1)))
(define p5 '(8 2 5 -3 -7))
(define p7 '((1 1)(0 1)))
(define p6 '((3 1)(0 1)))
(define p66 '(1 0 0 1))
(define p77 '(1 1))
(define p8 (make-polynomial 'x '((2 1) (0 1))))
(define p9 (make-polynomial 'x '((3 1) (0 1))))
(define p98 (make-rational p9 p8))
  (mattcheck "polynomial addition"
             (add (make-polynomial 'x p1)
                  (make-polynomial 'x p1))
             '(polynomial x (100 2)(2 4)(0 2)))
  (mattcheck "polynomial multiplication"
             (mul (make-polynomial 'x p1)
                  (make-polynomial 'x p1))
             '(polynomial x (200 1) (102 4) (100 2) (4 4) (2 4) (0 1)))
  (mattcheck "nested polynomial addition"
             (add (make-polynomial 'x p2)
                  (make-polynomial 'x p1))
             '(polynomial x (100 1) (7 (polynomial x (3 2))) (2 2) (0 1)))
  (mattcheck "nested polynomial mult"
             (mul (make-polynomial 'x p2)
                  (make-polynomial 'x p1))
             '(polynomial x (107 (polynomial x (3 2))) (9 (polynomial x (3 4))) (7 (polynomial x (3 2)))))
  (mattcheck "negation scheme-number"
             (neg 5) -5)
  (mattcheck "negation rational"
             (neg (make-rational 1 5))
             (make-rational -1 5))
  (mattcheck "negation rectangular complex"
             (neg (make-complex-from-real-imag 3 7))
             (make-complex-from-real-imag -3 -7))
  (mattcheck "negation polar complex"
             (neg (make-complex-from-mag-ang 3 7))
             (make-complex-from-mag-ang -3 7))

  (mattcheck "negation polynomials"
             (neg (make-polynomial 'x p1))
             (make-polynomial 'x p4))
  (mattcheck "polynomial subtraction"
             (sub (make-polynomial 'x p1)
                  (make-polynomial 'x p3))
             '(polynomial x 1 0 -2))
  (mattcheck "polynomial division 1"
             (div (make-polynomial 'x p6)
                  (make-polynomial 'x p7))
             '((polynomial x 1 -1 1) (polynomial x)))
  (mattcheck "polynomial division 2"
             (div (make-polynomial 'x p7)
                  (make-polynomial 'x p6))
             '((polynomial x) (polynomial x 1 1)))
  (mattcheck "polynomial division 3"
             (div (make-polynomial 'x p66)
                  (make-polynomial 'x p77))
             '((polynomial x 1 -1 1) (polynomial x)))
  (mattcheck "rational functions"
             (add p98 p98)
             '(rational (polynomial x 2 0 2 2 0 2) (polynomial x 1 0 2 0 1)))
\end{minted}

\begin{verbatim}
<...>
SUCCEED at rational functions
\end{verbatim}

\subsection{Exercise 2.94: GCD of polynomials}
\label{sec:orgb0185a3}

\subsubsection{Question}
\label{sec:org34d7fe5}

Using \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{div-terms}, implement the procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{remainder-terms}
and use this to define \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{gcd-terms} as above. Now write a procedure
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{gcd-poly} that computes the polynomial GCD of two polys. (The
procedure should signal an error if the two polys are not in the same variable.)
Install in the system a generic operation \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{greatest-common-divisor}
that reduces to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{gcd-poly} for polynomials and to ordinary
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{gcd} for ordinary numbers. As a test, try

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define p1 (make-polynomial
            'x '((4 1) (3 -1) (2 -2) (1 2))))
(define p2 (make-polynomial 'x '((3 1) (1 -1))))
(greatest-common-divisor p1 p2)
\end{minted}

and check your result by hand.

\subsubsection{Answer}
\label{sec:org40ad362}

An important change had to be made here. Dense termlists are padded with zeroes,
while sparse ones are not. This is fine for addition (and subtraction on the
right side) but it can be a problem otherwise. So \texttt{dense-first-term} needs to
find the first non-zero coefficient to return, \texttt{rest-terms} needs to chop off
leading zeroes for dense lists, and \texttt{adjoin-term-sparse} should probably be
amended to skip zeroes so this doesn't happen with sparse lists.

I've also had to rescue some ``refugees'' from \hyperref[sec:orgaed8b73]{Exercise 2.92}, such as \texttt{map-terms}. 

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(use-srfis '(1))
(define (install-polynomial-package) 'no)
;; internal procedures
;; representation of poly
(define (make-poly variable term-list)
  (cons variable
        (convert-termlist-if-reasonable term-list)))
(define (convert-termlist-if-reasonable term-list)
  (if (empty-termlist? term-list)
      term-list
      (cond ((sparse-termlist? term-list)
             (let ((tl (sort-sparse-terms term-list)))
               (if (should-be-sparse? tl)
                   tl
                   (sparse-to-dense tl))))
            ((should-be-sparse? term-list)
             (dense-to-sparse term-list))
            (else term-list))))
(define (variable p) (car p))
(define (terms p) (cdr p))
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

;; representation of terms and term lists
(define (sparse-termlist? term-list)
  (if (empty-termlist? term-list)
      #t
      (let ((t (car term-list)))
        (cond ((and (pair? t) ;; looks like a sparse list
                    (number? (first t))
                    (or (pair? (second t)) ;; or sparse with nested poly
                        (number? (second t)))) #t)
              ((or (number? t) ;; looks dense
                   (and (pair? t)
                        (not (number? (first t))));; or dense with a nested poly
                   (eq? #f t)) #f) ;; or dense with an empty entry
              (else (error "badly formed term: SPARSE-TERMLIST?" t term-list))))))
(define (sort-sparse-terms term-list)
  (sort term-list (lambda(t1 t2)
                    (> (order t1)
                       (order t2)))))
(define (should-be-sparse? term-list)
  ;; sparse or dense term-list -> bool
  ;; if more than half of term-list is zeroes, return true
  ;; reasoning:
  ;; - number of elements used for sparse list is (non-zero elements * 2)
  ;; - number of elements used for dense list is (highest order)
  (define (count-zeroes term-list)
    ;; term-list -> (highest order, zeroes)
    (let iter ((length 0)
               (zeroes 0)
               (TL (if (sparse-termlist? term-list)
                       (sparse-to-dense term-list)
                       term-list)))
      (if (empty-termlist? TL)
          (list zeroes length)
          (iter (1+ length)
                (if (=zero? (car TL))
                    (1+ zeroes)
                    zeroes)
                (cdr TL)))))
  (let ((stats (if (sparse-termlist? term-list) ;; do appropriate measurement
                   (list (- (1+ (order (sparse-first-term term-list)))
                            (length term-list))
                         (1+ (order (sparse-first-term term-list))))
                   (count-zeroes term-list))))
    (let ((zero-elements (first stats))
          (highest-order (second stats)))
      (> (/ zero-elements highest-order)
         (/ 1 2)))))
(define (sparse-to-dense term-list)
  (let iter ((old-list (reverse term-list))
             (new-list (the-empty-termlist)))
    (if (empty-termlist? old-list)
        new-list
        (iter (rest-terms old-list)
              (adjoin-term-dense (sparse-first-term old-list)
                                 new-list)))))
(define (dense-to-sparse term-list)
  (let iter ((old-list (reverse term-list))
             (old-order 0)
             (new-list (the-empty-termlist)))
    (if (empty-termlist? old-list)
        new-list
        (iter (rest-terms old-list)
              (1+ old-order)
              (adjoin-term-sparse (make-sparse-term old-order
                                                    (coeff (dense-first-term old-list)))
                                  new-list)))))
(define (make-sparse-term order coeff)
  (list order coeff))
(define (dense-rest-terms term-list)
  (let ((rest (cdr term-list)))
    (if (empty-termlist? rest)
        (the-empty-termlist)
        (let ((c (car rest)))
          (if (eq? #f c)
              (dense-rest-terms rest)
              rest)))))
(define (rest-terms term-list)
  (if (sparse-termlist? term-list)
      (cdr term-list)
      (dense-rest-terms term-list)))
(define (dense-termlist-order term-list)
  (1- (length term-list)))
(define (sparse-termlist-order term-list)
  (order (sparse-first-term term-list)))
(define (termlist-order term-list)
  (if (sparse-termlist? term-list)
      (sparse-termlist-order term-list)
      (dense-termlist-order term-list)))
;; always O(n)
(define (dense-first-term term-list)
  (let ((c (car term-list)))
    (if (eq? #f c)
        (dense-first-term (dense-rest-terms term-list))
        (make-sparse-term (dense-termlist-order term-list) c))))
(define (sparse-first-term term-list)
  (car term-list))
(define (add-sparse-term-to-sparse-term t1 t2)
  (make-sparse-term (order t1)
                    (add (coeff t1) (coeff t2))))
(define (first-term term-list)
  (if (sparse-termlist? term-list)
      (sparse-first-term term-list)
      (dense-first-term term-list)))
(define (adjoin-term-sparse term term-list)
  ;; if term is higher order, cons to list
  ;; if equal, replace or add
  ;; if term is lower order than top of list, try to insert in the middle
  (if  (empty-termlist? term-list)
       (cons term term-list)
       (let ((top-order (order (sparse-first-term term-list))))
         (cond ((<= (1+ top-order) (order term))
                (cons term term-list))
               ((= top-order (order term))
                (if (=zero? (coeff (sparse-first-term term-list)))
                    ;; replace if it's zero
                    (cons term (rest-terms term-list))
                    ;; and add if it's not
                    (let ((result (add-sparse-term-to-sparse-term term
                                                                  (sparse-first-term term-list))))
                      (cons result
                            (rest-terms term-list))))) 
               (else (adjoin-term-sparse (sparse-first-term term-list)
                                         (adjoin-term-sparse term
                                                             (rest-terms term-list))))))))
(define (adjoin-term-dense term term-list)
  ;; if term is lower order than top of list, try to insert in the middle
  (let ((top-order (dense-termlist-order term-list)))
    (cond ((= (1+ top-order) (order term))
           ;; if term is 1 order above top of list, adjoin
           (cons (coeff term) term-list))
          ;; if term shares order with top of list, 
          ((= top-order (order term))
           (if (=zero? (coeff (dense-first-term term-list)))
               ;; replace if it's zero
               (cons (coeff term)
                     (rest-terms term-list))
               ;; and add if it's not
               (let ((result (add-sparse-term-to-sparse-term term
                                                             (dense-first-term term-list))))
                 (cons (coeff result)
                       (rest-terms term-list)))))
          ((< top-order (order term))
           (adjoin-term-dense term (cons #f term-list)))
          ;; if term is more than 1 order above, adjoin 0 and recurse
          (else (adjoin-term-dense (dense-first-term term-list)
                                   (adjoin-term-dense term
                                                      (rest-terms term-list)))))))

(define (adjoin-term term term-list)
  (if (=zero? (coeff term))
      term-list
      (if (or (empty-termlist? term-list)
              (sparse-termlist? term-list))
          (adjoin-term-sparse term term-list)
          (adjoin-term-dense term term-list))))
(define (the-empty-termlist) '())
(define (empty-termlist? term-list)
  (or (null? term-list)
      (and (eq? #f (car term-list))
           (empty-termlist? (cdr term-list)))))
(define (order term) (first term))
(define (coeff term) (second term))
(define (map-terms f tl)
  ;; f is called (f order coeff)
  (let iter ((result '())
             (term-list tl))
    (if (empty-termlist? term-list)
        (reverse result)
        (iter (cons (let ((t (first-term term-list)))
                      (f (order t) (coeff t)))
                    result)
              (rest-terms term-list)))))
(define (map2-terms f tl1 tl2)
  (let iter ((result '())
             (term-list1 tl1)
             (term-list2 tl2))
    (if (or (empty-termlist? term-list1)
            (empty-termlist? term-list2))
        (reverse result)
        (iter (cons (let ((t1 (first-term term-list))
                          (t2 (first-term term-list)))
                      (f (order t1) (coeff t1)
                         (order t2) (coeff t2)))
                    result)
              (rest-terms term-list1)
              (rest-terms term-list2)))))
(define (add-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
      (make-poly (variable p1)
                 (add-terms (terms p1) (terms p2)))
      (error "Polys not in same var: ADD-POLY" (list p1 p2))))
(define (mul-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
      (make-poly (variable p1)
                 (mul-terms (terms p1) (terms p2)))
      (error "Polys not in same var: MUL-POLY" (list p1 p2))))
(define (add-terms L1 L2)
  (cond ((empty-termlist? L1) L2)
        ((empty-termlist? L2) L1)
        (else
         (let ((t1 (first-term L1))
               (t2 (first-term L2)))
           (cond ((> (order t1) (order t2))
                  (adjoin-term
                   t1 (add-terms (rest-terms L1) L2)))
                 ((< (order t1) (order t2))
                  (adjoin-term
                   t2 (add-terms L1 (rest-terms L2))))
                 (else
                  (adjoin-term
                   (make-sparse-term (order t1)
                                     (add (coeff t1) (coeff t2)))
                   (add-terms (rest-terms L1)
                              (rest-terms L2)))))))))
(define (mul-terms L1 L2)
  (if (empty-termlist? L1)
      (the-empty-termlist)
      (add-terms (mul-term-by-all-terms (first-term L1) L2)
                 (mul-terms (rest-terms L1) L2))))

;; interface to rest of the system
(define (tag p) (attach-tag 'polynomial p))
(put 'add '(polynomial polynomial)
     (lambda (p1 p2) (tag (add-poly p1 p2))))
(put 'mul '(polynomial polynomial)
     (lambda (p1 p2) (tag (mul-poly p1 p2))))
(put 'make 'polynomial
     (lambda (var terms) (tag (make-poly var terms))))
(define (if-1st-poly-make-2nd-poly t1 t2)
  (if (and (eqv? 'polynomial (type-tag t1))
           (not (eqv? 'polynomial (type-tag t2))))
      (tag (make-poly (variable (contents t1)) (list t2)))
      t2))
(define (mul-term-by-all-terms t1 L)
  (if (empty-termlist? L)
      (the-empty-termlist)
      (let* ((t2 (first-term L)) ;; If one coeff is a poly, make the other a poly
             (t1-coeff (if-1st-poly-make-2nd-poly (coeff t2) (coeff t1)))
             (t2-coeff (if-1st-poly-make-2nd-poly (coeff t1) (coeff t2))))
        
        (adjoin-term
         (make-sparse-term (+ (order t1) (order t2))
                           (mul t1-coeff t2-coeff))
         (mul-term-by-all-terms t1 (rest-terms L))))))
(define (terms-=zero? L)
  (or (empty-termlist? L)
      (and (=zero? (coeff (first-term L)))
           (terms-=zero? (rest-terms L)))))
(define (poly-=zero? p)
  (terms-=zero? (terms p)))
(put '=zero? '(polynomial) poly-=zero?)
(define (neg-terms TL)
  (let ((negterm (lambda(o c)
                   (make-sparse-term o (neg c)))))
    (map-terms negterm TL)))
(define (sub-terms T1 T2)
  (add-terms T1 (neg-terms T2)))
(define (neg-poly p)
  (make-poly (variable p)
             (neg-terms (terms p))))
(put 'neg '(polynomial)
     (lambda (p1) (tag (neg-poly p1))))
(define (sub-poly p1 p2)
  (add-poly p1 (neg-poly p2)))
(put 'sub '(polynomial polynomial)
     (lambda (p1 p2) (tag (sub-poly p1 p2))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (remainder-terms tl1 tl2)
  (second (div-terms tl1 tl2)))
(define (gcd-terms a b)
  (if (empty-termlist? b)
      a
      (gcd-terms b (remainder-terms a b))))
(define (gcd-poly p q)
  (cond ((same-variable? (variable p) (variable q))
         (make-poly (variable p)
                    (gcd-terms (terms p) (terms q))))
        ((trivial-poly? p)
         (gcd-poly (make-poly (variable q) (terms p))
                   q))
        ((trivial-poly? q)
         (gcd-poly p
                   (make-poly (variable p) (terms q))))
        (else (error "different vars not supported : GCD-POLY" p q))))
(put 'greatest-common-divisor '(polynomial polynomial)
     (lambda (x y) (tag (gcd-poly x y))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (install-gcd) 'no)
(put 'greatest-common-divisor '(scheme-number scheme-number)
     (lambda (x y) (attach-tag 'scheme-number (gcd x y))))
(put 'greatest-common-divisor '(real real)
     (lambda (x) (attach-tag 'scheme-number (gcd x y))))
;'done)
(define (greatest-common-divisor a b)
  (apply-generic 'greatest-common-divisor a b))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<op-table>>
<<type-table>>
<<sqrt>>
<<echo>>
<<smarter-type-tagging>>
<<attach-tag-fixed>>
<<list-indices>>
<<tower-predicates>>
<<apply-generic-raiseto>>
<<generic-arithmetic-rational-functions>>
<<real-package>>
<<eqzero?-rf>>
<<real-package>>

<<tower-coercions-rf>>

<<polynomial-densepadding-top>>
<<polynomial-projection>>
<<polynomial-division>>
<<polynomial-gcd>>
<<polynomial-rf-bottom>>

<<generic-negation>>
<<generic-gcd>>

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)
(install-real-package)
(install-equ?)
(install-=zero?)
(install-polynomial-package)
(install-negation)

<<gen-math-tests>>

(mattcheck "raise success"
           (raise 78)
           (make-rational 78 1))
(mattcheck "raise fail"
           (raise (make-polynomial 'x '((3 2)(1 1))))
           #f)
(mattcheck "apply-generic 1"
           (add 1 (make-rational 3 5))
           (make-rational 8 5))
(mattcheck "apply-generic 2"
           (add (make-real 2)
                (make-complex-from-mag-ang 3 5))
           (make-complex-from-real-imag 2.850986556389679 -2.8767728239894153))
(mattcheck "drop 1"
           (drop (make-complex-from-real-imag 5 0))
           5)
(mattcheck "drop 2"
           (drop (make-real 5))
           5)
(mattcheck "drop 3"
           (drop (make-rational 5 1))
           5)
(mattcheck "complex with nested rational"
           (make-complex-from-real-imag 2 (make-rational 3 5))
           (cons 'complex (cons 'rectangular (cons 2 (list 'rational 3 5)))))
(mattcheck "math on complex with nested rational"
           (add (make-complex-from-real-imag 2 (make-rational 3 5))
                (make-complex-from-mag-ang (make-rational 3 5) 2))
           (cons 'complex (cons 'rectangular
                                (cons (list 'rational 8.751559490358574 5)
                                      (list 'rational 28.639461402385223 25)))))
(mattcheck "polynomial = zero"
           (=zero? (make-polynomial 'x '((0 0)))))
(mattcheck "polynomial != zero" #f
           (=zero? (make-polynomial 'x '((1 1)(0 1)))))

(define p1 '((100 1)(2 2)(0 1)))
(define p2 (list (list 7 (make-polynomial 'x '((3 2))))))
(define p3 '((100 1)(2 1)(0 3)))
(define p4 '((100 -1)(2 -2)(0 -1)))
(define p5 '(8 2 5 -3 -7))
(define p7 '((1 1)(0 1)))
(define p6 '((3 1)(0 1)))
(define p66 '(1 0 0 1))
(define p77 '(1 1))
(define p8 (make-polynomial 'x '((2 1) (0 1))))
(define p9 (make-polynomial 'x '((3 1) (0 1))))
(define p98 (make-rational p9 p8))
  (mattcheck "polynomial addition"
             (add (make-polynomial 'x p1)
                  (make-polynomial 'x p1))
             '(polynomial x (100 2)(2 4)(0 2)))
  (mattcheck "polynomial multiplication"
             (mul (make-polynomial 'x p1)
                  (make-polynomial 'x p1))
             '(polynomial x (200 1) (102 4) (100 2) (4 4) (2 4) (0 1)))
  (mattcheck "nested polynomial addition"
             (add (make-polynomial 'x p2)
                  (make-polynomial 'x p1))
             '(polynomial x (100 1) (7 (polynomial x (3 2))) (2 2) (0 1)))
  (mattcheck "nested polynomial mult"
             (mul (make-polynomial 'x p2)
                  (make-polynomial 'x p1))
             '(polynomial x (107 (polynomial x (3 2))) (9 (polynomial x (3 4))) (7 (polynomial x (3 2)))))
(define p10 (make-polynomial
            'x '((4 1) (3 -1) (2 -2) (1 2))))
(define p11 (make-polynomial 'x '((3 1) (1 -1))))
  (mattcheck "negation scheme-number"
             (neg 5) -5)
  (mattcheck "negation rational"
             (neg (make-rational 1 5))
             (make-rational -1 5))
  (mattcheck "negation rectangular complex"
             (neg (make-complex-from-real-imag 3 7))
             (make-complex-from-real-imag -3 -7))
  (mattcheck "negation polar complex"
             (neg (make-complex-from-mag-ang 3 7))
             (make-complex-from-mag-ang -3 7))

  (mattcheck "negation polynomials"
             (neg (make-polynomial 'x p1))
             (make-polynomial 'x p4))
  (mattcheck "polynomial subtraction"
             (sub (make-polynomial 'x p1)
                  (make-polynomial 'x p3))
             '(polynomial x 1 #f -2))
  (mattcheck "polynomial division 1"
             (div (make-polynomial 'x p6)
                  (make-polynomial 'x p7))
             '((polynomial x 1 -1 1) (polynomial x)))
  (mattcheck "polynomial division 2"
             (div (make-polynomial 'x p7)
                  (make-polynomial 'x p6))
             '((polynomial x) (polynomial x 1 1)))
  (mattcheck "polynomial division 3"
             (div (make-polynomial 'x p66)
                  (make-polynomial 'x p77))
             '((polynomial x 1 -1 1) (polynomial x)))
  (mattcheck "rational functions"
             (add p98 p98)
             '(rational (polynomial x 2 #f 2 2 #f 2) (polynomial x 1 #f 2 #f 1)))
  (mattcheck "GCD for integers"
             (greatest-common-divisor 72 30)
             6)
  (mattcheck "GCD for polys"
             (greatest-common-divisor p10 p11)
             '(polynomial x -1 1 #f))
\end{minted}

\begin{verbatim}
<...>
SUCCEED at polynomial subtraction
SUCCEED at polynomial division 1
SUCCEED at polynomial division 2
SUCCEED at polynomial division 3
SUCCEED at rational functions
SUCCEED at GCD for integers
SUCCEED at GCD for polys
\end{verbatim}

\subsection{Exercise 2.95: a quirk in rational functions}
\label{sec:org70890f0}
\subsubsection{Question}
\label{sec:org114cea4}

Define \(P_1\), \(P_2\), and
\(P_3\) to be the polynomials

$\backslash$[
\begin{array}{l@{{}:}l}
	P_1 	& \quad x^2 - 2x + 1, \\
	P_2 	& \quad 11x^2 + 7, \\
	P_3 	& \quad 13x + 5.
\end{array}
$\backslash$]

Now define \(Q_1\) to be the product of \(P_1\) and \(P_2\) and \(Q_2\) to be
the product of \(P_1\) and \(P_3\), and use \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{greatest-common-divisor}
(@ref\{Exercise 2.94\}) to compute the GCD of \(Q_1\)
and \(Q_2\).

Note that the answer is not the same as \(P_1\). This example introduces
noninteger operations into the computation, causing difficulties with the GCD
algorithm. \footnote{In an implementation like MIT Scheme, this produces a polynomial
that is indeed a divisor of \(Q_1\) and \(Q_2\), but with rational coefficients.
In many other Scheme systems, in which division of integers can produce
limited-precision decimal numbers, we may fail to get a valid divisor.} To
understand what is happening, try tracing \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{gcd-terms} while computing
the GCD or try performing the division by hand.

\subsubsection{Answer}
\label{sec:org31e8847}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<op-table>>
<<type-table>>
<<sqrt>>
<<echo>>
<<smarter-type-tagging>>
<<attach-tag-fixed>>
<<list-indices>>
<<tower-predicates>>
<<apply-generic-raiseto>>
<<generic-arithmetic-rational-functions>>
<<real-package>>
<<eqzero?-rf>>
<<real-package>>

<<tower-coercions-rf>>

<<polynomial-densepadding-top>>
<<polynomial-projection>>
<<polynomial-division>>
<<polynomial-gcd>>
<<polynomial-rf-bottom>>

<<generic-negation>>
<<generic-gcd>>

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)
(install-real-package)
(install-equ?)
(install-=zero?)
(install-polynomial-package)
(install-negation)

(define p1 (make-polynomial 'x '(1 2 1)))
(define p2 (make-polynomial 'x '((2 11)(0 7))))
(define p3 (make-polynomial 'x '(13 5)))
(define q1 (mul p1 p2))
(define q2 (mul p1 p3))
(echo "P1: " p1)
(echo "P2: " p2)
(echo "P3: " p3)
(echo "Q1: " q1)
(echo "Q2: " q2)
(echo "GCD(Q1, Q2): " (greatest-common-divisor q1 q2))
\end{minted}

\begin{verbatim}
P1:  (polynomial x 1 2 1) 
P2:  (polynomial x 11 #f 7) 
P3:  (polynomial x 13 5) 
Q1:  (polynomial x 11 22 18 14 7) 
Q2:  (polynomial x 13 31 23 5) 
GCD(Q1, Q2):  (polynomial x 1458/169 2916/169 1458/169) 
\end{verbatim}

\subsection{Exercise 2.96: pseudodivision of polynomials}
\label{sec:org7c924f5}

\subsubsection{Text formulas}
\label{sec:orgb11a073}


More precisely, if \(P\) and \(Q\) are polynomials, let \(O_1\) be the order of
\(P\) (i.e., the order of the largest term of \(P\)) and let \(O_2\) be the
order of \(Q\). Let \(c\) be the leading coefficient of \(Q\). Then it can be
shown that, if we multiply \(P\) by the \textbf{integerizing factor} \(c^{1 + O_1 -
O_2}\), the resulting polynomial can be divided by \(Q\) by using the
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{div-terms} algorithm without introducing any fractions. The operation
of multiplying the dividend by this constant and then dividing is sometimes
called the \textbf{pseudodivision} of \(P\) by \(Q\). The remainder of the division is
called the \textbf{pseudoremainder}.

\subsubsection{Questions 1 and 2}
\label{sec:orge8662c5}

\begin{enumerate}
\item Implement the procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{pseudoremainder-terms}, which is just like
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{remainder-terms} except that it multiplies the dividend by the
integerizing factor described above before calling \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{div-terms}.
Modify \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{gcd-terms} to use \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{pseudoremainder-terms}, and
verify that \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{greatest-common-divisor} now produces an answer with
integer coefficients on the example in \hyperref[sec:org70890f0]{Exercise 2.95}.

\item The GCD now has integer coefficients, but they are larger than those of
\(P_1\). Modify \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{gcd-terms} so that it removes common factors from
the coefficients of the answer by dividing all the coefficients by their
(integer) greatest common divisor.
\end{enumerate}

\subsubsection{Answers 1 and 2}
\label{sec:org17813f8}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (remainder-terms tl1 tl2)
  (second (div-terms tl1 tl2)))
(define (find-integerizing-factor p q)
  (let ((o1 (termlist-order p))
        (o2 (termlist-order q))
        (c (coeff (first-term q))))
    (expt c (+ 1 (- o1 o2)))))
(define (pseudoremainder-terms tl1 tl2)
  (let* ((intize (find-integerizing-factor tl1 tl2))
         (tl1-prime (mul-terms tl1
                               (list (make-sparse-term 0 intize)))))
    (second (div-terms tl1-prime tl2))))
(define (gcd-terms a b)
  (let ((result (if (empty-termlist? b)
                    a
                    (gcd-terms b (pseudoremainder-terms a b)))))
    (if (empty-termlist? result)
        (the-empty-termlist)
        (let ((list-gcd (reduce gcd "ERROR"
                                (map-terms (lambda(o c) c) result))))
          (map-terms (lambda(o c)
                       (make-sparse-term o
                                         (div c list-gcd)))
                     result)))))
(define (gcd-poly p q)
  (cond ((same-variable? (variable p) (variable q))
         (make-poly (variable p)
                    (gcd-terms (terms p) (terms q))))
        ((trivial-poly? p)
         (gcd-poly (make-poly (variable q) (terms p))
                   q))
        ((trivial-poly? q)
         (gcd-poly p
                   (make-poly (variable p) (terms q))))
        (else (error "different vars not supported : GCD-POLY" p q))))
(put 'greatest-common-divisor '(polynomial polynomial)
     (lambda (x y) (tag (gcd-poly x y))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<op-table>>
<<type-table>>
<<sqrt>>
<<echo>>
<<smarter-type-tagging>>
<<attach-tag-fixed>>
<<list-indices>>
<<tower-predicates>>
<<apply-generic-raiseto>>
<<generic-arithmetic-rational-functions>>
<<real-package>>
<<eqzero?-rf>>
<<real-package>>

<<tower-coercions-rf>>

<<polynomial-densepadding-top>>
<<polynomial-projection>>
<<polynomial-division>>
<<polynomial-gcd-pseudo>>
<<polynomial-rf-bottom>>

<<generic-negation>>
<<generic-gcd>>

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)
(install-real-package)
(install-equ?)
(install-=zero?)
(install-polynomial-package)
(install-negation)

<<gen-math-tests>>

(mattcheck "raise success"
           (raise 78)
           (make-rational 78 1))
(mattcheck "raise fail"
           (raise (make-polynomial 'x '((3 2)(1 1))))
           #f)
(mattcheck "apply-generic 1"
           (add 1 (make-rational 3 5))
           (make-rational 8 5))
(mattcheck "apply-generic 2"
           (add (make-real 2)
                (make-complex-from-mag-ang 3 5))
           (make-complex-from-real-imag 2.850986556389679 -2.8767728239894153))
(mattcheck "drop 1"
           (drop (make-complex-from-real-imag 5 0))
           5)
(mattcheck "drop 2"
           (drop (make-real 5))
           5)
(mattcheck "drop 3"
           (drop (make-rational 5 1))
           5)
(mattcheck "complex with nested rational"
           (make-complex-from-real-imag 2 (make-rational 3 5))
           (cons 'complex (cons 'rectangular (cons 2 (list 'rational 3 5)))))
(mattcheck "math on complex with nested rational"
           (add (make-complex-from-real-imag 2 (make-rational 3 5))
                (make-complex-from-mag-ang (make-rational 3 5) 2))
           (cons 'complex (cons 'rectangular
                                (cons (list 'rational 8.751559490358574 5)
                                      (list 'rational 28.639461402385223 25)))))
(mattcheck "polynomial = zero"
           (=zero? (make-polynomial 'x '((0 0)))))
(mattcheck "polynomial != zero" #f
           (=zero? (make-polynomial 'x '((1 1)(0 1)))))

(define p1 '((100 1)(2 2)(0 1)))
(define p2 (list (list 7 (make-polynomial 'x '((3 2))))))
(define p3 '((100 1)(2 1)(0 3)))
(define p4 '((100 -1)(2 -2)(0 -1)))
(define p5 '(8 2 5 -3 -7))
(define p7 '((1 1)(0 1)))
(define p6 '((3 1)(0 1)))
(define p66 '(1 0 0 1))
(define p77 '(1 1))
(define p8 (make-polynomial 'x '((2 1) (0 1))))
(define p9 (make-polynomial 'x '((3 1) (0 1))))
(define p98 (make-rational p9 p8))
(mattcheck "polynomial addition"
           (add (make-polynomial 'x p1)
                (make-polynomial 'x p1))
           '(polynomial x (100 2)(2 4)(0 2)))
(mattcheck "polynomial multiplication"
           (mul (make-polynomial 'x p1)
                (make-polynomial 'x p1))
           '(polynomial x (200 1) (102 4) (100 2) (4 4) (2 4) (0 1)))
(mattcheck "nested polynomial addition"
           (add (make-polynomial 'x p2)
                (make-polynomial 'x p1))
           '(polynomial x (100 1) (7 (polynomial x (3 2))) (2 2) (0 1)))
(mattcheck "nested polynomial mult"
           (mul (make-polynomial 'x p2)
                (make-polynomial 'x p1))
           '(polynomial x (107 (polynomial x (3 2))) (9 (polynomial x (3 4))) (7 (polynomial x (3 2)))))
(define p10 (make-polynomial
             'x '((4 1) (3 -1) (2 -2) (1 2))))
(define p11 (make-polynomial 'x '((3 1) (1 -1))))
(mattcheck "negation scheme-number"
           (neg 5) -5)
(mattcheck "negation rational"
           (neg (make-rational 1 5))
           (make-rational -1 5))
(mattcheck "negation rectangular complex"
           (neg (make-complex-from-real-imag 3 7))
           (make-complex-from-real-imag -3 -7))
(mattcheck "negation polar complex"
           (neg (make-complex-from-mag-ang 3 7))
           (make-complex-from-mag-ang -3 7))

(mattcheck "negation polynomials"
           (neg (make-polynomial 'x p1))
           (make-polynomial 'x p4))
(mattcheck "polynomial subtraction"
           (sub (make-polynomial 'x p1)
                (make-polynomial 'x p3))
           '(polynomial x 1 #f -2))
(mattcheck "polynomial division 1"
           (div (make-polynomial 'x p6)
                (make-polynomial 'x p7))
           '((polynomial x 1 -1 1) (polynomial x)))
(mattcheck "polynomial division 2"
           (div (make-polynomial 'x p7)
                (make-polynomial 'x p6))
           '((polynomial x) (polynomial x 1 1)))
(mattcheck "polynomial division 3"
           (div (make-polynomial 'x p66)
                (make-polynomial 'x p77))
           '((polynomial x 1 -1 1) (polynomial x)))
(mattcheck "rational functions"
           (add p98 p98)
           '(rational (polynomial x 2 #f 2 2 #f 2) (polynomial x 1 #f 2 #f 1)))
(mattcheck "GCD for integers"
           (greatest-common-divisor 72 30)
           6)
(mattcheck "GCD for polys"
           (greatest-common-divisor p10 p11)
           '(polynomial x -1 1 #f))
(let* ((p1p (make-polynomial 'x '(1 2 1)))
       (p2p (make-polynomial 'x '((2 11)(0 7))))
       (p3p (make-polynomial 'x '(13 5)))
       (q1p (mul p1p p2p))
       (q2p (mul p1p p3p)))
  (mattcheck "greatest-common-divisor integerizing for polynomials"
             (greatest-common-divisor q1p q2p)
             p1p))
\end{minted}

\begin{verbatim}
<...>
SUCCEED at greatest-common-divisor integerizing for polynomials
\end{verbatim}

\subsection{Exercise 2.97: reducing terms of rational functions}
\label{sec:org70d9ab5}

\subsubsection{Questions 1 and 2}
\label{sec:orgfd269e9}

\begin{enumerate}
\item Implement this algorithm as a procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{reduce-terms} that takes
two term lists \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{n} and \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{d} as arguments and returns a
list \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{nn}, \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{dd}, which are \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{n} and
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{d} reduced to lowest terms via the algorithm given above. Also
write a procedure \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{reduce-poly}, analogous to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{add-poly},
that checks to see if the two polys have the same variable. If so,
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{reduce-poly} strips off the variable and passes the problem to
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{reduce-terms}, then reattaches the variable to the two term lists
supplied by \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{reduce-terms}.

\item Define a procedure analogous to \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{reduce-terms} that does what the
original \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{make-rat} did for integers:

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
   (define (reduce-integers n d)
     (let ((g (gcd n d)))
       (list (/ n g) (/ d g))))
\end{minted}

and define \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{reduce} as a generic operation that calls
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{apply-generic} to dispatch to either \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{reduce-poly} (for
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{polynomial} arguments) or \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{reduce-integers} (for
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{scheme-number} arguments). You can now easily make the
rational-arithmetic package reduce fractions to lowest terms by having
\mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{make-rat} call \mintinline[breaklines=true,breakanywhere=true,linenos=true]{scheme}{reduce} before combining the given
numerator and denominator to form a rational number. The system now handles
rational expressions in either integers or polynomials. To test your program,
try the example at the beginning of this extended exercise:
\end{enumerate}

\subsubsection{Answers 1 and 2}
\label{sec:org02cc174}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (remainder-terms tl1 tl2)
  (second (div-terms tl1 tl2)))
(define (find-integerizing-factor o1 o2 c)
  (expt c (+ 1 (- o1 o2))))
(define (pseudoremainder-terms tl1 tl2)
  (let* ((intize (find-integerizing-factor (termlist-order tl1)
                                           (termlist-order tl2)
                                           (coeff (first-term tl2))))
         (tl1-prime (mul-terms tl1
                               (list (make-sparse-term 0 intize)))))
    (second (div-terms tl1-prime tl2))))

(define (gcd-of-coeffs-in-terms tl)
  (reduce gcd 'ERROR
          (map-terms (lambda(o c) c) tl)))
(define (map-coeffs f tl)
  (map-terms (lambda(o c)
               (make-sparse-term o
                                 (f c)))
             tl))
(define (div-coeffs-by-gcd tl)
  (let ((g (gcd-of-coeffs-in-terms tl)))
    (map-coeffs (lambda(c)(div c g)) tl)))
(define (gcd-terms a b)
  (let ((result (if (empty-termlist? b)
                    a
                    (gcd-terms b (pseudoremainder-terms a b)))))
    (if (empty-termlist? result)
        (the-empty-termlist)
        (div-coeffs-by-gcd result))))
(define (gcd-poly p q)
  (cond ((same-variable? (variable p) (variable q))
         (make-poly (variable p)
                    (gcd-terms (terms p) (terms q))))
        ((trivial-poly? p)
         (gcd-poly (make-poly (variable q) (terms p))
                   q))
        ((trivial-poly? q)
         (gcd-poly p
                   (make-poly (variable p) (terms q))))
        (else (error "different vars not supported : GCD-POLY" p q))))
(put 'greatest-common-divisor '(polynomial polynomial)
     (lambda (x y) (tag (gcd-poly x y))))
(define (reduce-terms n d)
  (let* ((nd-gcd (gcd-terms n d))
         (intize (find-integerizing-factor (termlist-order nd-gcd)
                                           (max (termlist-order n)
                                                (termlist-order d))
                                           (coeff (first-term nd-gcd))))
         (nn (div-terms (mul-terms
                         n (list (make-sparse-term
                                  0 intize)))
                        nd-gcd))
         (dd (div-terms (mul-terms
                         d (list (make-sparse-term
                                  0 intize)))
                        nd-gcd)))
    (if (or (not (empty-termlist? (second nn)))
            (not (empty-termlist? (second dd))))
        (error "unexpected remainder from term reduction : REDUCE-TERMS" n d)
        (list (div-coeffs-by-gcd (first nn))
              (div-coeffs-by-gcd (first dd))))))
(define (reduce-poly p q)
  (let ((mp (lambda(target-poly reduced)
              (let ((v (variable target-poly)))
                (list (make-poly v (first reduced))
                      (make-poly v (second reduced)))))))
    (cond ((same-variable? (variable p) (variable q))
           (mp p (reduce-terms (terms p) (terms q))))
          ((trivial-poly? p)
           (mp q (reduce-terms (terms p) (terms q))))
          ((trivial-poly? q)
           (mp p (reduce-terms (terms p) (terms q))))
          (else (error "different vars not supported : GCD-POLY" p q)))))
(put 'reduce '(polynomial polynomial)
     (lambda(p q)
       (let ((result (reduce-poly p q)))
         (list (tag (first result))
               (tag (second result))))))
\end{minted}

\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (generic-reduce a b)
  (apply-generic 'reduce a b))
(define (reduce-integers n d)
  (if (and (integer? n)
           (integer? d))
      (let ((g (gcd n d)))
        (list (/ n g) (/ d g)))
      (list n d)))
(put 'reduce '(scheme-number scheme-number)
     reduce-integers)
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (real-part z) (apply-generic 'real-part z))
(define (imag-part z) (apply-generic 'imag-part z))
(define (magnitude z) (apply-generic 'magnitude z))
(define (angle z) (apply-generic 'angle z))
;; Now we begin to change code for support
;; These will be named slightly different so the primitive
;; functions aren't shadowed
(define (square x) (mul x 2))
(define (sine x) (apply-generic 'sine x)) ;; (sin)
(define (cosine x) (apply-generic 'cosine x)); (cos)
(define (square-root x) (apply-generic 'square-root x));(sqrt)
(define (arctan x y) (apply-generic 'arctan x y));(atan)

(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'sine '(scheme-number)
       (lambda (x) (tag (sin x))))
  (put 'cosine '(scheme-number)
       (lambda (x) (tag (cos x))))
  (put 'square-root '(scheme-number)
       (lambda (x) (tag (sqrt x))))
  (put 'arctan '(scheme-number scheme-number)
       (lambda (x y) (tag (atan x y))))
  (put 'make 'scheme-number (lambda (x) (tag x)))
  'done)

(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (first x))
  (define (denom x) (second x))
  (define (make-rat n d)
    (generic-reduce n d))
  (define (add-rat x y)
    (make-rat (add (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (sub (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (mul (numer x) (numer y))
              (mul (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (mul (numer x) (denom y))
              (mul (denom x) (numer y))))
  ;; interface to rest of the system
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'numer '(rational) numer)
  (put 'denom '(rational) denom)
  (put 'sine '(rational)
       (lambda(r) ((get 'sine '(scheme-number))
                   (div (numer r) (denom r)))))
  (put 'cosine '(rational)
       (lambda(r) ((get 'cosine '(scheme-number))
                   (div (numer r) (denom r)))))
  (put 'square-root '(rational)
       (lambda(r) ((get 'square-root '(scheme-number))
                   (div (numer r) (denom r)))))
  (put 'arctan '(rational)
       (lambda(r s) ((get 'arctan '(scheme-number))
                     (div (numer r) (denom r)) (div (numer s) (denom s)))))
  'done)

;; for future use
(define (numer r)
  ((get 'numer '(rational))
   (contents r)))
(define (denom r)
  ((get 'denom '(rational))
   (contents r)))

(define (make-rational n d)
  ((get 'make 'rational) n d))

(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (square-root (add (square (real-part z))
                      (square (imag-part z)))))
  (define (angle z)
    (arctan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (mul r (cosine a)) (mul r (sine a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z) (mul (magnitude z) (cosine (angle z))))
  (define (imag-part z) (mul (magnitude z) (sine (angle z))))
  (define (make-from-real-imag x y)
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-complex-package)
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  ;; let's make these generic
  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (sub (real-part z1) (real-part z2))
                         (sub (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
                       (add (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (div (magnitude z1) (magnitude z2))
                       (sub (angle z1) (angle z2))))
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))
  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle))

(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(define (project x)
  (let ((t1 (type-tag x)))
    (let ((p (get 'project t1)))
      (if p
          (p (contents x))
          #f))))

(define (drop x)
  (if (not (pair? x))
      x
      (let ((projected (project x)))
        (cond ((eqv? projected #f)
               x)
              ((equ? x projected)
               (drop projected))
              (else x)))))

(put 'project 'rational
     (lambda(num)
       ((get 'numer '(rational))
        num)))
(put 'project 'real
     (lambda(num)
       (round num)))
;; projecting a complex number may return something other than a single number
(put 'project 'complex
     (lambda(num)
       (let ((r ((get 'real-part '(complex)) num)))
         (if (number? (contents r))
             (make-real (contents r))
             r))))

;; equality testing with complex numbers also changes
(define (equ? x y) (apply-generic 'equ? x y))
(define (install-equ?)
  (put 'equ? '(scheme-number scheme-number)
       (lambda(x y) (= x y)))
  (put 'equ? '(complex complex)
       (lambda(x y)
         (let ((t1 (type-tag x))
               (t2 (type-tag y)))
           (cond ((and (eqv? t1 'polar)
                       (eqv? t2 'polar))
                  (and (equ? (apply-generic 'magnitude x)
                             (apply-generic 'magnitude y))
                       (equ? (apply-generic 'angle x)
                             (apply-generic 'angle y))))
                 (else
                  (and (equ? (apply-generic 'real-part x)
                             (apply-generic 'real-part y))
                       (equ? (apply-generic 'imag-part x)
                             (apply-generic 'imag-part y))))))))
  (put 'equ? '(rational rational)
       (lambda(x y)
         (and (equ? ((get 'numer '(rational)) x)
                 ((get 'numer '(rational)) y))
              (equ? ((get 'denom '(rational)) x)
                 ((get 'denom '(rational)) y)))))
  (put 'equ? '(real real)
       (lambda(x y) (= x y))))
\end{minted}
\begin{minted}[breaklines=true,breakanywhere=true,linenos=true]{scheme}
(load "mattcheck2.scm")
<<op-table>>
<<type-table>>
<<sqrt>>
<<echo>>
<<smarter-type-tagging>>
<<attach-tag-fixed>>
<<list-indices>>
<<tower-predicates>>
<<apply-generic-raiseto>>
<<generic-arithmetic-rf-reduce>>
<<real-package>>
<<eqzero?-rf>>
<<real-package>>

<<tower-coercions-rf>>

<<polynomial-densepadding-top>>
<<polynomial-projection>>
<<polynomial-division>>
<<polynomial-gcd-reduce>>
<<polynomial-rf-bottom>>

<<generic-negation>>
<<generic-gcd>>
<<generic-reduce-function>>

(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-scheme-number-package)
(install-real-package)
(install-equ?)
(install-=zero?)
(install-polynomial-package)
(install-negation)

<<gen-math-tests>>

(mattcheck "raise success"
           (raise 78)
           (make-rational 78 1))
(mattcheck "raise fail"
           (raise (make-polynomial 'x '((3 2)(1 1))))
           #f)
(mattcheck "apply-generic 1"
           (add 1 (make-rational 3 5))
           (make-rational 8 5))
(mattcheck "apply-generic 2"
           (add (make-real 2)
                (make-complex-from-mag-ang 3 5))
           (make-complex-from-real-imag 2.850986556389679 -2.8767728239894153))
(mattcheck "drop 1"
           (drop (make-complex-from-real-imag 5 0))
           5)
(mattcheck "drop 2"
           (drop (make-real 5))
           5)
(mattcheck "drop 3"
           (drop (make-rational 5 1))
           5)
(mattcheck "complex with nested rational"
           (make-complex-from-real-imag 2 (make-rational 3 5))
           (cons 'complex (cons 'rectangular (cons 2 (list 'rational 3 5)))))
(mattcheck "math on complex with nested rational"
           (add (make-complex-from-real-imag 2 (make-rational 3 5))
                (make-complex-from-mag-ang (make-rational 3 5) 2))
           (cons 'complex (cons 'rectangular
                                (cons (list 'rational 8.751559490358574 5)
                                      (list 'rational 28.639461402385223 25)))))
(mattcheck "polynomial = zero"
           (=zero? (make-polynomial 'x '((0 0)))))
(mattcheck "polynomial != zero" #f
           (=zero? (make-polynomial 'x '((1 1)(0 1)))))

(define p1 '((100 1)(2 2)(0 1)))
(define p2 (list (list 7 (make-polynomial 'x '((3 2))))))
(define p3 '((100 1)(2 1)(0 3)))
(define p4 '((100 -1)(2 -2)(0 -1)))
(define p5 '(8 2 5 -3 -7))
(define p7 '((1 1)(0 1)))
(define p6 '((3 1)(0 1)))
(define p66 '(1 0 0 1))
(define p77 '(1 1))
(define p8 (make-polynomial 'x '((2 1) (0 1))))
(define p9 (make-polynomial 'x '((3 1) (0 1))))
(define p98 (make-rational p9 p8))
(mattcheck "polynomial addition"
           (add (make-polynomial 'x p1)
                (make-polynomial 'x p1))
           '(polynomial x (100 2)(2 4)(0 2)))
(mattcheck "polynomial multiplication"
           (mul (make-polynomial 'x p1)
                (make-polynomial 'x p1))
           '(polynomial x (200 1) (102 4) (100 2) (4 4) (2 4) (0 1)))
(mattcheck "nested polynomial addition"
           (add (make-polynomial 'x p2)
                (make-polynomial 'x p1))
           '(polynomial x (100 1) (7 (polynomial x (3 2))) (2 2) (0 1)))
(mattcheck "nested polynomial mult"
           (mul (make-polynomial 'x p2)
                (make-polynomial 'x p1))
           '(polynomial x (107 (polynomial x (3 2))) (9 (polynomial x (3 4))) (7 (polynomial x (3 2)))))
(define p10 (make-polynomial
             'x '((4 1) (3 -1) (2 -2) (1 2))))
(define p11 (make-polynomial 'x '((3 1) (1 -1))))
(mattcheck "negation scheme-number"
           (neg 5) -5)
(mattcheck "negation rational"
           (neg (make-rational 1 5))
           (make-rational -1 5))
(mattcheck "negation rectangular complex"
           (neg (make-complex-from-real-imag 3 7))
           (make-complex-from-real-imag -3 -7))
(mattcheck "negation polar complex"
           (neg (make-complex-from-mag-ang 3 7))
           (make-complex-from-mag-ang -3 7))

(mattcheck "negation polynomials"
           (neg (make-polynomial 'x p1))
           (make-polynomial 'x p4))
(mattcheck "polynomial subtraction"
           (sub (make-polynomial 'x p1)
                (make-polynomial 'x p3))
           '(polynomial x 1 #f -2))
(mattcheck "polynomial division 1"
           (div (make-polynomial 'x p6)
                (make-polynomial 'x p7))
           '((polynomial x 1 -1 1) (polynomial x)))
(mattcheck "polynomial division 2"
           (div (make-polynomial 'x p7)
                (make-polynomial 'x p6))
           '((polynomial x) (polynomial x 1 1)))
(mattcheck "polynomial division 3"
           (div (make-polynomial 'x p66)
                (make-polynomial 'x p77))
           '((polynomial x 1 -1 1) (polynomial x)))
(mattcheck "rational functions (unsimplified, should fail)"
           (add p98 p98)
           '(rational (polynomial x 2 #f 2 2 #f 2) (polynomial x 1 #f 2 #f 1)))
(mattcheck "GCD for integers"
           (greatest-common-divisor 72 30)
           6)
(mattcheck "GCD for polys"
           (greatest-common-divisor p10 p11)
           '(polynomial x -1 1 #f))
(let* ((p1p (make-polynomial 'x '(1 2 1)))
       (p2p (make-polynomial 'x '((2 11)(0 7))))
       (p3p (make-polynomial 'x '(13 5)))
       (q1p (mul p1p p2p))
       (q2p (mul p1p p3p)))
  (mattcheck "greatest-common-divisor integerizing for polynomials"
             (greatest-common-divisor q1p q2p)
             p1p))
(mattcheck "rational functions (correctly simplified)"
           (add p98 p98)
           '(rational (polynomial x 1 #f #f 1) (polynomial x 1 #f 1)))
\end{minted}

\begin{verbatim}
<...>
FAIL at rational functions (unsimplified, should fail)
expected: (rational (polynomial x 2 #f 2 2 #f 2) (polynomial x 1 #f 2 #f 1))
returned: (rational (polynomial x 1 #f #f 1) (polynomial x 1 #f 1))
<...>
SUCCEED at greatest-common-divisor integerizing for polynomials
SUCCEED at rational functions (correctly simplified)
\end{verbatim}

This exercise has been pretty exhausting. I'll likely take a step back here,
maybe work on other projects a bit, and dive back in for Chapter 3.
\end{document}